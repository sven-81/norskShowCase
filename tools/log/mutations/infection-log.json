{"stats":{"totalMutantsCount":222,"killedCount":206,"notCoveredCount":0,"escapedCount":16,"errorCount":0,"syntaxErrorCount":0,"skippedCount":0,"ignoredCount":0,"timeOutCount":0,"msi":92.79,"mutationCodeCoverage":100,"coveredCodeMsi":92.79},"escaped":[{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app;\n\nuse norsk\\api\\app\\identityAccessManagement\\Session;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\routing\\Router;\nuse Slim\\App;\nclass NorskApi\n{\n    public function __construct(private readonly Logger $logger, private readonly Router $router, private readonly App $app, private readonly AppLoggerConfig $appLoggerConfig)\n    {\n    }\n    public function run(): void\n    {\n        $this->logger->info(LogMessage::fromString('Starting Norsk API'));\n        $this->app->addBodyParsingMiddleware();\n        $this->app->addRoutingMiddleware();\n        $this->app->addErrorMiddleware($this->appLoggerConfig->isDisplayErrorDetails(), $this->appLoggerConfig->isLogErrors(), $this->appLoggerConfig->isLogErrorDetails());\n        $session = Session::create();\n        $this->router->run($this->app, $session);\n        $this->app->run();\n        $session->destroy();\n        $this->logger->info(LogMessage::fromString('Stopping Norsk API'));\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app;\n\nuse norsk\\api\\app\\identityAccessManagement\\Session;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\routing\\Router;\nuse Slim\\App;\nclass NorskApi\n{\n    public function __construct(private readonly Logger $logger, private readonly Router $router, private readonly App $app, private readonly AppLoggerConfig $appLoggerConfig)\n    {\n    }\n    public function run(): void\n    {\n        $this->logger->info(LogMessage::fromString('Starting Norsk API'));\n        $this->app->addBodyParsingMiddleware();\n        $this->app->addRoutingMiddleware();\n        $this->app->addErrorMiddleware($this->appLoggerConfig->isDisplayErrorDetails(), $this->appLoggerConfig->isLogErrors(), $this->appLoggerConfig->isLogErrorDetails());\n        $session = Session::create();\n        $this->router->run($this->app, $session);\n        $this->app->run();\n        \n        $this->logger->info(LogMessage::fromString('Stopping Norsk API'));\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/NorskApi.php","originalStartLine":40},"diff":"@@ @@\n         $session = Session::create();\n         $this->router->run($this->app, $session);\n         $this->app->run();\n-        $session->destroy();\n+        \n         $this->logger->info(LogMessage::fromString('Stopping Norsk API'));\n     }\n }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.fc1d6c5477028f851c6627e2e4a2803d.infection.xml\n\n.                                                                   1 \/ 1 (100%)\n\nTime: 00:00.004, Memory: 18.00 MB\n\nOK (1 test, 6 assertions)"},{"mutator":{"mutatorName":"CastBool","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":142},"diff":"@@ @@\n         $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n         $logErrors = $logConfigItems['logErrors'];\n         $logErrorDetails = $logConfigItems['logErrorDetails'];\n-        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n+        return AppLoggerConfig::by($path, $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n     }\n     private static function readJwtConfig(array $auth): JwtConfig\n     {","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.7146b05620c7a5f52d95a11cc2e6f5a9.infection.xml\n\n.................................                                 33 \/ 33 (100%)\n\nTime: 00:00.016, Memory: 18.00 MB\n\nOK (33 tests, 58 assertions)"},{"mutator":{"mutatorName":"CastBool","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":142},"diff":"@@ @@\n         $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n         $logErrors = $logConfigItems['logErrors'];\n         $logErrorDetails = $logConfigItems['logErrorDetails'];\n-        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n+        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, $logErrors, (bool) $logErrorDetails);\n     }\n     private static function readJwtConfig(array $auth): JwtConfig\n     {","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.1692792890bdf9fe0957589d5c327401.infection.xml\n\n.................................                                 33 \/ 33 (100%)\n\nTime: 00:00.013, Memory: 18.00 MB\n\nOK (33 tests, 58 assertions)"},{"mutator":{"mutatorName":"CastBool","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":142},"diff":"@@ @@\n         $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n         $logErrors = $logConfigItems['logErrors'];\n         $logErrorDetails = $logConfigItems['logErrorDetails'];\n-        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n+        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, $logErrorDetails);\n     }\n     private static function readJwtConfig(array $auth): JwtConfig\n     {","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.d3cc9211fa89d4fd0a80faa14323c652.infection.xml\n\n.................................                                 33 \/ 33 (100%)\n\nTime: 00:00.014, Memory: 18.00 MB\n\nOK (33 tests, 58 assertions)"},{"mutator":{"mutatorName":"ArrayItemRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nclass AuthenticationAlgorithm\n{\n    private function __construct(private readonly string $algorithm)\n    {\n    }\n    public static function by(string $algorithm): self\n    {\n        self::ensureAlgorithmIsJwtValid($algorithm);\n        return new self($algorithm);\n    }\n    private static function ensureAlgorithmIsJwtValid(string $algorithm): void\n    {\n        $algorithmList = self::getAlgorithmList();\n        if (!in_array($algorithm, $algorithmList)) {\n            throw new InvalidArgumentException('Algorithm has no valid format');\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getAlgorithmList(): array\n    {\n        return ['HS256', 'HS384', 'HS512', 'PS256', 'PS384', 'PS512', 'RS256', 'RS384', 'RS512', 'ES256', 'ES256K', 'ES384', 'ES512', 'EdDSA'];\n    }\n    public function asString(): string\n    {\n        return $this->algorithm;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nclass AuthenticationAlgorithm\n{\n    private function __construct(private readonly string $algorithm)\n    {\n    }\n    public static function by(string $algorithm): self\n    {\n        self::ensureAlgorithmIsJwtValid($algorithm);\n        return new self($algorithm);\n    }\n    private static function ensureAlgorithmIsJwtValid(string $algorithm): void\n    {\n        $algorithmList = self::getAlgorithmList();\n        if (!in_array($algorithm, $algorithmList)) {\n            throw new InvalidArgumentException('Algorithm has no valid format');\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getAlgorithmList(): array\n    {\n        return ['HS384', 'HS512', 'PS256', 'PS384', 'PS512', 'RS256', 'RS384', 'RS512', 'ES256', 'ES256K', 'ES384', 'ES512', 'EdDSA'];\n    }\n    public function asString(): string\n    {\n        return $this->algorithm;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/AuthenticationAlgorithm.php","originalStartLine":39},"diff":"@@ @@\n      *\/\n     private static function getAlgorithmList(): array\n     {\n-        return ['HS256', 'HS384', 'HS512', 'PS256', 'PS384', 'PS512', 'RS256', 'RS384', 'RS512', 'ES256', 'ES256K', 'ES384', 'ES512', 'EdDSA'];\n+        return ['HS384', 'HS512', 'PS256', 'PS384', 'PS512', 'RS256', 'RS384', 'RS512', 'ES256', 'ES256K', 'ES384', 'ES512', 'EdDSA'];\n     }\n     public function asString(): string\n     {","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.51ac0a6be337daf79b822af9ca97b1f7.infection.xml\n\n..                                                                  2 \/ 2 (100%)\n\nTime: 00:00, Memory: 16.00 MB\n\nOK (2 tests, 4 assertions)"},{"mutator":{"mutatorName":"ConcatOperandRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse DateTimeImmutable;\nuse DateTimeZone;\nuse Psr\\Clock\\ClockInterface;\nclass Clock implements ClockInterface\n{\n    private const string EUROPE_BERLIN = 'Europe\/Berlin';\n    public function __construct(private DateTimeImmutable $clock)\n    {\n        $this->clock = $clock->setTimezone(new DateTimeZone(self::EUROPE_BERLIN));\n    }\n    public function now(): DateTimeImmutable\n    {\n        return new DateTimeImmutable('now', new DateTimeZone(self::EUROPE_BERLIN));\n    }\n    public function addSeconds(int $seconds): self\n    {\n        $newTime = $this->clock->modify('+' . $seconds . ' seconds');\n        $newTime = $newTime->setTimezone(new DateTimeZone(self::EUROPE_BERLIN));\n        return new self($newTime);\n    }\n    public function getTimestamp(): int\n    {\n        return $this->clock->getTimestamp();\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse DateTimeImmutable;\nuse DateTimeZone;\nuse Psr\\Clock\\ClockInterface;\nclass Clock implements ClockInterface\n{\n    private const string EUROPE_BERLIN = 'Europe\/Berlin';\n    public function __construct(private DateTimeImmutable $clock)\n    {\n        $this->clock = $clock->setTimezone(new DateTimeZone(self::EUROPE_BERLIN));\n    }\n    public function now(): DateTimeImmutable\n    {\n        return new DateTimeImmutable('now', new DateTimeZone(self::EUROPE_BERLIN));\n    }\n    public function addSeconds(int $seconds): self\n    {\n        $newTime = $this->clock->modify($seconds . ' seconds');\n        $newTime = $newTime->setTimezone(new DateTimeZone(self::EUROPE_BERLIN));\n        return new self($newTime);\n    }\n    public function getTimestamp(): int\n    {\n        return $this->clock->getTimestamp();\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/Clock.php","originalStartLine":30},"diff":"@@ @@\n     }\n     public function addSeconds(int $seconds): self\n     {\n-        $newTime = $this->clock->modify('+' . $seconds . ' seconds');\n+        $newTime = $this->clock->modify($seconds . ' seconds');\n         $newTime = $newTime->setTimezone(new DateTimeZone(self::EUROPE_BERLIN));\n         return new self($newTime);\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.d1bf756b9f159cc169338cf675f2821a.infection.xml\n\n...                                                                 3 \/ 3 (100%)\n\nTime: 00:00.001, Memory: 16.00 MB\n\nOK (3 tests, 4 assertions)"},{"mutator":{"mutatorName":"PregMatchRemoveCaret","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nclass JsonWebToken\n{\n    private function __construct(private readonly string $token)\n    {\n    }\n    public static function fromString(string $token): self\n    {\n        self::ensureTokenIsJwtValid($token);\n        return new self($token);\n    }\n    private static function ensureTokenIsJwtValid(string $token): void\n    {\n        if (!preg_match(\"\/^([a-zA-Z0-9_=]{4,36})\\\\.([a-zA-Z0-9_=]{4,})\\\\.([a-zA-Z0-9_\\\\-+\\\\\/=]{4,86})\\$\/\", $token)) {\n            throw new InvalidArgumentException('Token has no valid format');\n        }\n    }\n    public static function fromBearerString(string $bearerToken): self\n    {\n        $jwtToken = str_replace('Bearer ', '', $bearerToken);\n        return new self($jwtToken);\n    }\n    public function asString(): string\n    {\n        return $this->token;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nclass JsonWebToken\n{\n    private function __construct(private readonly string $token)\n    {\n    }\n    public static function fromString(string $token): self\n    {\n        self::ensureTokenIsJwtValid($token);\n        return new self($token);\n    }\n    private static function ensureTokenIsJwtValid(string $token): void\n    {\n        if (!preg_match(\"\/([a-zA-Z0-9_=]{4,36})\\\\.([a-zA-Z0-9_=]{4,})\\\\.([a-zA-Z0-9_\\\\-+\\\\\/=]{4,86})\\$\/\", $token)) {\n            throw new InvalidArgumentException('Token has no valid format');\n        }\n    }\n    public static function fromBearerString(string $bearerToken): self\n    {\n        $jwtToken = str_replace('Bearer ', '', $bearerToken);\n        return new self($jwtToken);\n    }\n    public function asString(): string\n    {\n        return $this->token;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JsonWebToken.php","originalStartLine":26},"diff":"@@ @@\n     }\n     private static function ensureTokenIsJwtValid(string $token): void\n     {\n-        if (!preg_match(\"\/^([a-zA-Z0-9_=]{4,36})\\\\.([a-zA-Z0-9_=]{4,})\\\\.([a-zA-Z0-9_\\\\-+\\\\\/=]{4,86})\\$\/\", $token)) {\n+        if (!preg_match(\"\/([a-zA-Z0-9_=]{4,36})\\\\.([a-zA-Z0-9_=]{4,})\\\\.([a-zA-Z0-9_\\\\-+\\\\\/=]{4,86})\\$\/\", $token)) {\n             throw new InvalidArgumentException('Token has no valid format');\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.6e690fc5895f217150e4260b9f61d88f.infection.xml\n\n...                                                                 3 \/ 3 (100%)\n\nTime: 00:00.001, Memory: 16.00 MB\n\nOK (3 tests, 5 assertions)"},{"mutator":{"mutatorName":"PregMatchRemoveDollar","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nclass JsonWebToken\n{\n    private function __construct(private readonly string $token)\n    {\n    }\n    public static function fromString(string $token): self\n    {\n        self::ensureTokenIsJwtValid($token);\n        return new self($token);\n    }\n    private static function ensureTokenIsJwtValid(string $token): void\n    {\n        if (!preg_match(\"\/^([a-zA-Z0-9_=]{4,36})\\\\.([a-zA-Z0-9_=]{4,})\\\\.([a-zA-Z0-9_\\\\-+\\\\\/=]{4,86})\\$\/\", $token)) {\n            throw new InvalidArgumentException('Token has no valid format');\n        }\n    }\n    public static function fromBearerString(string $bearerToken): self\n    {\n        $jwtToken = str_replace('Bearer ', '', $bearerToken);\n        return new self($jwtToken);\n    }\n    public function asString(): string\n    {\n        return $this->token;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nclass JsonWebToken\n{\n    private function __construct(private readonly string $token)\n    {\n    }\n    public static function fromString(string $token): self\n    {\n        self::ensureTokenIsJwtValid($token);\n        return new self($token);\n    }\n    private static function ensureTokenIsJwtValid(string $token): void\n    {\n        if (!preg_match(\"\/^([a-zA-Z0-9_=]{4,36})\\\\.([a-zA-Z0-9_=]{4,})\\\\.([a-zA-Z0-9_\\\\-+\\\\\/=]{4,86})\/\", $token)) {\n            throw new InvalidArgumentException('Token has no valid format');\n        }\n    }\n    public static function fromBearerString(string $bearerToken): self\n    {\n        $jwtToken = str_replace('Bearer ', '', $bearerToken);\n        return new self($jwtToken);\n    }\n    public function asString(): string\n    {\n        return $this->token;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JsonWebToken.php","originalStartLine":26},"diff":"@@ @@\n     }\n     private static function ensureTokenIsJwtValid(string $token): void\n     {\n-        if (!preg_match(\"\/^([a-zA-Z0-9_=]{4,36})\\\\.([a-zA-Z0-9_=]{4,})\\\\.([a-zA-Z0-9_\\\\-+\\\\\/=]{4,86})\\$\/\", $token)) {\n+        if (!preg_match(\"\/^([a-zA-Z0-9_=]{4,36})\\\\.([a-zA-Z0-9_=]{4,})\\\\.([a-zA-Z0-9_\\\\-+\\\\\/=]{4,86})\/\", $token)) {\n             throw new InvalidArgumentException('Token has no valid format');\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.b76fd26b8e49a7a33aea48a78be9a759.infection.xml\n\n...                                                                 3 \/ 3 (100%)\n\nTime: 00:00.001, Memory: 16.00 MB\n\nOK (3 tests, 5 assertions)"},{"mutator":{"mutatorName":"Concat","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException($throwable->getMessage() . 'Token expired: '),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":92},"diff":"@@ @@\n         } catch (Throwable $throwable) {\n             $this->logger->error($throwable);\n             return match (true) {\n-                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n+                $throwable instanceof ExpiredException => throw new RuntimeException($throwable->getMessage() . 'Token expired: '),\n                 $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                 $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                 default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.035aaa95b01585167bc2bbad70c9f9b2.infection.xml\n\n..........                                                        10 \/ 10 (100%)\n\nTime: 00:00.011, Memory: 18.00 MB\n\nOK (10 tests, 50 assertions)"},{"mutator":{"mutatorName":"ConcatOperandRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: '),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":92},"diff":"@@ @@\n         } catch (Throwable $throwable) {\n             $this->logger->error($throwable);\n             return match (true) {\n-                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n+                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: '),\n                 $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                 $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                 default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.adad48b6000ffa119b9f78ea4cac32e6.infection.xml\n\n..........                                                        10 \/ 10 (100%)\n\nTime: 00:00.015, Memory: 18.00 MB\n\nOK (10 tests, 50 assertions)"},{"mutator":{"mutatorName":"Concat","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException($throwable->getMessage() . 'Invalid token signature: '),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":95},"diff":"@@ @@\n             $this->logger->error($throwable);\n             return match (true) {\n                 $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n-                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n+                $throwable instanceof SignatureInvalidException => throw new RuntimeException($throwable->getMessage() . 'Invalid token signature: '),\n                 $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                 default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n             };","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.b14e49e780a03f5e1e7f07fdab7558fd.infection.xml\n\n..........                                                        10 \/ 10 (100%)\n\nTime: 00:00.011, Memory: 18.00 MB\n\nOK (10 tests, 50 assertions)"},{"mutator":{"mutatorName":"ConcatOperandRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: '),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":95},"diff":"@@ @@\n             $this->logger->error($throwable);\n             return match (true) {\n                 $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n-                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n+                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: '),\n                 $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                 default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n             };","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.15fed316d59ae3fb864e69b0c25ec67b.infection.xml\n\n..........                                                        10 \/ 10 (100%)\n\nTime: 00:00.011, Memory: 18.00 MB\n\nOK (10 tests, 50 assertions)"},{"mutator":{"mutatorName":"Concat","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException($throwable->getMessage() . 'Token not valid yet: '),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":98},"diff":"@@ @@\n             return match (true) {\n                 $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                 $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n-                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n+                $throwable instanceof BeforeValidException => throw new RuntimeException($throwable->getMessage() . 'Token not valid yet: '),\n                 default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n             };\n         }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.bfdd92f10129be993c283dca9643dfa3.infection.xml\n\n..........                                                        10 \/ 10 (100%)\n\nTime: 00:00.011, Memory: 18.00 MB\n\nOK (10 tests, 50 assertions)"},{"mutator":{"mutatorName":"ConcatOperandRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: '),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":98},"diff":"@@ @@\n             return match (true) {\n                 $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                 $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n-                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n+                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: '),\n                 default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n             };\n         }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.5c688ddebfeee7b2491090692cccc634.infection.xml\n\n..........                                                        10 \/ 10 (100%)\n\nTime: 00:00.011, Memory: 18.00 MB\n\nOK (10 tests, 50 assertions)"},{"mutator":{"mutatorName":"Concat","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException($throwable->getMessage() . 'Invalid token: '),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":101},"diff":"@@ @@\n                 $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                 $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                 $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n-                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n+                default => throw new RuntimeException($throwable->getMessage() . 'Invalid token: '),\n             };\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.d02e57590bf51c38bf3f7313208817d4.infection.xml\n\n..........                                                        10 \/ 10 (100%)\n\nTime: 00:00.011, Memory: 18.00 MB\n\nOK (10 tests, 50 assertions)"},{"mutator":{"mutatorName":"ConcatOperandRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: '),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":101},"diff":"@@ @@\n                 $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                 $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                 $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n-                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n+                default => throw new RuntimeException('Invalid token: '),\n             };\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.de5ae43e32d34c95edec10efe606c4f7.infection.xml\n\n..........                                                        10 \/ 10 (100%)\n\nTime: 00:00.010, Memory: 18.00 MB\n\nOK (10 tests, 50 assertions)"}],"timeouted":[],"killed":[{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app;\n\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\config\\DbConfig;\nuse norsk\\api\\app\\identityAccessManagement\\IdentityAccessManagementFactory;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\persistence\\DbConnection;\nuse norsk\\api\\app\\persistence\\MysqliWrapper;\nuse norsk\\api\\app\\routing\\Context;\nuse norsk\\api\\app\\routing\\Router;\nuse norsk\\api\\user\\UsersReader;\nuse Slim\\Factory\\AppFactory;\nclass Factory\n{\n    private Logger $logger;\n    private DbConnection $dbConnection;\n    private function __construct(private readonly AppConfig $appConfig, private readonly DbConfig $dbConfig)\n    {\n    }\n    public static function fromConfigs(AppConfig $appConfig, DbConfig $dbConfig): self\n    {\n        return new self($appConfig, $dbConfig);\n    }\n    public function createNorskApi(): NorskApi\n    {\n        $this->logger = Logger::create($this->appConfig->getLogPath());\n        $this->dbConnection = $this->createDbConnection($this->dbConfig);\n        return new NorskApi($this->logger, $this->createRouter(), AppFactory::create(), $this->appConfig->getAppLoggerConfig());\n    }\n    private function createDbConnection(DbConfig $config): DbConnection\n    {\n        return new DbConnection($this->createMysqliWrapper(), $config);\n    }\n    private function createMysqliWrapper(): MysqliWrapper\n    {\n        return new MysqliWrapper();\n    }\n    private function createRouter(): Router\n    {\n        return new Router($this->createIdentityAccessManagement(), $this->createContext());\n    }\n    private function createIdentityAccessManagement(): IdentityAccessManagementFactory\n    {\n        return new IdentityAccessManagementFactory($this->appConfig, $this->logger, $this->createUsersReader(), $this->appConfig->getUrl());\n    }\n    private function createUsersReader(): UsersReader\n    {\n        return new UsersReader($this->dbConnection);\n    }\n    private function createContext(): Context\n    {\n        return new Context($this->logger, $this->dbConnection, $this->createIdentityAccessManagement()->createJwtManagement(), $this->appConfig);\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app;\n\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\config\\DbConfig;\nuse norsk\\api\\app\\identityAccessManagement\\IdentityAccessManagementFactory;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\persistence\\DbConnection;\nuse norsk\\api\\app\\persistence\\MysqliWrapper;\nuse norsk\\api\\app\\routing\\Context;\nuse norsk\\api\\app\\routing\\Router;\nuse norsk\\api\\user\\UsersReader;\nuse Slim\\Factory\\AppFactory;\nclass Factory\n{\n    private Logger $logger;\n    private DbConnection $dbConnection;\n    private function __construct(private readonly AppConfig $appConfig, private readonly DbConfig $dbConfig)\n    {\n    }\n    protected static function fromConfigs(AppConfig $appConfig, DbConfig $dbConfig): self\n    {\n        return new self($appConfig, $dbConfig);\n    }\n    public function createNorskApi(): NorskApi\n    {\n        $this->logger = Logger::create($this->appConfig->getLogPath());\n        $this->dbConnection = $this->createDbConnection($this->dbConfig);\n        return new NorskApi($this->logger, $this->createRouter(), AppFactory::create(), $this->appConfig->getAppLoggerConfig());\n    }\n    private function createDbConnection(DbConfig $config): DbConnection\n    {\n        return new DbConnection($this->createMysqliWrapper(), $config);\n    }\n    private function createMysqliWrapper(): MysqliWrapper\n    {\n        return new MysqliWrapper();\n    }\n    private function createRouter(): Router\n    {\n        return new Router($this->createIdentityAccessManagement(), $this->createContext());\n    }\n    private function createIdentityAccessManagement(): IdentityAccessManagementFactory\n    {\n        return new IdentityAccessManagementFactory($this->appConfig, $this->logger, $this->createUsersReader(), $this->appConfig->getUrl());\n    }\n    private function createUsersReader(): UsersReader\n    {\n        return new UsersReader($this->dbConnection);\n    }\n    private function createContext(): Context\n    {\n        return new Context($this->logger, $this->dbConnection, $this->createIdentityAccessManagement()->createJwtManagement(), $this->appConfig);\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/Factory.php","originalStartLine":30},"diff":"@@ @@\n     private function __construct(private readonly AppConfig $appConfig, private readonly DbConfig $dbConfig)\n     {\n     }\n-    public static function fromConfigs(AppConfig $appConfig, DbConfig $dbConfig): self\n+    protected static function fromConfigs(AppConfig $appConfig, DbConfig $dbConfig): self\n     {\n         return new self($appConfig, $dbConfig);\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.ed15dce43a2299af34fb507e78d514b5.infection.xml\n\nE                                                                   1 \/ 1 (100%)\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\FactoryTest::testCanCreateNorskApi\nError: Call to protected method norsk\\api\\app\\Factory::fromConfigs() from scope norsk\\api\\app\\FactoryTest\n\n\/app\/api\/tests\/unit\/app\/FactoryTest.php:19\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app;\n\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\config\\DbConfig;\nuse norsk\\api\\app\\identityAccessManagement\\IdentityAccessManagementFactory;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\persistence\\DbConnection;\nuse norsk\\api\\app\\persistence\\MysqliWrapper;\nuse norsk\\api\\app\\routing\\Context;\nuse norsk\\api\\app\\routing\\Router;\nuse norsk\\api\\user\\UsersReader;\nuse Slim\\Factory\\AppFactory;\nclass Factory\n{\n    private Logger $logger;\n    private DbConnection $dbConnection;\n    private function __construct(private readonly AppConfig $appConfig, private readonly DbConfig $dbConfig)\n    {\n    }\n    public static function fromConfigs(AppConfig $appConfig, DbConfig $dbConfig): self\n    {\n        return new self($appConfig, $dbConfig);\n    }\n    public function createNorskApi(): NorskApi\n    {\n        $this->logger = Logger::create($this->appConfig->getLogPath());\n        $this->dbConnection = $this->createDbConnection($this->dbConfig);\n        return new NorskApi($this->logger, $this->createRouter(), AppFactory::create(), $this->appConfig->getAppLoggerConfig());\n    }\n    private function createDbConnection(DbConfig $config): DbConnection\n    {\n        return new DbConnection($this->createMysqliWrapper(), $config);\n    }\n    private function createMysqliWrapper(): MysqliWrapper\n    {\n        return new MysqliWrapper();\n    }\n    private function createRouter(): Router\n    {\n        return new Router($this->createIdentityAccessManagement(), $this->createContext());\n    }\n    private function createIdentityAccessManagement(): IdentityAccessManagementFactory\n    {\n        return new IdentityAccessManagementFactory($this->appConfig, $this->logger, $this->createUsersReader(), $this->appConfig->getUrl());\n    }\n    private function createUsersReader(): UsersReader\n    {\n        return new UsersReader($this->dbConnection);\n    }\n    private function createContext(): Context\n    {\n        return new Context($this->logger, $this->dbConnection, $this->createIdentityAccessManagement()->createJwtManagement(), $this->appConfig);\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app;\n\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\config\\DbConfig;\nuse norsk\\api\\app\\identityAccessManagement\\IdentityAccessManagementFactory;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\persistence\\DbConnection;\nuse norsk\\api\\app\\persistence\\MysqliWrapper;\nuse norsk\\api\\app\\routing\\Context;\nuse norsk\\api\\app\\routing\\Router;\nuse norsk\\api\\user\\UsersReader;\nuse Slim\\Factory\\AppFactory;\nclass Factory\n{\n    private Logger $logger;\n    private DbConnection $dbConnection;\n    private function __construct(private readonly AppConfig $appConfig, private readonly DbConfig $dbConfig)\n    {\n    }\n    public static function fromConfigs(AppConfig $appConfig, DbConfig $dbConfig): self\n    {\n        return new self($appConfig, $dbConfig);\n    }\n    protected function createNorskApi(): NorskApi\n    {\n        $this->logger = Logger::create($this->appConfig->getLogPath());\n        $this->dbConnection = $this->createDbConnection($this->dbConfig);\n        return new NorskApi($this->logger, $this->createRouter(), AppFactory::create(), $this->appConfig->getAppLoggerConfig());\n    }\n    private function createDbConnection(DbConfig $config): DbConnection\n    {\n        return new DbConnection($this->createMysqliWrapper(), $config);\n    }\n    private function createMysqliWrapper(): MysqliWrapper\n    {\n        return new MysqliWrapper();\n    }\n    private function createRouter(): Router\n    {\n        return new Router($this->createIdentityAccessManagement(), $this->createContext());\n    }\n    private function createIdentityAccessManagement(): IdentityAccessManagementFactory\n    {\n        return new IdentityAccessManagementFactory($this->appConfig, $this->logger, $this->createUsersReader(), $this->appConfig->getUrl());\n    }\n    private function createUsersReader(): UsersReader\n    {\n        return new UsersReader($this->dbConnection);\n    }\n    private function createContext(): Context\n    {\n        return new Context($this->logger, $this->dbConnection, $this->createIdentityAccessManagement()->createJwtManagement(), $this->appConfig);\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/Factory.php","originalStartLine":36},"diff":"@@ @@\n     {\n         return new self($appConfig, $dbConfig);\n     }\n-    public function createNorskApi(): NorskApi\n+    protected function createNorskApi(): NorskApi\n     {\n         $this->logger = Logger::create($this->appConfig->getLogPath());\n         $this->dbConnection = $this->createDbConnection($this->dbConfig);","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.96f409997cabd03afae8ca15898bec4c.infection.xml\n\nE                                                                   1 \/ 1 (100%)\n\nTime: 00:00.003, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\FactoryTest::testCanCreateNorskApi\nError: Call to protected method norsk\\api\\app\\Factory::createNorskApi() from scope norsk\\api\\app\\FactoryTest\n\n\/app\/api\/tests\/unit\/app\/FactoryTest.php:21\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app;\n\nuse norsk\\api\\app\\identityAccessManagement\\Session;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\routing\\Router;\nuse Slim\\App;\nclass NorskApi\n{\n    public function __construct(private readonly Logger $logger, private readonly Router $router, private readonly App $app, private readonly AppLoggerConfig $appLoggerConfig)\n    {\n    }\n    public function run(): void\n    {\n        $this->logger->info(LogMessage::fromString('Starting Norsk API'));\n        $this->app->addBodyParsingMiddleware();\n        $this->app->addRoutingMiddleware();\n        $this->app->addErrorMiddleware($this->appLoggerConfig->isDisplayErrorDetails(), $this->appLoggerConfig->isLogErrors(), $this->appLoggerConfig->isLogErrorDetails());\n        $session = Session::create();\n        $this->router->run($this->app, $session);\n        $this->app->run();\n        $session->destroy();\n        $this->logger->info(LogMessage::fromString('Stopping Norsk API'));\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app;\n\nuse norsk\\api\\app\\identityAccessManagement\\Session;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\routing\\Router;\nuse Slim\\App;\nclass NorskApi\n{\n    public function __construct(private readonly Logger $logger, private readonly Router $router, private readonly App $app, private readonly AppLoggerConfig $appLoggerConfig)\n    {\n    }\n    protected function run(): void\n    {\n        $this->logger->info(LogMessage::fromString('Starting Norsk API'));\n        $this->app->addBodyParsingMiddleware();\n        $this->app->addRoutingMiddleware();\n        $this->app->addErrorMiddleware($this->appLoggerConfig->isDisplayErrorDetails(), $this->appLoggerConfig->isLogErrors(), $this->appLoggerConfig->isLogErrorDetails());\n        $session = Session::create();\n        $this->router->run($this->app, $session);\n        $this->app->run();\n        $session->destroy();\n        $this->logger->info(LogMessage::fromString('Stopping Norsk API'));\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/NorskApi.php","originalStartLine":25},"diff":"@@ @@\n     public function __construct(private readonly Logger $logger, private readonly Router $router, private readonly App $app, private readonly AppLoggerConfig $appLoggerConfig)\n     {\n     }\n-    public function run(): void\n+    protected function run(): void\n     {\n         $this->logger->info(LogMessage::fromString('Starting Norsk API'));\n         $this->app->addBodyParsingMiddleware();","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.2a1a1d2d7d7d61e72bb03c781e50f72c.infection.xml\n\nE                                                                   1 \/ 1 (100%)\n\nTime: 00:00.004, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\NorskApiTest::testCanRun\nError: Call to protected method norsk\\api\\app\\NorskApi::run() from scope norsk\\api\\app\\NorskApiTest\n\n\/app\/api\/tests\/unit\/app\/NorskApiTest.php:59\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app;\n\nuse norsk\\api\\app\\identityAccessManagement\\Session;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\routing\\Router;\nuse Slim\\App;\nclass NorskApi\n{\n    public function __construct(private readonly Logger $logger, private readonly Router $router, private readonly App $app, private readonly AppLoggerConfig $appLoggerConfig)\n    {\n    }\n    public function run(): void\n    {\n        $this->logger->info(LogMessage::fromString('Starting Norsk API'));\n        $this->app->addBodyParsingMiddleware();\n        $this->app->addRoutingMiddleware();\n        $this->app->addErrorMiddleware($this->appLoggerConfig->isDisplayErrorDetails(), $this->appLoggerConfig->isLogErrors(), $this->appLoggerConfig->isLogErrorDetails());\n        $session = Session::create();\n        $this->router->run($this->app, $session);\n        $this->app->run();\n        $session->destroy();\n        $this->logger->info(LogMessage::fromString('Stopping Norsk API'));\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app;\n\nuse norsk\\api\\app\\identityAccessManagement\\Session;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\routing\\Router;\nuse Slim\\App;\nclass NorskApi\n{\n    public function __construct(private readonly Logger $logger, private readonly Router $router, private readonly App $app, private readonly AppLoggerConfig $appLoggerConfig)\n    {\n    }\n    public function run(): void\n    {\n        \n        $this->app->addBodyParsingMiddleware();\n        $this->app->addRoutingMiddleware();\n        $this->app->addErrorMiddleware($this->appLoggerConfig->isDisplayErrorDetails(), $this->appLoggerConfig->isLogErrors(), $this->appLoggerConfig->isLogErrorDetails());\n        $session = Session::create();\n        $this->router->run($this->app, $session);\n        $this->app->run();\n        $session->destroy();\n        $this->logger->info(LogMessage::fromString('Stopping Norsk API'));\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/NorskApi.php","originalStartLine":27},"diff":"@@ @@\n     }\n     public function run(): void\n     {\n-        $this->logger->info(LogMessage::fromString('Starting Norsk API'));\n+        \n         $this->app->addBodyParsingMiddleware();\n         $this->app->addRoutingMiddleware();\n         $this->app->addErrorMiddleware($this->appLoggerConfig->isDisplayErrorDetails(), $this->appLoggerConfig->isLogErrors(), $this->appLoggerConfig->isLogErrorDetails());","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.8b7283d24d1cd97024a5c1de2171a449.infection.xml\n\nF                                                                   1 \/ 1 (100%)\n\nTime: 00:00.006, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\NorskApiTest::testCanRun\nFailed asserting that two arrays are equal.\n--- Expected\n+++ Actual\n@@ @@\n Array (\n     0 => norsk\\api\\app\\logging\\LogMessage Object (\n-        'message' => 'Starting Norsk API'\n+        'message' => 'Stopping Norsk API'\n     )\n )\n\n\/app\/api\/tests\/unit\/app\/NorskApiTest.php:28\n\/app\/api\/src\/app\/NorskApi.php:27\n\/app\/api\/tests\/unit\/app\/NorskApiTest.php:59\n\nFAILURES!\nTests: 1, Assertions: 1, Failures: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app;\n\nuse norsk\\api\\app\\identityAccessManagement\\Session;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\routing\\Router;\nuse Slim\\App;\nclass NorskApi\n{\n    public function __construct(private readonly Logger $logger, private readonly Router $router, private readonly App $app, private readonly AppLoggerConfig $appLoggerConfig)\n    {\n    }\n    public function run(): void\n    {\n        $this->logger->info(LogMessage::fromString('Starting Norsk API'));\n        $this->app->addBodyParsingMiddleware();\n        $this->app->addRoutingMiddleware();\n        $this->app->addErrorMiddleware($this->appLoggerConfig->isDisplayErrorDetails(), $this->appLoggerConfig->isLogErrors(), $this->appLoggerConfig->isLogErrorDetails());\n        $session = Session::create();\n        $this->router->run($this->app, $session);\n        $this->app->run();\n        $session->destroy();\n        $this->logger->info(LogMessage::fromString('Stopping Norsk API'));\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app;\n\nuse norsk\\api\\app\\identityAccessManagement\\Session;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\routing\\Router;\nuse Slim\\App;\nclass NorskApi\n{\n    public function __construct(private readonly Logger $logger, private readonly Router $router, private readonly App $app, private readonly AppLoggerConfig $appLoggerConfig)\n    {\n    }\n    public function run(): void\n    {\n        $this->logger->info(LogMessage::fromString('Starting Norsk API'));\n        \n        $this->app->addRoutingMiddleware();\n        $this->app->addErrorMiddleware($this->appLoggerConfig->isDisplayErrorDetails(), $this->appLoggerConfig->isLogErrors(), $this->appLoggerConfig->isLogErrorDetails());\n        $session = Session::create();\n        $this->router->run($this->app, $session);\n        $this->app->run();\n        $session->destroy();\n        $this->logger->info(LogMessage::fromString('Stopping Norsk API'));\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/NorskApi.php","originalStartLine":29},"diff":"@@ @@\n     public function run(): void\n     {\n         $this->logger->info(LogMessage::fromString('Starting Norsk API'));\n-        $this->app->addBodyParsingMiddleware();\n+        \n         $this->app->addRoutingMiddleware();\n         $this->app->addErrorMiddleware($this->appLoggerConfig->isDisplayErrorDetails(), $this->appLoggerConfig->isLogErrors(), $this->appLoggerConfig->isLogErrorDetails());\n         $session = Session::create();","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.7cd94b8243ddf68c82494d611f0a301c.infection.xml\n\nF                                                                   1 \/ 1 (100%)\n\nTime: 00:00.005, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\NorskApiTest::testCanRun\nExpectation failed for method name is \"addBodyParsingMiddleware\" when invoked 1 time.\nMethod was expected to be called 1 time, actually called 0 times.\n\nFAILURES!\nTests: 1, Assertions: 5, Failures: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app;\n\nuse norsk\\api\\app\\identityAccessManagement\\Session;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\routing\\Router;\nuse Slim\\App;\nclass NorskApi\n{\n    public function __construct(private readonly Logger $logger, private readonly Router $router, private readonly App $app, private readonly AppLoggerConfig $appLoggerConfig)\n    {\n    }\n    public function run(): void\n    {\n        $this->logger->info(LogMessage::fromString('Starting Norsk API'));\n        $this->app->addBodyParsingMiddleware();\n        $this->app->addRoutingMiddleware();\n        $this->app->addErrorMiddleware($this->appLoggerConfig->isDisplayErrorDetails(), $this->appLoggerConfig->isLogErrors(), $this->appLoggerConfig->isLogErrorDetails());\n        $session = Session::create();\n        $this->router->run($this->app, $session);\n        $this->app->run();\n        $session->destroy();\n        $this->logger->info(LogMessage::fromString('Stopping Norsk API'));\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app;\n\nuse norsk\\api\\app\\identityAccessManagement\\Session;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\routing\\Router;\nuse Slim\\App;\nclass NorskApi\n{\n    public function __construct(private readonly Logger $logger, private readonly Router $router, private readonly App $app, private readonly AppLoggerConfig $appLoggerConfig)\n    {\n    }\n    public function run(): void\n    {\n        $this->logger->info(LogMessage::fromString('Starting Norsk API'));\n        $this->app->addBodyParsingMiddleware();\n        \n        $this->app->addErrorMiddleware($this->appLoggerConfig->isDisplayErrorDetails(), $this->appLoggerConfig->isLogErrors(), $this->appLoggerConfig->isLogErrorDetails());\n        $session = Session::create();\n        $this->router->run($this->app, $session);\n        $this->app->run();\n        $session->destroy();\n        $this->logger->info(LogMessage::fromString('Stopping Norsk API'));\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/NorskApi.php","originalStartLine":30},"diff":"@@ @@\n     {\n         $this->logger->info(LogMessage::fromString('Starting Norsk API'));\n         $this->app->addBodyParsingMiddleware();\n-        $this->app->addRoutingMiddleware();\n+        \n         $this->app->addErrorMiddleware($this->appLoggerConfig->isDisplayErrorDetails(), $this->appLoggerConfig->isLogErrors(), $this->appLoggerConfig->isLogErrorDetails());\n         $session = Session::create();\n         $this->router->run($this->app, $session);","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.c2e9005d2d2159272687e28f1c499bce.infection.xml\n\nF                                                                   1 \/ 1 (100%)\n\nTime: 00:00.005, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\NorskApiTest::testCanRun\nExpectation failed for method name is \"addRoutingMiddleware\" when invoked 1 time.\nMethod was expected to be called 1 time, actually called 0 times.\n\nFAILURES!\nTests: 1, Assertions: 5, Failures: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app;\n\nuse norsk\\api\\app\\identityAccessManagement\\Session;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\routing\\Router;\nuse Slim\\App;\nclass NorskApi\n{\n    public function __construct(private readonly Logger $logger, private readonly Router $router, private readonly App $app, private readonly AppLoggerConfig $appLoggerConfig)\n    {\n    }\n    public function run(): void\n    {\n        $this->logger->info(LogMessage::fromString('Starting Norsk API'));\n        $this->app->addBodyParsingMiddleware();\n        $this->app->addRoutingMiddleware();\n        $this->app->addErrorMiddleware($this->appLoggerConfig->isDisplayErrorDetails(), $this->appLoggerConfig->isLogErrors(), $this->appLoggerConfig->isLogErrorDetails());\n        $session = Session::create();\n        $this->router->run($this->app, $session);\n        $this->app->run();\n        $session->destroy();\n        $this->logger->info(LogMessage::fromString('Stopping Norsk API'));\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app;\n\nuse norsk\\api\\app\\identityAccessManagement\\Session;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\routing\\Router;\nuse Slim\\App;\nclass NorskApi\n{\n    public function __construct(private readonly Logger $logger, private readonly Router $router, private readonly App $app, private readonly AppLoggerConfig $appLoggerConfig)\n    {\n    }\n    public function run(): void\n    {\n        $this->logger->info(LogMessage::fromString('Starting Norsk API'));\n        $this->app->addBodyParsingMiddleware();\n        $this->app->addRoutingMiddleware();\n        \n        $session = Session::create();\n        $this->router->run($this->app, $session);\n        $this->app->run();\n        $session->destroy();\n        $this->logger->info(LogMessage::fromString('Stopping Norsk API'));\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/NorskApi.php","originalStartLine":31},"diff":"@@ @@\n         $this->logger->info(LogMessage::fromString('Starting Norsk API'));\n         $this->app->addBodyParsingMiddleware();\n         $this->app->addRoutingMiddleware();\n-        $this->app->addErrorMiddleware($this->appLoggerConfig->isDisplayErrorDetails(), $this->appLoggerConfig->isLogErrors(), $this->appLoggerConfig->isLogErrorDetails());\n+        \n         $session = Session::create();\n         $this->router->run($this->app, $session);\n         $this->app->run();","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.92bd083b77e2388529342bfac9d11f27.infection.xml\n\nF                                                                   1 \/ 1 (100%)\n\nTime: 00:00.005, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\NorskApiTest::testCanRun\nExpectation failed for method name is \"addErrorMiddleware\" when invoked 1 time.\nMethod was expected to be called 1 time, actually called 0 times.\n\nFAILURES!\nTests: 1, Assertions: 5, Failures: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app;\n\nuse norsk\\api\\app\\identityAccessManagement\\Session;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\routing\\Router;\nuse Slim\\App;\nclass NorskApi\n{\n    public function __construct(private readonly Logger $logger, private readonly Router $router, private readonly App $app, private readonly AppLoggerConfig $appLoggerConfig)\n    {\n    }\n    public function run(): void\n    {\n        $this->logger->info(LogMessage::fromString('Starting Norsk API'));\n        $this->app->addBodyParsingMiddleware();\n        $this->app->addRoutingMiddleware();\n        $this->app->addErrorMiddleware($this->appLoggerConfig->isDisplayErrorDetails(), $this->appLoggerConfig->isLogErrors(), $this->appLoggerConfig->isLogErrorDetails());\n        $session = Session::create();\n        $this->router->run($this->app, $session);\n        $this->app->run();\n        $session->destroy();\n        $this->logger->info(LogMessage::fromString('Stopping Norsk API'));\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app;\n\nuse norsk\\api\\app\\identityAccessManagement\\Session;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\routing\\Router;\nuse Slim\\App;\nclass NorskApi\n{\n    public function __construct(private readonly Logger $logger, private readonly Router $router, private readonly App $app, private readonly AppLoggerConfig $appLoggerConfig)\n    {\n    }\n    public function run(): void\n    {\n        $this->logger->info(LogMessage::fromString('Starting Norsk API'));\n        $this->app->addBodyParsingMiddleware();\n        $this->app->addRoutingMiddleware();\n        $this->app->addErrorMiddleware($this->appLoggerConfig->isDisplayErrorDetails(), $this->appLoggerConfig->isLogErrors(), $this->appLoggerConfig->isLogErrorDetails());\n        $session = Session::create();\n        \n        $this->app->run();\n        $session->destroy();\n        $this->logger->info(LogMessage::fromString('Stopping Norsk API'));\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/NorskApi.php","originalStartLine":38},"diff":"@@ @@\n         $this->app->addRoutingMiddleware();\n         $this->app->addErrorMiddleware($this->appLoggerConfig->isDisplayErrorDetails(), $this->appLoggerConfig->isLogErrors(), $this->appLoggerConfig->isLogErrorDetails());\n         $session = Session::create();\n-        $this->router->run($this->app, $session);\n+        \n         $this->app->run();\n         $session->destroy();\n         $this->logger->info(LogMessage::fromString('Stopping Norsk API'));\n     }\n }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.8b2ee87abbd4b51688dab7031de4599d.infection.xml\n\nF                                                                   1 \/ 1 (100%)\n\nTime: 00:00.006, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\NorskApiTest::testCanRun\nExpectation failed for method name is \"run\" when invoked 1 time.\nMethod was expected to be called 1 time, actually called 0 times.\n\nFAILURES!\nTests: 1, Assertions: 4, Failures: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app;\n\nuse norsk\\api\\app\\identityAccessManagement\\Session;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\routing\\Router;\nuse Slim\\App;\nclass NorskApi\n{\n    public function __construct(private readonly Logger $logger, private readonly Router $router, private readonly App $app, private readonly AppLoggerConfig $appLoggerConfig)\n    {\n    }\n    public function run(): void\n    {\n        $this->logger->info(LogMessage::fromString('Starting Norsk API'));\n        $this->app->addBodyParsingMiddleware();\n        $this->app->addRoutingMiddleware();\n        $this->app->addErrorMiddleware($this->appLoggerConfig->isDisplayErrorDetails(), $this->appLoggerConfig->isLogErrors(), $this->appLoggerConfig->isLogErrorDetails());\n        $session = Session::create();\n        $this->router->run($this->app, $session);\n        $this->app->run();\n        $session->destroy();\n        $this->logger->info(LogMessage::fromString('Stopping Norsk API'));\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app;\n\nuse norsk\\api\\app\\identityAccessManagement\\Session;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\routing\\Router;\nuse Slim\\App;\nclass NorskApi\n{\n    public function __construct(private readonly Logger $logger, private readonly Router $router, private readonly App $app, private readonly AppLoggerConfig $appLoggerConfig)\n    {\n    }\n    public function run(): void\n    {\n        $this->logger->info(LogMessage::fromString('Starting Norsk API'));\n        $this->app->addBodyParsingMiddleware();\n        $this->app->addRoutingMiddleware();\n        $this->app->addErrorMiddleware($this->appLoggerConfig->isDisplayErrorDetails(), $this->appLoggerConfig->isLogErrors(), $this->appLoggerConfig->isLogErrorDetails());\n        $session = Session::create();\n        $this->router->run($this->app, $session);\n        \n        $session->destroy();\n        $this->logger->info(LogMessage::fromString('Stopping Norsk API'));\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/NorskApi.php","originalStartLine":39},"diff":"@@ @@\n         $this->app->addErrorMiddleware($this->appLoggerConfig->isDisplayErrorDetails(), $this->appLoggerConfig->isLogErrors(), $this->appLoggerConfig->isLogErrorDetails());\n         $session = Session::create();\n         $this->router->run($this->app, $session);\n-        $this->app->run();\n+        \n         $session->destroy();\n         $this->logger->info(LogMessage::fromString('Stopping Norsk API'));\n     }\n }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.bd6819712d20e87933bfcf93da8c4ef5.infection.xml\n\nF                                                                   1 \/ 1 (100%)\n\nTime: 00:00.005, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\NorskApiTest::testCanRun\nExpectation failed for method name is \"run\" when invoked 1 time.\nMethod was expected to be called 1 time, actually called 0 times.\n\nFAILURES!\nTests: 1, Assertions: 5, Failures: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app;\n\nuse norsk\\api\\app\\identityAccessManagement\\Session;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\routing\\Router;\nuse Slim\\App;\nclass NorskApi\n{\n    public function __construct(private readonly Logger $logger, private readonly Router $router, private readonly App $app, private readonly AppLoggerConfig $appLoggerConfig)\n    {\n    }\n    public function run(): void\n    {\n        $this->logger->info(LogMessage::fromString('Starting Norsk API'));\n        $this->app->addBodyParsingMiddleware();\n        $this->app->addRoutingMiddleware();\n        $this->app->addErrorMiddleware($this->appLoggerConfig->isDisplayErrorDetails(), $this->appLoggerConfig->isLogErrors(), $this->appLoggerConfig->isLogErrorDetails());\n        $session = Session::create();\n        $this->router->run($this->app, $session);\n        $this->app->run();\n        $session->destroy();\n        $this->logger->info(LogMessage::fromString('Stopping Norsk API'));\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app;\n\nuse norsk\\api\\app\\identityAccessManagement\\Session;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\routing\\Router;\nuse Slim\\App;\nclass NorskApi\n{\n    public function __construct(private readonly Logger $logger, private readonly Router $router, private readonly App $app, private readonly AppLoggerConfig $appLoggerConfig)\n    {\n    }\n    public function run(): void\n    {\n        $this->logger->info(LogMessage::fromString('Starting Norsk API'));\n        $this->app->addBodyParsingMiddleware();\n        $this->app->addRoutingMiddleware();\n        $this->app->addErrorMiddleware($this->appLoggerConfig->isDisplayErrorDetails(), $this->appLoggerConfig->isLogErrors(), $this->appLoggerConfig->isLogErrorDetails());\n        $session = Session::create();\n        $this->router->run($this->app, $session);\n        $this->app->run();\n        $session->destroy();\n        \n    }\n}","originalFilePath":"\/app\/api\/src\/app\/NorskApi.php","originalStartLine":41},"diff":"@@ @@\n         $this->router->run($this->app, $session);\n         $this->app->run();\n         $session->destroy();\n-        $this->logger->info(LogMessage::fromString('Stopping Norsk API'));\n+        \n     }\n }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.1228f0819b7c338ce7e51a9e407c6d56.infection.xml\n\nF                                                                   1 \/ 1 (100%)\n\nTime: 00:00.007, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\NorskApiTest::testCanRun\nExpectation failed for method name is \"info\" when invoked 2 times.\nMethod was expected to be called 2 times, actually called 1 time.\n\nFAILURES!\nTests: 1, Assertions: 2, Failures: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    protected static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":38},"diff":"@@ @@\n     private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n     {\n     }\n-    public static function fromPath(Path $configPath): self\n+    protected static function fromPath(Path $configPath): self\n     {\n         $file = File::fromPath($configPath);\n         $configItems = $file->parseIniFile()->asArray();","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.d2b644e188d11e53e07a2acd647423e0.infection.xml\n\nE\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testThrowsExceptionIfConfigFirstLevelKeyIsMissing with data set \"logs\" ('[empty]\\rempty=x\\r[auth]\\rmethod=x', 'logs')\nError: Call to protected method norsk\\api\\app\\config\\AppConfig::fromPath() from scope norsk\\api\\app\\config\\AppConfigTest\n\n\/app\/api\/tests\/unit\/app\/config\/AppConfigTest.php:34\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        \n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":42},"diff":"@@ @@\n     {\n         $file = File::fromPath($configPath);\n         $configItems = $file->parseIniFile()->asArray();\n-        self::ensureConfigIsValid($configItems);\n+        \n         self::displayErrorForDebug($configItems);\n         return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.d2e373adeaa2d6899ce22f503fc5c16b.infection.xml\n\nF\n\nTime: 00:00.004, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testThrowsExceptionIfConfigFirstLevelKeyIsMissing with data set \"logs\" ('[empty]\\rempty=x\\r[auth]\\rmethod=x', 'logs')\nFailed asserting that exception of type \"TypeError\" matches expected exception \"RuntimeException\". Message was: \"norsk\\api\\app\\config\\AppConfig::readLoggerConfig(): Argument #1 ($logConfigItems) must be of type array, null given, called in \/app\/api\/src\/app\/config\/AppConfig.php on line 34\" at\n\/app\/api\/src\/app\/config\/AppConfig.php:84\n\/app\/api\/src\/app\/config\/AppConfig.php:34\n\/app\/api\/tests\/unit\/app\/config\/AppConfigTest.php:307\n.\n\nFAILURES!\nTests: 1, Assertions: 1, Failures: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        \n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":44},"diff":"@@ @@\n         $file = File::fromPath($configPath);\n         $configItems = $file->parseIniFile()->asArray();\n         self::ensureConfigIsValid($configItems);\n-        self::displayErrorForDebug($configItems);\n+        \n         return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n     }\n     private static function ensureConfigIsValid(array $configItems): void","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.2b62198be373450c7b6d8e5078c9a9f4.infection.xml\n\n...............................F\n\nTime: 00:00.013, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testCanSetErrorLevelToProductionLevelWithoutWarnings\nE_ERROR | E_PARSE aktiv\nFailed asserting that 32767 is identical to 5.\n\n\/app\/api\/tests\/unit\/app\/config\/AppConfigTest.php:360\n\nFAILURES!\nTests: 32, Assertions: 57, Failures: 1."},{"mutator":{"mutatorName":"ArrayItemRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":57},"diff":"@@ @@\n     }\n     private static function ensureConfigIsValid(array $configItems): void\n     {\n-        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n+        $expectedKeys = [self::AUTH => self::AUTH_SECOND_LEVEL];\n         self::ensureKeysExist($configItems, $expectedKeys);\n         self::ensureKeyHasValue($configItems, $expectedKeys);\n         self::ensureParamsExist($configItems, $expectedKeys);","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.3b6a9bb58aec4c84f8e17cf0d1507723.infection.xml\n\nF\n\nTime: 00:00.003, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testThrowsExceptionIfConfigFirstLevelKeyIsMissing with data set \"logs\" ('[empty]\\rempty=x\\r[auth]\\rmethod=x', 'logs')\nFailed asserting that exception message 'Key is not set: key' contains 'Key is not set: logs'.\n\nFAILURES!\nTests: 1, Assertions: 2, Failures: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        \n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":62},"diff":"@@ @@\n     private static function ensureConfigIsValid(array $configItems): void\n     {\n         $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n-        self::ensureKeysExist($configItems, $expectedKeys);\n+        \n         self::ensureKeyHasValue($configItems, $expectedKeys);\n         self::ensureParamsExist($configItems, $expectedKeys);\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.773f4e3b48749a483ad48e8193c18d58.infection.xml\n\nF\n\nTime: 00:00.004, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testThrowsExceptionIfConfigFirstLevelKeyIsMissing with data set \"logs\" ('[empty]\\rempty=x\\r[auth]\\rmethod=x', 'logs')\nFailed asserting that exception of type \"TypeError\" matches expected exception \"RuntimeException\". Message was: \"count(): Argument #1 ($value) must be of type Countable|array, null given\" at\n\/app\/api\/src\/app\/config\/AppConfig.php:58\n\/app\/api\/src\/app\/config\/AppConfig.php:40\n\/app\/api\/src\/app\/config\/AppConfig.php:32\n\/app\/api\/tests\/unit\/app\/config\/AppConfigTest.php:307\n.\n\nFAILURES!\nTests: 1, Assertions: 1, Failures: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        \n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":63},"diff":"@@ @@\n     {\n         $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n         self::ensureKeysExist($configItems, $expectedKeys);\n-        self::ensureKeyHasValue($configItems, $expectedKeys);\n+        \n         self::ensureParamsExist($configItems, $expectedKeys);\n     }\n     private static function ensureKeysExist(array $configItems, array $expectedKeys): void","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.8d049118f69f5d76abb4a2e75d4d2d2b.infection.xml\n\n..F\n\nTime: 00:00.004, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testThrowsExceptionIfConfigFirstLevelKeyIsEmpty with data set #0 ('[logs]\\r[auth]\\rfo=o', 'logs')\nFailed asserting that exception message 'Key is not set: path' contains 'Key is empty: logs'.\n\nFAILURES!\nTests: 3, Assertions: 6, Failures: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        \n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":64},"diff":"@@ @@\n         $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n         self::ensureKeysExist($configItems, $expectedKeys);\n         self::ensureKeyHasValue($configItems, $expectedKeys);\n-        self::ensureParamsExist($configItems, $expectedKeys);\n+        \n     }\n     private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n     {","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.92bff93db3ec5a2d69e62dde8cb825db.infection.xml\n\n....F\n\nTime: 00:00.006, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testThrowsExceptionIfConfigParamKeyIsMissing with data set \"path\" ('[logs]\\rdisplayErrorDetails =... x\\r\\r', 'path')\nFailed asserting that exception of type \"InvalidArgumentException\" matches expected exception \"RuntimeException\". Message was: \"The given URL is not a valid URL: x\" at\n\/app\/api\/src\/app\/response\/Url.php:28\n\/app\/api\/src\/app\/response\/Url.php:19\n\/app\/api\/src\/app\/config\/AppConfig.php:34\n\/app\/api\/tests\/unit\/app\/config\/AppConfigTest.php:337\n.\n\nFAILURES!\nTests: 5, Assertions: 9, Failures: 1."},{"mutator":{"mutatorName":"UnwrapArrayKeys","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":70},"diff":"@@ @@\n     }\n     private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n     {\n-        foreach (array_keys($expectedKeys) as $configKey) {\n+        foreach ($expectedKeys as $configKey) {\n             self::ensureKeyIsSet($configKey, $configItems);\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.3d9971c1a9eac8d323f7d0da83728d80.infection.xml\n\nE\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testThrowsExceptionIfConfigFirstLevelKeyIsMissing with data set \"logs\" ('[empty]\\rempty=x\\r[auth]\\rmethod=x', 'logs')\nTypeError: norsk\\api\\app\\config\\AppConfig::ensureKeyIsSet(): Argument #1 ($param) must be of type string|int|bool|null, array given, called in \/app\/api\/src\/app\/config\/AppConfig.php on line 46\n\n\/app\/api\/src\/app\/config\/AppConfig.php:49\n\/app\/api\/src\/app\/config\/AppConfig.php:46\n\/app\/api\/src\/app\/config\/AppConfig.php:39\n\/app\/api\/src\/app\/config\/AppConfig.php:32\n\/app\/api\/tests\/unit\/app\/config\/AppConfigTest.php:34\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Foreach_","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ([] as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":70},"diff":"@@ @@\n     }\n     private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n     {\n-        foreach (array_keys($expectedKeys) as $configKey) {\n+        foreach ([] as $configKey) {\n             self::ensureKeyIsSet($configKey, $configItems);\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.f417a694b8afb7c24308573ea28d0914.infection.xml\n\nF\n\nTime: 00:00.004, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testThrowsExceptionIfConfigFirstLevelKeyIsMissing with data set \"logs\" ('[empty]\\rempty=x\\r[auth]\\rmethod=x', 'logs')\nFailed asserting that exception of type \"TypeError\" matches expected exception \"RuntimeException\". Message was: \"count(): Argument #1 ($value) must be of type Countable|array, null given\" at\n\/app\/api\/src\/app\/config\/AppConfig.php:58\n\/app\/api\/src\/app\/config\/AppConfig.php:40\n\/app\/api\/src\/app\/config\/AppConfig.php:32\n\/app\/api\/tests\/unit\/app\/config\/AppConfigTest.php:307\n.\n\nFAILURES!\nTests: 1, Assertions: 1, Failures: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            \n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":71},"diff":"@@ @@\n     private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n     {\n         foreach (array_keys($expectedKeys) as $configKey) {\n-            self::ensureKeyIsSet($configKey, $configItems);\n+            \n         }\n     }\n     private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.f009edcbae67fbfb56c89b1506927470.infection.xml\n\nF\n\nTime: 00:00.005, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testThrowsExceptionIfConfigFirstLevelKeyIsMissing with data set \"logs\" ('[empty]\\rempty=x\\r[auth]\\rmethod=x', 'logs')\nFailed asserting that exception of type \"TypeError\" matches expected exception \"RuntimeException\". Message was: \"count(): Argument #1 ($value) must be of type Countable|array, null given\" at\n\/app\/api\/src\/app\/config\/AppConfig.php:58\n\/app\/api\/src\/app\/config\/AppConfig.php:40\n\/app\/api\/src\/app\/config\/AppConfig.php:32\n\/app\/api\/tests\/unit\/app\/config\/AppConfigTest.php:307\n.\n\nFAILURES!\nTests: 1, Assertions: 1, Failures: 1."},{"mutator":{"mutatorName":"LogicalNot","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":78},"diff":"@@ @@\n     }\n     private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n     {\n-        if (!array_key_exists($param, $array)) {\n+        if (array_key_exists($param, $array)) {\n             throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.37eaa3232bf8e210918c32e9291eed55.infection.xml\n\nE\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testThrowsExceptionIfConfigFirstLevelKeyIsMissing with data set \"logs\" ('[empty]\\rempty=x\\r[auth]\\rmethod=x', 'logs')\nnorsk\\api\\app\\config\\exceptions\\KeyIsNotSetException: Key is not set: logs\n\n\/app\/api\/src\/app\/config\/AppConfig.php:52\n\/app\/api\/src\/app\/config\/AppConfig.php:46\n\/app\/api\/src\/app\/config\/AppConfig.php:39\n\/app\/api\/src\/app\/config\/AppConfig.php:32\n\/app\/api\/tests\/unit\/app\/config\/AppConfigTest.php:34\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Throw_","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":79},"diff":"@@ @@\n     private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n     {\n         if (!array_key_exists($param, $array)) {\n-            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n+            new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n         }\n     }\n     private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.ad0154dfad3e1041e2bf24c00cec9ec1.infection.xml\n\nF\n\nTime: 00:00.006, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testThrowsExceptionIfConfigFirstLevelKeyIsMissing with data set \"logs\" ('[empty]\\rempty=x\\r[auth]\\rmethod=x', 'logs')\nFailed asserting that exception of type \"TypeError\" matches expected exception \"RuntimeException\". Message was: \"count(): Argument #1 ($value) must be of type Countable|array, null given\" at\n\/app\/api\/src\/app\/config\/AppConfig.php:58\n\/app\/api\/src\/app\/config\/AppConfig.php:40\n\/app\/api\/src\/app\/config\/AppConfig.php:32\n\/app\/api\/tests\/unit\/app\/config\/AppConfigTest.php:307\n.\n\nFAILURES!\nTests: 1, Assertions: 1, Failures: 1."},{"mutator":{"mutatorName":"Concat","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException($param . 'Key is not set: ', ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":80},"diff":"@@ @@\n     private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n     {\n         if (!array_key_exists($param, $array)) {\n-            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n+            throw new KeyIsNotSetException($param . 'Key is not set: ', ResponseCode::unprocessable->value);\n         }\n     }\n     private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.f9666f856b7a62c8c9ad7e2f78afc8ad.infection.xml\n\nF\n\nTime: 00:00.003, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testThrowsExceptionIfConfigFirstLevelKeyIsMissing with data set \"logs\" ('[empty]\\rempty=x\\r[auth]\\rmethod=x', 'logs')\nFailed asserting that exception message 'logsKey is not set: ' contains 'Key is not set: logs'.\n\nFAILURES!\nTests: 1, Assertions: 2, Failures: 1."},{"mutator":{"mutatorName":"ConcatOperandRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException($param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":80},"diff":"@@ @@\n     private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n     {\n         if (!array_key_exists($param, $array)) {\n-            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n+            throw new KeyIsNotSetException($param, ResponseCode::unprocessable->value);\n         }\n     }\n     private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.5b9e74348cd4607fbbe03a417fb6167e.infection.xml\n\nF\n\nTime: 00:00.003, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testThrowsExceptionIfConfigFirstLevelKeyIsMissing with data set \"logs\" ('[empty]\\rempty=x\\r[auth]\\rmethod=x', 'logs')\nFailed asserting that exception message 'logs' contains 'Key is not set: logs'.\n\nFAILURES!\nTests: 1, Assertions: 2, Failures: 1."},{"mutator":{"mutatorName":"ConcatOperandRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ', ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":80},"diff":"@@ @@\n     private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n     {\n         if (!array_key_exists($param, $array)) {\n-            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n+            throw new KeyIsNotSetException('Key is not set: ', ResponseCode::unprocessable->value);\n         }\n     }\n     private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.c1a7206575cc265cb1bb2ce5636b2f8a.infection.xml\n\nF\n\nTime: 00:00.003, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testThrowsExceptionIfConfigFirstLevelKeyIsMissing with data set \"logs\" ('[empty]\\rempty=x\\r[auth]\\rmethod=x', 'logs')\nFailed asserting that exception message 'Key is not set: ' contains 'Key is not set: logs'.\n\nFAILURES!\nTests: 1, Assertions: 2, Failures: 1."},{"mutator":{"mutatorName":"UnwrapArrayKeys","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":89},"diff":"@@ @@\n     }\n     private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n     {\n-        foreach (array_keys($expectedKeys) as $configKey) {\n+        foreach ($expectedKeys as $configKey) {\n             if (count($configItems[$configKey]) === 0) {\n                 throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n             }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.cf21702f98a508bf327fca60392052ac.infection.xml\n\nE\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testThrowsExceptionIfConfigFirstLevelKeyIsMissing with data set \"logs\" ('[empty]\\rempty=x\\r[auth]\\rmethod=x', 'logs')\nTypeError: Cannot access offset of type array on array\n\n\/app\/api\/src\/app\/config\/AppConfig.php:58\n\/app\/api\/src\/app\/config\/AppConfig.php:40\n\/app\/api\/src\/app\/config\/AppConfig.php:32\n\/app\/api\/tests\/unit\/app\/config\/AppConfigTest.php:34\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Foreach_","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach ([] as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":89},"diff":"@@ @@\n     }\n     private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n     {\n-        foreach (array_keys($expectedKeys) as $configKey) {\n+        foreach ([] as $configKey) {\n             if (count($configItems[$configKey]) === 0) {\n                 throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n             }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.66ec15d0355fed5cb81b1a0e6d1f1cf0.infection.xml\n\n..F\n\nTime: 00:00.004, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testThrowsExceptionIfConfigFirstLevelKeyIsEmpty with data set #0 ('[logs]\\r[auth]\\rfo=o', 'logs')\nFailed asserting that exception message 'Key is not set: path' contains 'Key is empty: logs'.\n\nFAILURES!\nTests: 3, Assertions: 6, Failures: 1."},{"mutator":{"mutatorName":"Identical","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) !== 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":90},"diff":"@@ @@\n     private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n     {\n         foreach (array_keys($expectedKeys) as $configKey) {\n-            if (count($configItems[$configKey]) === 0) {\n+            if (count($configItems[$configKey]) !== 0) {\n                 throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n             }\n         }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.8247935fb37ded489804815e229205c4.infection.xml\n\nE\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testThrowsExceptionIfConfigFirstLevelKeyIsMissing with data set \"logs\" ('[empty]\\rempty=x\\r[auth]\\rmethod=x', 'logs')\nnorsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException: Key is empty: logs\n\n\/app\/api\/src\/app\/config\/AppConfig.php:59\n\/app\/api\/src\/app\/config\/AppConfig.php:40\n\/app\/api\/src\/app\/config\/AppConfig.php:32\n\/app\/api\/tests\/unit\/app\/config\/AppConfigTest.php:34\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Throw_","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":91},"diff":"@@ @@\n     {\n         foreach (array_keys($expectedKeys) as $configKey) {\n             if (count($configItems[$configKey]) === 0) {\n-                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n+                new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n             }\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.0d59b275fdf4ba349b5dfa8186c4c51f.infection.xml\n\n..F\n\nTime: 00:00.004, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testThrowsExceptionIfConfigFirstLevelKeyIsEmpty with data set #0 ('[logs]\\r[auth]\\rfo=o', 'logs')\nFailed asserting that exception message 'Key is not set: path' contains 'Key is empty: logs'.\n\nFAILURES!\nTests: 3, Assertions: 6, Failures: 1."},{"mutator":{"mutatorName":"Concat","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException($configKey . 'Key is empty: ', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":92},"diff":"@@ @@\n     {\n         foreach (array_keys($expectedKeys) as $configKey) {\n             if (count($configItems[$configKey]) === 0) {\n-                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n+                throw new KeyHasEmptyValueException($configKey . 'Key is empty: ', ResponseCode::unprocessable->value);\n             }\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.054b16770b4fc7bdfe097783b1903e94.infection.xml\n\n..F\n\nTime: 00:00.004, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testThrowsExceptionIfConfigFirstLevelKeyIsEmpty with data set #0 ('[logs]\\r[auth]\\rfo=o', 'logs')\nFailed asserting that exception message 'logsKey is empty: ' contains 'Key is empty: logs'.\n\nFAILURES!\nTests: 3, Assertions: 6, Failures: 1."},{"mutator":{"mutatorName":"ConcatOperandRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException($configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":92},"diff":"@@ @@\n     {\n         foreach (array_keys($expectedKeys) as $configKey) {\n             if (count($configItems[$configKey]) === 0) {\n-                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n+                throw new KeyHasEmptyValueException($configKey, ResponseCode::unprocessable->value);\n             }\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.16b8da635a28fa1f37cd780a30cb2bb9.infection.xml\n\n..F\n\nTime: 00:00.003, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testThrowsExceptionIfConfigFirstLevelKeyIsEmpty with data set #0 ('[logs]\\r[auth]\\rfo=o', 'logs')\nFailed asserting that exception message 'logs' contains 'Key is empty: logs'.\n\nFAILURES!\nTests: 3, Assertions: 6, Failures: 1."},{"mutator":{"mutatorName":"ConcatOperandRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":92},"diff":"@@ @@\n     {\n         foreach (array_keys($expectedKeys) as $configKey) {\n             if (count($configItems[$configKey]) === 0) {\n-                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n+                throw new KeyHasEmptyValueException('Key is empty: ', ResponseCode::unprocessable->value);\n             }\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.5d8e094dff502628760a81615fd91137.infection.xml\n\n..F\n\nTime: 00:00.004, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testThrowsExceptionIfConfigFirstLevelKeyIsEmpty with data set #0 ('[logs]\\r[auth]\\rfo=o', 'logs')\nFailed asserting that exception message 'Key is empty: ' contains 'Key is empty: logs'.\n\nFAILURES!\nTests: 3, Assertions: 6, Failures: 1."},{"mutator":{"mutatorName":"Foreach_","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ([] as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":102},"diff":"@@ @@\n     }\n     private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n     {\n-        foreach ($expectedKeys as $configKey => $params) {\n+        foreach ([] as $configKey => $params) {\n             foreach ($params as $param) {\n                 self::ensureKeyIsSet($param, $configItems[$configKey]);\n                 self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.15aed07b17e631d226a992491f97f974.infection.xml\n\n....F\n\nTime: 00:00.007, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testThrowsExceptionIfConfigParamKeyIsMissing with data set \"path\" ('[logs]\\rdisplayErrorDetails =... x\\r\\r', 'path')\nFailed asserting that exception of type \"InvalidArgumentException\" matches expected exception \"RuntimeException\". Message was: \"The given URL is not a valid URL: x\" at\n\/app\/api\/src\/app\/response\/Url.php:28\n\/app\/api\/src\/app\/response\/Url.php:19\n\/app\/api\/src\/app\/config\/AppConfig.php:34\n\/app\/api\/tests\/unit\/app\/config\/AppConfigTest.php:337\n.\n\nFAILURES!\nTests: 5, Assertions: 9, Failures: 1."},{"mutator":{"mutatorName":"Foreach_","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ([] as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":103},"diff":"@@ @@\n     private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n     {\n         foreach ($expectedKeys as $configKey => $params) {\n-            foreach ($params as $param) {\n+            foreach ([] as $param) {\n                 self::ensureKeyIsSet($param, $configItems[$configKey]);\n                 self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n             }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.f105503b501dc1aa3182bfeef0bb0358.infection.xml\n\n....F\n\nTime: 00:00.009, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testThrowsExceptionIfConfigParamKeyIsMissing with data set \"path\" ('[logs]\\rdisplayErrorDetails =... x\\r\\r', 'path')\nFailed asserting that exception of type \"InvalidArgumentException\" matches expected exception \"RuntimeException\". Message was: \"The given URL is not a valid URL: x\" at\n\/app\/api\/src\/app\/response\/Url.php:28\n\/app\/api\/src\/app\/response\/Url.php:19\n\/app\/api\/src\/app\/config\/AppConfig.php:34\n\/app\/api\/tests\/unit\/app\/config\/AppConfigTest.php:337\n.\n\nFAILURES!\nTests: 5, Assertions: 9, Failures: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                \n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":104},"diff":"@@ @@\n     {\n         foreach ($expectedKeys as $configKey => $params) {\n             foreach ($params as $param) {\n-                self::ensureKeyIsSet($param, $configItems[$configKey]);\n+                \n                 self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n             }\n         }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.2c33a356e00ae861e8a68b59189b968b.infection.xml\n\n....F\n\nTime: 00:00.006, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testThrowsExceptionIfConfigParamKeyIsMissing with data set \"path\" ('[logs]\\rdisplayErrorDetails =... x\\r\\r', 'path')\nFailed asserting that exception of type \"InvalidArgumentException\" matches expected exception \"RuntimeException\". Message was: \"The given URL is not a valid URL: x\" at\n\/app\/api\/src\/app\/response\/Url.php:28\n\/app\/api\/src\/app\/response\/Url.php:19\n\/app\/api\/src\/app\/config\/AppConfig.php:34\n\/app\/api\/tests\/unit\/app\/config\/AppConfigTest.php:337\n.\n\nFAILURES!\nTests: 5, Assertions: 9, Failures: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                \n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":105},"diff":"@@ @@\n         foreach ($expectedKeys as $configKey => $params) {\n             foreach ($params as $param) {\n                 self::ensureKeyIsSet($param, $configItems[$configKey]);\n-                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n+                \n             }\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.2efdab0bdc1c28934bb6c9a4e429eb87.infection.xml\n\n..............F\n\nTime: 00:00.008, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testThrowsExceptionIfConfigParamValueIsEmpty with data set \"path\" ('[logs]\\rpath = \\rdisplayError... x\\r\\r', 'path')\nFailed asserting that exception of type \"InvalidArgumentException\" matches expected exception \"RuntimeException\". Message was: \"The given URL is not a valid URL: x\" at\n\/app\/api\/src\/app\/response\/Url.php:28\n\/app\/api\/src\/app\/response\/Url.php:19\n\/app\/api\/src\/app\/config\/AppConfig.php:34\n\/app\/api\/tests\/unit\/app\/config\/AppConfigTest.php:349\n.\n\nFAILURES!\nTests: 15, Assertions: 29, Failures: 1."},{"mutator":{"mutatorName":"LogicalOr","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) && self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":114},"diff":"@@ @@\n     }\n     private static function displayErrorForDebug(array $configItems): void\n     {\n-        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n+        if (self::noDebugEntryInConfig($configItems) && self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n             error_reporting(E_ERROR | E_PARSE);\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.0516a51e094e828a11fe9ebe7f31c855.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testThrowsExceptionIfConfigFirstLevelKeyIsMissing with data set \"logs\" ('[empty]\\rempty=x\\r[auth]\\rmethod=x', 'logs')\nTypeError: norsk\\api\\app\\config\\AppConfig::debugEntryIsTurnedOffByFalse(): Argument #1 ($debug) must be of type string|int|bool, null given, called in \/app\/api\/src\/app\/config\/AppConfig.php on line 74\n\n\/app\/api\/src\/app\/config\/AppConfig.php:104\n\/app\/api\/src\/app\/config\/AppConfig.php:74\n\/app\/api\/src\/app\/config\/AppConfig.php:33\n\/app\/api\/tests\/unit\/app\/config\/AppConfigTest.php:34\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1, Warnings: 2."},{"mutator":{"mutatorName":"LogicalOrAllSubExprNegation","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (!self::noDebugEntryInConfig($configItems) || !self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":114},"diff":"@@ @@\n     }\n     private static function displayErrorForDebug(array $configItems): void\n     {\n-        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n+        if (!self::noDebugEntryInConfig($configItems) || !self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n             error_reporting(E_ERROR | E_PARSE);\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.4c2f9518ca313b198e960998862bea20.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testThrowsExceptionIfConfigFirstLevelKeyIsMissing with data set \"logs\" ('[empty]\\rempty=x\\r[auth]\\rmethod=x', 'logs')\nTypeError: norsk\\api\\app\\config\\AppConfig::debugEntryIsTurnedOffByFalse(): Argument #1 ($debug) must be of type string|int|bool, null given, called in \/app\/api\/src\/app\/config\/AppConfig.php on line 74\n\n\/app\/api\/src\/app\/config\/AppConfig.php:104\n\/app\/api\/src\/app\/config\/AppConfig.php:74\n\/app\/api\/src\/app\/config\/AppConfig.php:33\n\/app\/api\/tests\/unit\/app\/config\/AppConfigTest.php:34\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1, Warnings: 2."},{"mutator":{"mutatorName":"LogicalOrNegation","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (!(self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug']))) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":114},"diff":"@@ @@\n     }\n     private static function displayErrorForDebug(array $configItems): void\n     {\n-        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n+        if (!(self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug']))) {\n             error_reporting(E_ERROR | E_PARSE);\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.ef2ffd19a0efd47936ad7976bbbcff0a.infection.xml\n\n...............................F\n\nTime: 00:00.015, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testCanSetErrorLevelToProductionLevelWithoutWarnings\nE_ERROR | E_PARSE aktiv\nFailed asserting that 32767 is identical to 5.\n\n\/app\/api\/tests\/unit\/app\/config\/AppConfigTest.php:360\n\nFAILURES!\nTests: 32, Assertions: 57, Failures: 1."},{"mutator":{"mutatorName":"LogicalOrSingleSubExprNegation","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (!self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":114},"diff":"@@ @@\n     }\n     private static function displayErrorForDebug(array $configItems): void\n     {\n-        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n+        if (!self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n             error_reporting(E_ERROR | E_PARSE);\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.54e9bccc4f2a9c398b9197b27f40c093.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testThrowsExceptionIfConfigFirstLevelKeyIsMissing with data set \"logs\" ('[empty]\\rempty=x\\r[auth]\\rmethod=x', 'logs')\nTypeError: norsk\\api\\app\\config\\AppConfig::debugEntryIsTurnedOffByFalse(): Argument #1 ($debug) must be of type string|int|bool, null given, called in \/app\/api\/src\/app\/config\/AppConfig.php on line 74\n\n\/app\/api\/src\/app\/config\/AppConfig.php:104\n\/app\/api\/src\/app\/config\/AppConfig.php:74\n\/app\/api\/src\/app\/config\/AppConfig.php:33\n\/app\/api\/tests\/unit\/app\/config\/AppConfigTest.php:34\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1, Warnings: 2."},{"mutator":{"mutatorName":"LogicalOrSingleSubExprNegation","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || !self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":114},"diff":"@@ @@\n     }\n     private static function displayErrorForDebug(array $configItems): void\n     {\n-        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n+        if (self::noDebugEntryInConfig($configItems) || !self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n             error_reporting(E_ERROR | E_PARSE);\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.72814eda029b46f220d6f6f694dd3142.infection.xml\n\n................................F                                 33 \/ 33 (100%)\n\nTime: 00:00.015, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testDoestNotSetErrorLevelToProductionLevelWithoutWarningsIfDebugIsInConfig\nE_ALL aktiv\nFailed asserting that 5 is identical to 32767.\n\n\/app\/api\/tests\/unit\/app\/config\/AppConfigTest.php:371\n\nFAILURES!\nTests: 33, Assertions: 58, Failures: 1."},{"mutator":{"mutatorName":"BitwiseOr","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR & E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":119},"diff":"@@ @@\n     private static function displayErrorForDebug(array $configItems): void\n     {\n         if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n-            error_reporting(E_ERROR | E_PARSE);\n+            error_reporting(E_ERROR & E_PARSE);\n         }\n     }\n     private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.419c96ad27b87ef0630d5f827df008f9.infection.xml\n\n...............................F\n\nTime: 00:00.013, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testCanSetErrorLevelToProductionLevelWithoutWarnings\nE_ERROR | E_PARSE aktiv\nFailed asserting that 0 is identical to 5.\n\n\/app\/api\/tests\/unit\/app\/config\/AppConfigTest.php:360\n\nFAILURES!\nTests: 32, Assertions: 57, Failures: 1."},{"mutator":{"mutatorName":"FunctionCallRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            \n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":119},"diff":"@@ @@\n     private static function displayErrorForDebug(array $configItems): void\n     {\n         if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n-            error_reporting(E_ERROR | E_PARSE);\n+            \n         }\n     }\n     private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.3748321bc5e34ab34eac109c0a24b0eb.infection.xml\n\n...............................F\n\nTime: 00:00.013, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testCanSetErrorLevelToProductionLevelWithoutWarnings\nE_ERROR | E_PARSE aktiv\nFailed asserting that 32767 is identical to 5.\n\n\/app\/api\/tests\/unit\/app\/config\/AppConfigTest.php:360\n\nFAILURES!\nTests: 32, Assertions: 57, Failures: 1."},{"mutator":{"mutatorName":"Identical","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems !== '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":126},"diff":"@@ @@\n     }\n     private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n     {\n-        if ($configItems === '') {\n+        if ($configItems !== '') {\n             throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.c569b208c9bccefb030f60e2f6bc15f3.infection.xml\n\nE\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testThrowsExceptionIfConfigFirstLevelKeyIsMissing with data set \"logs\" ('[empty]\\rempty=x\\r[auth]\\rmethod=x', 'logs')\nnorsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException: Key is empty: path\n\n\/app\/api\/src\/app\/config\/AppConfig.php:81\n\/app\/api\/src\/app\/config\/AppConfig.php:68\n\/app\/api\/src\/app\/config\/AppConfig.php:41\n\/app\/api\/src\/app\/config\/AppConfig.php:32\n\/app\/api\/tests\/unit\/app\/config\/AppConfigTest.php:34\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Throw_","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":127},"diff":"@@ @@\n     private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n     {\n         if ($configItems === '') {\n-            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n+            new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n         }\n     }\n     private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.912f2e1e93035de0049c223ba54217c4.infection.xml\n\n..............F\n\nTime: 00:00.008, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testThrowsExceptionIfConfigParamValueIsEmpty with data set \"path\" ('[logs]\\rpath = \\rdisplayError... x\\r\\r', 'path')\nFailed asserting that exception of type \"InvalidArgumentException\" matches expected exception \"RuntimeException\". Message was: \"The given URL is not a valid URL: x\" at\n\/app\/api\/src\/app\/response\/Url.php:28\n\/app\/api\/src\/app\/response\/Url.php:19\n\/app\/api\/src\/app\/config\/AppConfig.php:34\n\/app\/api\/tests\/unit\/app\/config\/AppConfigTest.php:349\n.\n\nFAILURES!\nTests: 15, Assertions: 29, Failures: 1."},{"mutator":{"mutatorName":"Concat","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException($param . 'Key is empty: ', ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":128},"diff":"@@ @@\n     private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n     {\n         if ($configItems === '') {\n-            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n+            throw new KeyHasEmptyValueException($param . 'Key is empty: ', ResponseCode::unprocessable->value);\n         }\n     }\n     private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.bc3aabe470057f8ab680bfe52c0512c2.infection.xml\n\n..............F\n\nTime: 00:00.008, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testThrowsExceptionIfConfigParamValueIsEmpty with data set \"path\" ('[logs]\\rpath = \\rdisplayError... x\\r\\r', 'path')\nFailed asserting that exception message 'pathKey is empty: ' contains 'Key is empty: path'.\n\nFAILURES!\nTests: 15, Assertions: 30, Failures: 1."},{"mutator":{"mutatorName":"ConcatOperandRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException($param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":128},"diff":"@@ @@\n     private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n     {\n         if ($configItems === '') {\n-            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n+            throw new KeyHasEmptyValueException($param, ResponseCode::unprocessable->value);\n         }\n     }\n     private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.a5d3132540dad14b63577c882e585541.infection.xml\n\n..............F\n\nTime: 00:00.011, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testThrowsExceptionIfConfigParamValueIsEmpty with data set \"path\" ('[logs]\\rpath = \\rdisplayError... x\\r\\r', 'path')\nFailed asserting that exception message 'path' contains 'Key is empty: path'.\n\nFAILURES!\nTests: 15, Assertions: 30, Failures: 1."},{"mutator":{"mutatorName":"ConcatOperandRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ', ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":128},"diff":"@@ @@\n     private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n     {\n         if ($configItems === '') {\n-            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n+            throw new KeyHasEmptyValueException('Key is empty: ', ResponseCode::unprocessable->value);\n         }\n     }\n     private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.c1b986c0c26974d3806a2d7729d7789f.infection.xml\n\n..............F\n\nTime: 00:00.008, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testThrowsExceptionIfConfigParamValueIsEmpty with data set \"path\" ('[logs]\\rpath = \\rdisplayError... x\\r\\r', 'path')\nFailed asserting that exception message 'Key is empty: ' contains 'Key is empty: path'.\n\nFAILURES!\nTests: 15, Assertions: 30, Failures: 1."},{"mutator":{"mutatorName":"Concat","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(self::API_ROOT . __DIR__ . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":137},"diff":"@@ @@\n     }\n     private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n     {\n-        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n+        $path = Path::fromString(self::API_ROOT . __DIR__ . $logConfigItems['path']);\n         $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n         $logErrors = $logConfigItems['logErrors'];\n         $logErrorDetails = $logConfigItems['logErrorDetails'];","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.ae5a205cd41f0d310daf1b0346ea9979.infection.xml\n\n..........................F\n\nTime: 00:00.012, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testCanGetLogPath\nFailed asserting that false is identical to '\/app\/api\/logs'.\n\n\/app\/api\/tests\/unit\/app\/config\/AppConfigTest.php:249\n\nFAILURES!\nTests: 27, Assertions: 52, Failures: 1."},{"mutator":{"mutatorName":"ConcatOperandRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":137},"diff":"@@ @@\n     }\n     private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n     {\n-        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n+        $path = Path::fromString(self::API_ROOT . $logConfigItems['path']);\n         $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n         $logErrors = $logConfigItems['logErrors'];\n         $logErrorDetails = $logConfigItems['logErrorDetails'];","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.c089ed50ac4b45b80162ca760759f8af.infection.xml\n\n..........................F\n\nTime: 00:00.013, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testCanGetLogPath\nFailed asserting that false is identical to '\/app\/api\/logs'.\n\n\/app\/api\/tests\/unit\/app\/config\/AppConfigTest.php:249\n\nFAILURES!\nTests: 27, Assertions: 52, Failures: 1."},{"mutator":{"mutatorName":"ConcatOperandRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":137},"diff":"@@ @@\n     }\n     private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n     {\n-        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n+        $path = Path::fromString(__DIR__ . $logConfigItems['path']);\n         $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n         $logErrors = $logConfigItems['logErrors'];\n         $logErrorDetails = $logConfigItems['logErrorDetails'];","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.7a95b6735ceee260f7aff539e795a10c.infection.xml\n\n..........................F\n\nTime: 00:00.013, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testCanGetLogPath\nFailed asserting that false is identical to '\/app\/api\/logs'.\n\n\/app\/api\/tests\/unit\/app\/config\/AppConfigTest.php:249\n\nFAILURES!\nTests: 27, Assertions: 52, Failures: 1."},{"mutator":{"mutatorName":"Concat","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . $logConfigItems['path'] . self::API_ROOT);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":137},"diff":"@@ @@\n     }\n     private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n     {\n-        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n+        $path = Path::fromString(__DIR__ . $logConfigItems['path'] . self::API_ROOT);\n         $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n         $logErrors = $logConfigItems['logErrors'];\n         $logErrorDetails = $logConfigItems['logErrorDetails'];","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.6d56ef23f74ea235ed985435b2703e3f.infection.xml\n\n..........................F\n\nTime: 00:00.013, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testCanGetLogPath\nFailed asserting that false is identical to '\/app\/api\/logs'.\n\n\/app\/api\/tests\/unit\/app\/config\/AppConfigTest.php:249\n\nFAILURES!\nTests: 27, Assertions: 52, Failures: 1."},{"mutator":{"mutatorName":"ConcatOperandRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":137},"diff":"@@ @@\n     }\n     private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n     {\n-        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n+        $path = Path::fromString(__DIR__ . self::API_ROOT);\n         $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n         $logErrors = $logConfigItems['logErrors'];\n         $logErrorDetails = $logConfigItems['logErrorDetails'];","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.10b4f8ffe1f87ae23941558f136d96c0.infection.xml\n\n..........................F\n\nTime: 00:00.015, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testCanGetLogPath\nFailed asserting that two strings are identical.\n--- Expected\n+++ Actual\n@@ @@\n-'\/app\/api\/logs'\n+'\/app\/api'\n\n\/app\/api\/tests\/unit\/app\/config\/AppConfigTest.php:249\n\nFAILURES!\nTests: 27, Assertions: 52, Failures: 1."},{"mutator":{"mutatorName":"LogicalNot","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":159},"diff":"@@ @@\n     }\n     private static function noDebugEntryInConfig(array $configItems): bool\n     {\n-        return !isset($configItems[self::ERROR]['debug']);\n+        return isset($configItems[self::ERROR]['debug']);\n     }\n     private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n     {","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.53c461b2450b8828ef83555d6e7d10c6.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testThrowsExceptionIfConfigFirstLevelKeyIsMissing with data set \"logs\" ('[empty]\\rempty=x\\r[auth]\\rmethod=x', 'logs')\nTypeError: norsk\\api\\app\\config\\AppConfig::debugEntryIsTurnedOffByFalse(): Argument #1 ($debug) must be of type string|int|bool, null given, called in \/app\/api\/src\/app\/config\/AppConfig.php on line 74\n\n\/app\/api\/src\/app\/config\/AppConfig.php:104\n\/app\/api\/src\/app\/config\/AppConfig.php:74\n\/app\/api\/src\/app\/config\/AppConfig.php:33\n\/app\/api\/tests\/unit\/app\/config\/AppConfigTest.php:34\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1, Warnings: 2."},{"mutator":{"mutatorName":"TrueValue","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== false;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":165},"diff":"@@ @@\n     }\n     private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n     {\n-        return $debug !== true;\n+        return $debug !== false;\n     }\n     public function getLogPath(): Path\n     {","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.ea58358e8ba4fb6b6dcfeed1eb88103f.infection.xml\n\n................................F                                 33 \/ 33 (100%)\n\nTime: 00:00.013, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testDoestNotSetErrorLevelToProductionLevelWithoutWarningsIfDebugIsInConfig\nE_ALL aktiv\nFailed asserting that 5 is identical to 32767.\n\n\/app\/api\/tests\/unit\/app\/config\/AppConfigTest.php:371\n\nFAILURES!\nTests: 33, Assertions: 58, Failures: 1."},{"mutator":{"mutatorName":"NotIdentical","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug === true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":165},"diff":"@@ @@\n     }\n     private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n     {\n-        return $debug !== true;\n+        return $debug === true;\n     }\n     public function getLogPath(): Path\n     {","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.1917121a7bd436b1611dea86703abe8b.infection.xml\n\n................................F                                 33 \/ 33 (100%)\n\nTime: 00:00.014, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testDoestNotSetErrorLevelToProductionLevelWithoutWarningsIfDebugIsInConfig\nE_ALL aktiv\nFailed asserting that 5 is identical to 32767.\n\n\/app\/api\/tests\/unit\/app\/config\/AppConfigTest.php:371\n\nFAILURES!\nTests: 33, Assertions: 58, Failures: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    protected function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":169},"diff":"@@ @@\n     {\n         return $debug !== true;\n     }\n-    public function getLogPath(): Path\n+    protected function getLogPath(): Path\n     {\n         return $this->appLoggerConfig->getPath();\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.1995c4a0e65ed972fc286ce477203697.infection.xml\n\n..........................E\n\nTime: 00:00.012, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testCanGetLogPath\nError: Call to protected method norsk\\api\\app\\config\\AppConfig::getLogPath() from scope norsk\\api\\app\\config\\AppConfigTest\n\n\/app\/api\/tests\/unit\/app\/config\/AppConfigTest.php:253\n\nERRORS!\nTests: 27, Assertions: 51, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    protected function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":175},"diff":"@@ @@\n     {\n         return $this->appLoggerConfig->getPath();\n     }\n-    public function getJwtConfig(): JwtConfig\n+    protected function getJwtConfig(): JwtConfig\n     {\n         return $this->jwtConfig;\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.f5a64f0dee4f04fc9ea124aaf5b3b8cb.infection.xml\n\n...........................E\n\nTime: 00:00.012, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testCanGetJwtCredentials\nError: Call to protected method norsk\\api\\app\\config\\AppConfig::getJwtConfig() from scope norsk\\api\\app\\config\\AppConfigTest\n\n\/app\/api\/tests\/unit\/app\/config\/AppConfigTest.php:267\n\nERRORS!\nTests: 28, Assertions: 52, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    protected function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":181},"diff":"@@ @@\n     {\n         return $this->jwtConfig;\n     }\n-    public function getPepper(): Pepper\n+    protected function getPepper(): Pepper\n     {\n         return $this->pepper;\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.13a49edf7e27723708b41734b9f48001.infection.xml\n\n............................E\n\nTime: 00:00.012, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testCenGetPepper\nError: Call to protected method norsk\\api\\app\\config\\AppConfig::getPepper() from scope norsk\\api\\app\\config\\AppConfigTest\n\n\/app\/api\/tests\/unit\/app\/config\/AppConfigTest.php:276\n\nERRORS!\nTests: 29, Assertions: 53, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    protected function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":187},"diff":"@@ @@\n     {\n         return $this->pepper;\n     }\n-    public function getUrl(): Url\n+    protected function getUrl(): Url\n     {\n         return $this->url;\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.780c1f6fbfd9ca839108da289ac25a72.infection.xml\n\n.............................E\n\nTime: 00:00.012, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testCenGetUrl\nError: Call to protected method norsk\\api\\app\\config\\AppConfig::getUrl() from scope norsk\\api\\app\\config\\AppConfigTest\n\n\/app\/api\/tests\/unit\/app\/config\/AppConfigTest.php:285\n\nERRORS!\nTests: 30, Assertions: 54, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    public function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm;\nuse norsk\\api\\app\\identityAccessManagement\\AuthenticationKey;\nuse norsk\\api\\app\\identityAccessManagement\\JwtAudience;\nuse norsk\\api\\app\\identityAccessManagement\\JwtConfig;\nuse norsk\\api\\app\\identityAccessManagement\\JwtSubject;\nuse norsk\\api\\app\\logging\\AppLoggerConfig;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\Pepper;\nclass AppConfig\n{\n    private const string API_ROOT = '\/..\/..\/..\/';\n    private const string ERROR = 'error';\n    private const string LOGS = 'logs';\n    private const string AUTH = 'auth';\n    private const array LOGS_SECOND_LEVEL = ['path', 'displayErrorDetails', 'logErrors', 'logErrorDetails'];\n    private const array AUTH_SECOND_LEVEL = ['method', 'key', 'sub', 'aud', 'addition', 'originUrl'];\n    private function __construct(private readonly AppLoggerConfig $appLoggerConfig, private readonly JwtConfig $jwtConfig, private readonly Pepper $pepper, private readonly Url $url)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        self::displayErrorForDebug($configItems);\n        return new self(self::readLoggerConfig($configItems[self::LOGS]), self::readJwtConfig($configItems[self::AUTH]), Pepper::by($configItems[self::AUTH]['addition']), Url::by($configItems[self::AUTH]['originUrl']));\n    }\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        $expectedKeys = [self::LOGS => self::LOGS_SECOND_LEVEL, self::AUTH => self::AUTH_SECOND_LEVEL];\n        self::ensureKeysExist($configItems, $expectedKeys);\n        self::ensureKeyHasValue($configItems, $expectedKeys);\n        self::ensureParamsExist($configItems, $expectedKeys);\n    }\n    private static function ensureKeysExist(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            self::ensureKeyIsSet($configKey, $configItems);\n        }\n    }\n    private static function ensureKeyIsSet(string|int|bool|null $param, array $array): void\n    {\n        if (!array_key_exists($param, $array)) {\n            throw new KeyIsNotSetException('Key is not set: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function ensureKeyHasValue(array $configItems, array $expectedKeys): void\n    {\n        foreach (array_keys($expectedKeys) as $configKey) {\n            if (count($configItems[$configKey]) === 0) {\n                throw new KeyHasEmptyValueException('Key is empty: ' . $configKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    private static function ensureParamsExist(array $configItems, array $expectedKeys): void\n    {\n        foreach ($expectedKeys as $configKey => $params) {\n            foreach ($params as $param) {\n                self::ensureKeyIsSet($param, $configItems[$configKey]);\n                self::ensureKeyIsNotEmpty($configItems[$configKey][$param], $param);\n            }\n        }\n    }\n    private static function displayErrorForDebug(array $configItems): void\n    {\n        if (self::noDebugEntryInConfig($configItems) || self::debugEntryIsTurnedOffByFalse($configItems[self::ERROR]['debug'])) {\n            error_reporting(E_ERROR | E_PARSE);\n        }\n    }\n    private static function ensureKeyIsNotEmpty(string|int|bool|null $configItems, string $param): void\n    {\n        if ($configItems === '') {\n            throw new KeyHasEmptyValueException('Key is empty: ' . $param, ResponseCode::unprocessable->value);\n        }\n    }\n    private static function readLoggerConfig(array $logConfigItems): AppLoggerConfig\n    {\n        $path = Path::fromString(__DIR__ . self::API_ROOT . $logConfigItems['path']);\n        $displayErrorDetails = $logConfigItems['displayErrorDetails'];\n        $logErrors = $logConfigItems['logErrors'];\n        $logErrorDetails = $logConfigItems['logErrorDetails'];\n        return AppLoggerConfig::by($path, (bool) $displayErrorDetails, (bool) $logErrors, (bool) $logErrorDetails);\n    }\n    private static function readJwtConfig(array $auth): JwtConfig\n    {\n        $key = AuthenticationKey::by($auth['key']);\n        $method = AuthenticationAlgorithm::by($auth['method']);\n        $subject = JwtSubject::by($auth['sub']);\n        $audience = JwtAudience::by($auth['aud']);\n        return JwtConfig::fromCredentials($key, $method, $subject, $audience);\n    }\n    private static function noDebugEntryInConfig(array $configItems): bool\n    {\n        return !isset($configItems[self::ERROR]['debug']);\n    }\n    private static function debugEntryIsTurnedOffByFalse(int|string|bool $debug): bool\n    {\n        return $debug !== true;\n    }\n    public function getLogPath(): Path\n    {\n        return $this->appLoggerConfig->getPath();\n    }\n    public function getJwtConfig(): JwtConfig\n    {\n        return $this->jwtConfig;\n    }\n    public function getPepper(): Pepper\n    {\n        return $this->pepper;\n    }\n    public function getUrl(): Url\n    {\n        return $this->url;\n    }\n    protected function getAppLoggerConfig(): AppLoggerConfig\n    {\n        return $this->appLoggerConfig;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/AppConfig.php","originalStartLine":193},"diff":"@@ @@\n     {\n         return $this->url;\n     }\n-    public function getAppLoggerConfig(): AppLoggerConfig\n+    protected function getAppLoggerConfig(): AppLoggerConfig\n     {\n         return $this->appLoggerConfig;\n     }\n }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.6a7434657eca34de26a42df8377adc2f.infection.xml\n\n..............................E\n\nTime: 00:00.013, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\config\\AppConfigTest::testCenGetAppLoggerConfig\nError: Call to protected method norsk\\api\\app\\config\\AppConfig::getAppLoggerConfig() from scope norsk\\api\\app\\config\\AppConfigTest\n\n\/app\/api\/tests\/unit\/app\/config\/AppConfigTest.php:294\n\nERRORS!\nTests: 31, Assertions: 55, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    protected static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/DbConfig.php","originalStartLine":36},"diff":"@@ @@\n     private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n     {\n     }\n-    public static function fromPath(Path $configPath): self\n+    protected static function fromPath(Path $configPath): self\n     {\n         $file = File::fromPath($configPath);\n         $configItems = $file->parseIniFile()->asArray();","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.414ac278fd5d5adb1dbe38a45b60a163.infection.xml\n\nE\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\config\\DbConfigTest::testThrowsExceptionIfValueDoesNotExist with data set \"host\" ('[database]\\rdb_server = \\rdb_... = foo', 'db_server')\nError: Call to protected method norsk\\api\\app\\config\\DbConfig::fromPath() from scope norsk\\api\\app\\config\\DbConfigTest\n\n\/app\/api\/tests\/unit\/app\/config\/DbConfigTest.php:127\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        \n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/DbConfig.php","originalStartLine":40},"diff":"@@ @@\n     {\n         $file = File::fromPath($configPath);\n         $configItems = $file->parseIniFile()->asArray();\n-        self::ensureConfigIsValid($configItems);\n+        \n         return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n     }\n     \/**","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.20f1b7f410c146b55b4cca51d7b19638.infection.xml\n\nF\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\DbConfigTest::testThrowsExceptionIfValueDoesNotExist with data set \"host\" ('[database]\\rdb_server = \\rdb_... = foo', 'db_server')\nFailed asserting that exception of type \"InvalidArgumentException\" matches expected exception \"RuntimeException\". Message was: \"Host is not set\" at\n\/app\/api\/src\/app\/persistence\/Host.php:28\n\/app\/api\/src\/app\/persistence\/Host.php:19\n\/app\/api\/src\/app\/config\/DbConfig.php:30\n\/app\/api\/tests\/unit\/app\/config\/DbConfigTest.php:121\n.\n\nFAILURES!\nTests: 1, Assertions: 1, Failures: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        \n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/DbConfig.php","originalStartLine":57},"diff":"@@ @@\n      *\/\n     private static function ensureConfigIsValid(array $configItems): void\n     {\n-        self::ensureKeysExist($configItems);\n+        \n         self::ensureKeysHaveValues($configItems);\n     }\n     private static function ensureKeysExist(array $configItems): void","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.a2da3d5fc487440e575bfb28ccaf2ece.infection.xml\n\n......F\n\nTime: 00:00.007, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\DbConfigTest::testThrowsExceptionIfKeyDoesNotExist with data set \"host\" ('[database]', 'db_server')\nFailed asserting that exception of type \"TypeError\" matches expected exception \"RuntimeException\". Message was: \"norsk\\api\\app\\persistence\\Host::fromString(): Argument #1 ($host) must be of type string, null given, called in \/app\/api\/src\/app\/config\/DbConfig.php on line 30\" at\n\/app\/api\/src\/app\/persistence\/Host.php:17\n\/app\/api\/src\/app\/config\/DbConfig.php:30\n\/app\/api\/tests\/unit\/app\/config\/DbConfigTest.php:104\n.\n\nFAILURES!\nTests: 7, Assertions: 19, Failures: 1, Warnings: 6."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        \n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/DbConfig.php","originalStartLine":58},"diff":"@@ @@\n     private static function ensureConfigIsValid(array $configItems): void\n     {\n         self::ensureKeysExist($configItems);\n-        self::ensureKeysHaveValues($configItems);\n+        \n     }\n     private static function ensureKeysExist(array $configItems): void\n     {","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.eca9c52f23c93e917f16d5bc6f9f2532.infection.xml\n\nF\n\nTime: 00:00.003, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\DbConfigTest::testThrowsExceptionIfValueDoesNotExist with data set \"host\" ('[database]\\rdb_server = \\rdb_... = foo', 'db_server')\nFailed asserting that exception of type \"InvalidArgumentException\" matches expected exception \"RuntimeException\". Message was: \"Host is not set\" at\n\/app\/api\/src\/app\/persistence\/Host.php:28\n\/app\/api\/src\/app\/persistence\/Host.php:19\n\/app\/api\/src\/app\/config\/DbConfig.php:30\n\/app\/api\/tests\/unit\/app\/config\/DbConfigTest.php:121\n.\n\nFAILURES!\nTests: 1, Assertions: 1, Failures: 1."},{"mutator":{"mutatorName":"Foreach_","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ([] as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/DbConfig.php","originalStartLine":66},"diff":"@@ @@\n     private static function ensureKeysExist(array $configItems): void\n     {\n         $neededKeys = self::getKeys();\n-        foreach ($neededKeys as $neededKey) {\n+        foreach ([] as $neededKey) {\n             if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                 throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n             }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.82ab5d8f33a474b89cca87f992b1dffa.infection.xml\n\n......F\n\nTime: 00:00.007, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\DbConfigTest::testThrowsExceptionIfKeyDoesNotExist with data set \"host\" ('[database]', 'db_server')\nFailed asserting that exception of type \"TypeError\" matches expected exception \"RuntimeException\". Message was: \"norsk\\api\\app\\persistence\\Host::fromString(): Argument #1 ($host) must be of type string, null given, called in \/app\/api\/src\/app\/config\/DbConfig.php on line 30\" at\n\/app\/api\/src\/app\/persistence\/Host.php:17\n\/app\/api\/src\/app\/config\/DbConfig.php:30\n\/app\/api\/tests\/unit\/app\/config\/DbConfigTest.php:104\n.\n\nFAILURES!\nTests: 7, Assertions: 19, Failures: 1, Warnings: 6."},{"mutator":{"mutatorName":"LogicalNot","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/DbConfig.php","originalStartLine":67},"diff":"@@ @@\n     {\n         $neededKeys = self::getKeys();\n         foreach ($neededKeys as $neededKey) {\n-            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n+            if (array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                 throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n             }\n         }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.5377707cd93899c3da186cbebb9aa9ef.infection.xml\n\nE\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\config\\DbConfigTest::testThrowsExceptionIfValueDoesNotExist with data set \"host\" ('[database]\\rdb_server = \\rdb_... = foo', 'db_server')\nnorsk\\api\\app\\config\\exceptions\\KeyIsNotSetException: db_server is not set.\n\n\/app\/api\/src\/app\/config\/DbConfig.php:45\n\/app\/api\/src\/app\/config\/DbConfig.php:37\n\/app\/api\/src\/app\/config\/DbConfig.php:29\n\/app\/api\/tests\/unit\/app\/config\/DbConfigTest.php:127\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Concat","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException(' is not set.' . $neededKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/DbConfig.php","originalStartLine":68},"diff":"@@ @@\n         $neededKeys = self::getKeys();\n         foreach ($neededKeys as $neededKey) {\n             if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n-                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n+                throw new KeyIsNotSetException(' is not set.' . $neededKey, ResponseCode::unprocessable->value);\n             }\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.8c75df01200b81d2e87990fcb0a6245c.infection.xml\n\n......F\n\nTime: 00:00.005, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\DbConfigTest::testThrowsExceptionIfKeyDoesNotExist with data set \"host\" ('[database]', 'db_server')\nFailed asserting that exception message ' is not set.db_server' contains 'db_server is not set.'.\n\nFAILURES!\nTests: 7, Assertions: 20, Failures: 1."},{"mutator":{"mutatorName":"ConcatOperandRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException(' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/DbConfig.php","originalStartLine":68},"diff":"@@ @@\n         $neededKeys = self::getKeys();\n         foreach ($neededKeys as $neededKey) {\n             if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n-                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n+                throw new KeyIsNotSetException(' is not set.', ResponseCode::unprocessable->value);\n             }\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.20d4f06b4689568c5c1ed933f9de442b.infection.xml\n\n......F\n\nTime: 00:00.004, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\DbConfigTest::testThrowsExceptionIfKeyDoesNotExist with data set \"host\" ('[database]', 'db_server')\nFailed asserting that exception message ' is not set.' contains 'db_server is not set.'.\n\nFAILURES!\nTests: 7, Assertions: 20, Failures: 1."},{"mutator":{"mutatorName":"ConcatOperandRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/DbConfig.php","originalStartLine":68},"diff":"@@ @@\n         $neededKeys = self::getKeys();\n         foreach ($neededKeys as $neededKey) {\n             if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n-                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n+                throw new KeyIsNotSetException($neededKey, ResponseCode::unprocessable->value);\n             }\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.7543fc1f4d47e5b784f260b22acccb40.infection.xml\n\n......F\n\nTime: 00:00.006, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\DbConfigTest::testThrowsExceptionIfKeyDoesNotExist with data set \"host\" ('[database]', 'db_server')\nFailed asserting that exception message 'db_server' contains 'db_server is not set.'.\n\nFAILURES!\nTests: 7, Assertions: 20, Failures: 1."},{"mutator":{"mutatorName":"Throw_","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/DbConfig.php","originalStartLine":68},"diff":"@@ @@\n         $neededKeys = self::getKeys();\n         foreach ($neededKeys as $neededKey) {\n             if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n-                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n+                new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n             }\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.c206ccf7f68a1b5c7606b821b2bb7866.infection.xml\n\n......F\n\nTime: 00:00.006, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\DbConfigTest::testThrowsExceptionIfKeyDoesNotExist with data set \"host\" ('[database]', 'db_server')\nFailed asserting that exception of type \"TypeError\" matches expected exception \"RuntimeException\". Message was: \"norsk\\api\\app\\persistence\\Host::fromString(): Argument #1 ($host) must be of type string, null given, called in \/app\/api\/src\/app\/config\/DbConfig.php on line 30\" at\n\/app\/api\/src\/app\/persistence\/Host.php:17\n\/app\/api\/src\/app\/config\/DbConfig.php:30\n\/app\/api\/tests\/unit\/app\/config\/DbConfigTest.php:104\n.\n\nFAILURES!\nTests: 7, Assertions: 19, Failures: 1, Warnings: 6."},{"mutator":{"mutatorName":"ArrayItemRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/DbConfig.php","originalStartLine":79},"diff":"@@ @@\n      *\/\n     private static function getKeys(): array\n     {\n-        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n+        return [self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n     }\n     private static function ensureKeysHaveValues(array $configItems): void\n     {","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.c2d3d7966d3ef4f4c11591f4b61ea056.infection.xml\n\nF\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\DbConfigTest::testThrowsExceptionIfValueDoesNotExist with data set \"host\" ('[database]\\rdb_server = \\rdb_... = foo', 'db_server')\nFailed asserting that exception of type \"InvalidArgumentException\" matches expected exception \"RuntimeException\". Message was: \"Host is not set\" at\n\/app\/api\/src\/app\/persistence\/Host.php:28\n\/app\/api\/src\/app\/persistence\/Host.php:19\n\/app\/api\/src\/app\/config\/DbConfig.php:30\n\/app\/api\/tests\/unit\/app\/config\/DbConfigTest.php:121\n.\n\nFAILURES!\nTests: 1, Assertions: 1, Failures: 1."},{"mutator":{"mutatorName":"Foreach_","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ([] as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/DbConfig.php","originalStartLine":93},"diff":"@@ @@\n     private static function ensureKeysHaveValues(array $configItems): void\n     {\n         $neededKeys = self::getKeys();\n-        foreach ($neededKeys as $neededKey) {\n+        foreach ([] as $neededKey) {\n             if ($configItems[self::DATABASE][$neededKey] === '') {\n                 throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n             }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.ffc3e88fd0a7337e23c34e901883eeb1.infection.xml\n\nF\n\nTime: 00:00.003, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\DbConfigTest::testThrowsExceptionIfValueDoesNotExist with data set \"host\" ('[database]\\rdb_server = \\rdb_... = foo', 'db_server')\nFailed asserting that exception of type \"InvalidArgumentException\" matches expected exception \"RuntimeException\". Message was: \"Host is not set\" at\n\/app\/api\/src\/app\/persistence\/Host.php:28\n\/app\/api\/src\/app\/persistence\/Host.php:19\n\/app\/api\/src\/app\/config\/DbConfig.php:30\n\/app\/api\/tests\/unit\/app\/config\/DbConfigTest.php:121\n.\n\nFAILURES!\nTests: 1, Assertions: 1, Failures: 1."},{"mutator":{"mutatorName":"Identical","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] !== '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/DbConfig.php","originalStartLine":94},"diff":"@@ @@\n     {\n         $neededKeys = self::getKeys();\n         foreach ($neededKeys as $neededKey) {\n-            if ($configItems[self::DATABASE][$neededKey] === '') {\n+            if ($configItems[self::DATABASE][$neededKey] !== '') {\n                 throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n             }\n         }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.993abd7277268efe9f63ae6c7cfe45ff.infection.xml\n\nE\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\config\\DbConfigTest::testThrowsExceptionIfValueDoesNotExist with data set \"host\" ('[database]\\rdb_server = \\rdb_... = foo', 'db_server')\nnorsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException: db_server is empty.\n\n\/app\/api\/src\/app\/config\/DbConfig.php:61\n\/app\/api\/src\/app\/config\/DbConfig.php:38\n\/app\/api\/src\/app\/config\/DbConfig.php:29\n\/app\/api\/tests\/unit\/app\/config\/DbConfigTest.php:127\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Concat","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException(' is empty.' . $neededKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/DbConfig.php","originalStartLine":95},"diff":"@@ @@\n         $neededKeys = self::getKeys();\n         foreach ($neededKeys as $neededKey) {\n             if ($configItems[self::DATABASE][$neededKey] === '') {\n-                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n+                throw new KeyHasEmptyValueException(' is empty.' . $neededKey, ResponseCode::unprocessable->value);\n             }\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.9596737da60ebfc7ada60438972559d4.infection.xml\n\nF\n\nTime: 00:00.003, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\DbConfigTest::testThrowsExceptionIfValueDoesNotExist with data set \"host\" ('[database]\\rdb_server = \\rdb_... = foo', 'db_server')\nFailed asserting that exception message ' is empty.db_server' contains 'db_server is empty.'.\n\nFAILURES!\nTests: 1, Assertions: 2, Failures: 1."},{"mutator":{"mutatorName":"ConcatOperandRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException(' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/DbConfig.php","originalStartLine":95},"diff":"@@ @@\n         $neededKeys = self::getKeys();\n         foreach ($neededKeys as $neededKey) {\n             if ($configItems[self::DATABASE][$neededKey] === '') {\n-                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n+                throw new KeyHasEmptyValueException(' is empty.', ResponseCode::unprocessable->value);\n             }\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.aefae2fa77c5f67b77abf56d0cb0f5c6.infection.xml\n\nF\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\DbConfigTest::testThrowsExceptionIfValueDoesNotExist with data set \"host\" ('[database]\\rdb_server = \\rdb_... = foo', 'db_server')\nFailed asserting that exception message ' is empty.' contains 'db_server is empty.'.\n\nFAILURES!\nTests: 1, Assertions: 2, Failures: 1."},{"mutator":{"mutatorName":"ConcatOperandRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey, ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/DbConfig.php","originalStartLine":95},"diff":"@@ @@\n         $neededKeys = self::getKeys();\n         foreach ($neededKeys as $neededKey) {\n             if ($configItems[self::DATABASE][$neededKey] === '') {\n-                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n+                throw new KeyHasEmptyValueException($neededKey, ResponseCode::unprocessable->value);\n             }\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.889d2d79d275b99151dd31514049e915.infection.xml\n\nF\n\nTime: 00:00.003, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\DbConfigTest::testThrowsExceptionIfValueDoesNotExist with data set \"host\" ('[database]\\rdb_server = \\rdb_... = foo', 'db_server')\nFailed asserting that exception message 'db_server' contains 'db_server is empty.'.\n\nFAILURES!\nTests: 1, Assertions: 2, Failures: 1."},{"mutator":{"mutatorName":"Throw_","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/DbConfig.php","originalStartLine":95},"diff":"@@ @@\n         $neededKeys = self::getKeys();\n         foreach ($neededKeys as $neededKey) {\n             if ($configItems[self::DATABASE][$neededKey] === '') {\n-                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n+                new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n             }\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.850d2601f40146014934098c1b732b35.infection.xml\n\nF\n\nTime: 00:00.003, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\DbConfigTest::testThrowsExceptionIfValueDoesNotExist with data set \"host\" ('[database]\\rdb_server = \\rdb_... = foo', 'db_server')\nFailed asserting that exception of type \"InvalidArgumentException\" matches expected exception \"RuntimeException\". Message was: \"Host is not set\" at\n\/app\/api\/src\/app\/persistence\/Host.php:28\n\/app\/api\/src\/app\/persistence\/Host.php:19\n\/app\/api\/src\/app\/config\/DbConfig.php:30\n\/app\/api\/tests\/unit\/app\/config\/DbConfigTest.php:121\n.\n\nFAILURES!\nTests: 1, Assertions: 1, Failures: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    protected function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/DbConfig.php","originalStartLine":101},"diff":"@@ @@\n             }\n         }\n     }\n-    public function host(): Host\n+    protected function host(): Host\n     {\n         return $this->host;\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.6db1d2c6423104a5e477738d52805b1d.infection.xml\n\n...........E\n\nTime: 00:00.007, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\config\\DbConfigTest::testCanReadDbServer\nError: Call to protected method norsk\\api\\app\\config\\DbConfig::host() from scope norsk\\api\\app\\config\\DbConfigTest\n\n\/app\/api\/tests\/unit\/app\/config\/DbConfigTest.php:69\n\nERRORS!\nTests: 12, Assertions: 33, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    protected function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/DbConfig.php","originalStartLine":107},"diff":"@@ @@\n     {\n         return $this->host;\n     }\n-    public function database(): DatabaseName\n+    protected function database(): DatabaseName\n     {\n         return $this->name;\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.bde59636a385f4c0dcb0c2f3a603979c.infection.xml\n\n............E\n\nTime: 00:00.007, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\config\\DbConfigTest::testCanReadDatabaseName\nError: Call to protected method norsk\\api\\app\\config\\DbConfig::database() from scope norsk\\api\\app\\config\\DbConfigTest\n\n\/app\/api\/tests\/unit\/app\/config\/DbConfigTest.php:75\n\nERRORS!\nTests: 13, Assertions: 34, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    protected function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/DbConfig.php","originalStartLine":113},"diff":"@@ @@\n     {\n         return $this->name;\n     }\n-    public function user(): User\n+    protected function user(): User\n     {\n         return $this->user;\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.26c9c0600a30a49f5491297a37566b3f.infection.xml\n\n...............E                                                  16 \/ 16 (100%)\n\nTime: 00:00.006, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\config\\DbConfigTest::testCanReadDbUser\nError: Call to protected method norsk\\api\\app\\config\\DbConfig::user() from scope norsk\\api\\app\\config\\DbConfigTest\n\n\/app\/api\/tests\/unit\/app\/config\/DbConfigTest.php:93\n\nERRORS!\nTests: 16, Assertions: 37, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    protected function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/DbConfig.php","originalStartLine":119},"diff":"@@ @@\n     {\n         return $this->user;\n     }\n-    public function password(): Password\n+    protected function password(): Password\n     {\n         return $this->password;\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.a8a629cbf2decff149e92f52e7a73eba.infection.xml\n\n.............E\n\nTime: 00:00.007, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\config\\DbConfigTest::testCanReadDbPassword\nError: Call to protected method norsk\\api\\app\\config\\DbConfig::password() from scope norsk\\api\\app\\config\\DbConfigTest\n\n\/app\/api\/tests\/unit\/app\/config\/DbConfigTest.php:81\n\nERRORS!\nTests: 14, Assertions: 35, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    public function port(): Port\n    {\n        return $this->port;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse norsk\\api\\app\\config\\exceptions\\KeyHasEmptyValueException;\nuse norsk\\api\\app\\config\\exceptions\\KeyIsNotSetException;\nuse norsk\\api\\app\\persistence\\DatabaseName;\nuse norsk\\api\\app\\persistence\\Host;\nuse norsk\\api\\app\\persistence\\Password;\nuse norsk\\api\\app\\persistence\\Port;\nuse norsk\\api\\app\\persistence\\User;\nuse norsk\\api\\app\\response\\ResponseCode;\nclass DbConfig\n{\n    private const string DATABASE = 'database';\n    private const string DB_SERVER = 'db_server';\n    private const string DB_NAME = 'db_name';\n    private const string DB_USER = 'db_user';\n    private const string DB_PASSWORD = 'db_password';\n    private const string DB_PORT = 'db_port';\n    private function __construct(private readonly Host $host, private readonly DatabaseName $name, private readonly User $user, private readonly Password $password, private readonly Port $port)\n    {\n    }\n    public static function fromPath(Path $configPath): self\n    {\n        $file = File::fromPath($configPath);\n        $configItems = $file->parseIniFile()->asArray();\n        self::ensureConfigIsValid($configItems);\n        return new self(Host::fromString($configItems[self::DATABASE][self::DB_SERVER]), DatabaseName::fromString($configItems[self::DATABASE][self::DB_NAME]), User::fromString($configItems[self::DATABASE][self::DB_USER]), Password::fromString($configItems[self::DATABASE][self::DB_PASSWORD]), Port::fromInt($configItems[self::DATABASE][self::DB_PORT]));\n    }\n    \/**\n     * @param array<array<string>> $configItems\n     *\/\n    private static function ensureConfigIsValid(array $configItems): void\n    {\n        self::ensureKeysExist($configItems);\n        self::ensureKeysHaveValues($configItems);\n    }\n    private static function ensureKeysExist(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if (!array_key_exists($neededKey, $configItems[self::DATABASE])) {\n                throw new KeyIsNotSetException($neededKey . ' is not set.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getKeys(): array\n    {\n        return [self::DB_SERVER, self::DB_NAME, self::DB_USER, self::DB_PASSWORD, self::DB_PORT];\n    }\n    private static function ensureKeysHaveValues(array $configItems): void\n    {\n        $neededKeys = self::getKeys();\n        foreach ($neededKeys as $neededKey) {\n            if ($configItems[self::DATABASE][$neededKey] === '') {\n                throw new KeyHasEmptyValueException($neededKey . ' is empty.', ResponseCode::unprocessable->value);\n            }\n        }\n    }\n    public function host(): Host\n    {\n        return $this->host;\n    }\n    public function database(): DatabaseName\n    {\n        return $this->name;\n    }\n    public function user(): User\n    {\n        return $this->user;\n    }\n    public function password(): Password\n    {\n        return $this->password;\n    }\n    protected function port(): Port\n    {\n        return $this->port;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/DbConfig.php","originalStartLine":125},"diff":"@@ @@\n     {\n         return $this->password;\n     }\n-    public function port(): Port\n+    protected function port(): Port\n     {\n         return $this->port;\n     }\n }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.7a5ea33ad9aa2a89e60255dbe12a2791.infection.xml\n\n..............E\n\nTime: 00:00.007, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\config\\DbConfigTest::testCanReadPort\nError: Call to protected method norsk\\api\\app\\config\\DbConfig::port() from scope norsk\\api\\app\\config\\DbConfigTest\n\n\/app\/api\/tests\/unit\/app\/config\/DbConfigTest.php:87\n\nERRORS!\nTests: 15, Assertions: 36, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse RuntimeException;\nclass File\n{\n    private function __construct(private readonly Path $path)\n    {\n    }\n    public static function fromPath(Path $path): self\n    {\n        return new self($path);\n    }\n    public function parseIniFile(): IniItems\n    {\n        $this->isReadable();\n        $content = parse_ini_file($this->getPath()->asString(), true, INI_SCANNER_TYPED);\n        return IniItems::fromAssocArray($content);\n    }\n    private function isReadable(): void\n    {\n        if (!is_readable($this->path->asString())) {\n            throw new RuntimeException(\"Cannot read file: {$this->path->asString()}\");\n        }\n    }\n    public function getPath(): Path\n    {\n        return $this->path;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse RuntimeException;\nclass File\n{\n    private function __construct(private readonly Path $path)\n    {\n    }\n    protected static function fromPath(Path $path): self\n    {\n        return new self($path);\n    }\n    public function parseIniFile(): IniItems\n    {\n        $this->isReadable();\n        $content = parse_ini_file($this->getPath()->asString(), true, INI_SCANNER_TYPED);\n        return IniItems::fromAssocArray($content);\n    }\n    private function isReadable(): void\n    {\n        if (!is_readable($this->path->asString())) {\n            throw new RuntimeException(\"Cannot read file: {$this->path->asString()}\");\n        }\n    }\n    public function getPath(): Path\n    {\n        return $this->path;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/File.php","originalStartLine":16},"diff":"@@ @@\n     private function __construct(private readonly Path $path)\n     {\n     }\n-    public static function fromPath(Path $path): self\n+    protected static function fromPath(Path $path): self\n     {\n         return new self($path);\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.48cd2829bba30c147a38c00bf3d5fc1a.infection.xml\n\nE\n\nTime: 00:00.001, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\config\\FileTest::testCanGetPath\nError: Call to protected method norsk\\api\\app\\config\\File::fromPath() from scope norsk\\api\\app\\config\\FileTest\n\n\/app\/api\/tests\/unit\/app\/config\/FileTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse RuntimeException;\nclass File\n{\n    private function __construct(private readonly Path $path)\n    {\n    }\n    public static function fromPath(Path $path): self\n    {\n        return new self($path);\n    }\n    public function parseIniFile(): IniItems\n    {\n        $this->isReadable();\n        $content = parse_ini_file($this->getPath()->asString(), true, INI_SCANNER_TYPED);\n        return IniItems::fromAssocArray($content);\n    }\n    private function isReadable(): void\n    {\n        if (!is_readable($this->path->asString())) {\n            throw new RuntimeException(\"Cannot read file: {$this->path->asString()}\");\n        }\n    }\n    public function getPath(): Path\n    {\n        return $this->path;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse RuntimeException;\nclass File\n{\n    private function __construct(private readonly Path $path)\n    {\n    }\n    public static function fromPath(Path $path): self\n    {\n        return new self($path);\n    }\n    protected function parseIniFile(): IniItems\n    {\n        $this->isReadable();\n        $content = parse_ini_file($this->getPath()->asString(), true, INI_SCANNER_TYPED);\n        return IniItems::fromAssocArray($content);\n    }\n    private function isReadable(): void\n    {\n        if (!is_readable($this->path->asString())) {\n            throw new RuntimeException(\"Cannot read file: {$this->path->asString()}\");\n        }\n    }\n    public function getPath(): Path\n    {\n        return $this->path;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/File.php","originalStartLine":22},"diff":"@@ @@\n     {\n         return new self($path);\n     }\n-    public function parseIniFile(): IniItems\n+    protected function parseIniFile(): IniItems\n     {\n         $this->isReadable();\n         $content = parse_ini_file($this->getPath()->asString(), true, INI_SCANNER_TYPED);","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.112d853cf88f2ae2a8dc7df2d0acc43e.infection.xml\n\n.E\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\config\\FileTest::testCanParseIniFile\nError: Call to protected method norsk\\api\\app\\config\\File::parseIniFile() from scope norsk\\api\\app\\config\\FileTest\n\n\/app\/api\/tests\/unit\/app\/config\/FileTest.php:27\n\nERRORS!\nTests: 2, Assertions: 1, Errors: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse RuntimeException;\nclass File\n{\n    private function __construct(private readonly Path $path)\n    {\n    }\n    public static function fromPath(Path $path): self\n    {\n        return new self($path);\n    }\n    public function parseIniFile(): IniItems\n    {\n        $this->isReadable();\n        $content = parse_ini_file($this->getPath()->asString(), true, INI_SCANNER_TYPED);\n        return IniItems::fromAssocArray($content);\n    }\n    private function isReadable(): void\n    {\n        if (!is_readable($this->path->asString())) {\n            throw new RuntimeException(\"Cannot read file: {$this->path->asString()}\");\n        }\n    }\n    public function getPath(): Path\n    {\n        return $this->path;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse RuntimeException;\nclass File\n{\n    private function __construct(private readonly Path $path)\n    {\n    }\n    public static function fromPath(Path $path): self\n    {\n        return new self($path);\n    }\n    public function parseIniFile(): IniItems\n    {\n        \n        $content = parse_ini_file($this->getPath()->asString(), true, INI_SCANNER_TYPED);\n        return IniItems::fromAssocArray($content);\n    }\n    private function isReadable(): void\n    {\n        if (!is_readable($this->path->asString())) {\n            throw new RuntimeException(\"Cannot read file: {$this->path->asString()}\");\n        }\n    }\n    public function getPath(): Path\n    {\n        return $this->path;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/File.php","originalStartLine":24},"diff":"@@ @@\n     }\n     public function parseIniFile(): IniItems\n     {\n-        $this->isReadable();\n+        \n         $content = parse_ini_file($this->getPath()->asString(), true, INI_SCANNER_TYPED);\n         return IniItems::fromAssocArray($content);\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.531af40e48ca8a1cbfab71cb222d8ec8.infection.xml\n\n..F                                                                 3 \/ 3 (100%)\n\nTime: 00:00.003, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\FileTest::testThrowsExceptionIfFileIsNotReadable\nFailed asserting that exception of type \"TypeError\" matches expected exception \"RuntimeException\". Message was: \"norsk\\api\\app\\config\\IniItems::fromAssocArray(): Argument #1 ($items) must be of type array, false given, called in \/app\/api\/src\/app\/config\/File.php on line 20\" at\n\/app\/api\/src\/app\/config\/IniItems.php:18\n\/app\/api\/src\/app\/config\/File.php:20\n\/app\/api\/tests\/unit\/app\/config\/FileTest.php:37\n.\n\nFAILURES!\nTests: 3, Assertions: 3, Failures: 1, Warnings: 1."},{"mutator":{"mutatorName":"LogicalNot","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse RuntimeException;\nclass File\n{\n    private function __construct(private readonly Path $path)\n    {\n    }\n    public static function fromPath(Path $path): self\n    {\n        return new self($path);\n    }\n    public function parseIniFile(): IniItems\n    {\n        $this->isReadable();\n        $content = parse_ini_file($this->getPath()->asString(), true, INI_SCANNER_TYPED);\n        return IniItems::fromAssocArray($content);\n    }\n    private function isReadable(): void\n    {\n        if (!is_readable($this->path->asString())) {\n            throw new RuntimeException(\"Cannot read file: {$this->path->asString()}\");\n        }\n    }\n    public function getPath(): Path\n    {\n        return $this->path;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse RuntimeException;\nclass File\n{\n    private function __construct(private readonly Path $path)\n    {\n    }\n    public static function fromPath(Path $path): self\n    {\n        return new self($path);\n    }\n    public function parseIniFile(): IniItems\n    {\n        $this->isReadable();\n        $content = parse_ini_file($this->getPath()->asString(), true, INI_SCANNER_TYPED);\n        return IniItems::fromAssocArray($content);\n    }\n    private function isReadable(): void\n    {\n        if (is_readable($this->path->asString())) {\n            throw new RuntimeException(\"Cannot read file: {$this->path->asString()}\");\n        }\n    }\n    public function getPath(): Path\n    {\n        return $this->path;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/File.php","originalStartLine":33},"diff":"@@ @@\n     }\n     private function isReadable(): void\n     {\n-        if (!is_readable($this->path->asString())) {\n+        if (is_readable($this->path->asString())) {\n             throw new RuntimeException(\"Cannot read file: {$this->path->asString()}\");\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.3a051d5d81f1987f6c27f026a9691434.infection.xml\n\n.E\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\config\\FileTest::testCanParseIniFile\nRuntimeException: Cannot read file: \/app\/api\/tests\/unit\/app\/config\/..\/resources\/mySqlConfig.test.ini\n\n\/app\/api\/src\/app\/config\/File.php:25\n\/app\/api\/src\/app\/config\/File.php:18\n\/app\/api\/tests\/unit\/app\/config\/FileTest.php:27\n\nERRORS!\nTests: 2, Assertions: 1, Errors: 1."},{"mutator":{"mutatorName":"Throw_","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse RuntimeException;\nclass File\n{\n    private function __construct(private readonly Path $path)\n    {\n    }\n    public static function fromPath(Path $path): self\n    {\n        return new self($path);\n    }\n    public function parseIniFile(): IniItems\n    {\n        $this->isReadable();\n        $content = parse_ini_file($this->getPath()->asString(), true, INI_SCANNER_TYPED);\n        return IniItems::fromAssocArray($content);\n    }\n    private function isReadable(): void\n    {\n        if (!is_readable($this->path->asString())) {\n            throw new RuntimeException(\"Cannot read file: {$this->path->asString()}\");\n        }\n    }\n    public function getPath(): Path\n    {\n        return $this->path;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse RuntimeException;\nclass File\n{\n    private function __construct(private readonly Path $path)\n    {\n    }\n    public static function fromPath(Path $path): self\n    {\n        return new self($path);\n    }\n    public function parseIniFile(): IniItems\n    {\n        $this->isReadable();\n        $content = parse_ini_file($this->getPath()->asString(), true, INI_SCANNER_TYPED);\n        return IniItems::fromAssocArray($content);\n    }\n    private function isReadable(): void\n    {\n        if (!is_readable($this->path->asString())) {\n            new RuntimeException(\"Cannot read file: {$this->path->asString()}\");\n        }\n    }\n    public function getPath(): Path\n    {\n        return $this->path;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/File.php","originalStartLine":34},"diff":"@@ @@\n     private function isReadable(): void\n     {\n         if (!is_readable($this->path->asString())) {\n-            throw new RuntimeException(\"Cannot read file: {$this->path->asString()}\");\n+            new RuntimeException(\"Cannot read file: {$this->path->asString()}\");\n         }\n     }\n     public function getPath(): Path","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.a6530d74246a73bce6e39c77567a1e2e.infection.xml\n\n..F                                                                 3 \/ 3 (100%)\n\nTime: 00:00.003, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\config\\FileTest::testThrowsExceptionIfFileIsNotReadable\nFailed asserting that exception of type \"TypeError\" matches expected exception \"RuntimeException\". Message was: \"norsk\\api\\app\\config\\IniItems::fromAssocArray(): Argument #1 ($items) must be of type array, false given, called in \/app\/api\/src\/app\/config\/File.php on line 20\" at\n\/app\/api\/src\/app\/config\/IniItems.php:18\n\/app\/api\/src\/app\/config\/File.php:20\n\/app\/api\/tests\/unit\/app\/config\/FileTest.php:37\n.\n\nFAILURES!\nTests: 3, Assertions: 3, Failures: 1, Warnings: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse RuntimeException;\nclass File\n{\n    private function __construct(private readonly Path $path)\n    {\n    }\n    public static function fromPath(Path $path): self\n    {\n        return new self($path);\n    }\n    public function parseIniFile(): IniItems\n    {\n        $this->isReadable();\n        $content = parse_ini_file($this->getPath()->asString(), true, INI_SCANNER_TYPED);\n        return IniItems::fromAssocArray($content);\n    }\n    private function isReadable(): void\n    {\n        if (!is_readable($this->path->asString())) {\n            throw new RuntimeException(\"Cannot read file: {$this->path->asString()}\");\n        }\n    }\n    public function getPath(): Path\n    {\n        return $this->path;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse RuntimeException;\nclass File\n{\n    private function __construct(private readonly Path $path)\n    {\n    }\n    public static function fromPath(Path $path): self\n    {\n        return new self($path);\n    }\n    public function parseIniFile(): IniItems\n    {\n        $this->isReadable();\n        $content = parse_ini_file($this->getPath()->asString(), true, INI_SCANNER_TYPED);\n        return IniItems::fromAssocArray($content);\n    }\n    private function isReadable(): void\n    {\n        if (!is_readable($this->path->asString())) {\n            throw new RuntimeException(\"Cannot read file: {$this->path->asString()}\");\n        }\n    }\n    protected function getPath(): Path\n    {\n        return $this->path;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/File.php","originalStartLine":39},"diff":"@@ @@\n             throw new RuntimeException(\"Cannot read file: {$this->path->asString()}\");\n         }\n     }\n-    public function getPath(): Path\n+    protected function getPath(): Path\n     {\n         return $this->path;\n     }\n }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.7d90302ead3b07f0543eb109cc7f5b8c.infection.xml\n\nE\n\nTime: 00:00.001, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\config\\FileTest::testCanGetPath\nError: Call to protected method norsk\\api\\app\\config\\File::getPath() from scope norsk\\api\\app\\config\\FileTest\n\n\/app\/api\/tests\/unit\/app\/config\/FileTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse ArrayIterator;\nuse IteratorAggregate;\nclass IniItems implements IteratorAggregate\n{\n    private function __construct(private readonly array $items)\n    {\n    }\n    public static function fromAssocArray(array $items): self\n    {\n        return new self($items);\n    }\n    public function asArray(): array\n    {\n        return $this->items;\n    }\n    public function getIterator(): ArrayIterator\n    {\n        return new ArrayIterator($this->items);\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse ArrayIterator;\nuse IteratorAggregate;\nclass IniItems implements IteratorAggregate\n{\n    private function __construct(private readonly array $items)\n    {\n    }\n    protected static function fromAssocArray(array $items): self\n    {\n        return new self($items);\n    }\n    public function asArray(): array\n    {\n        return $this->items;\n    }\n    public function getIterator(): ArrayIterator\n    {\n        return new ArrayIterator($this->items);\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/IniItems.php","originalStartLine":18},"diff":"@@ @@\n     private function __construct(private readonly array $items)\n     {\n     }\n-    public static function fromAssocArray(array $items): self\n+    protected static function fromAssocArray(array $items): self\n     {\n         return new self($items);\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.9df698f945faf8425ed917a728449a53.infection.xml\n\nE\n\nTime: 00:00.001, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\config\\IniItemsTest::testCanBeUsedAsArray\nError: Call to protected method norsk\\api\\app\\config\\IniItems::fromAssocArray() from scope norsk\\api\\app\\config\\IniItemsTest\n\n\/app\/api\/tests\/unit\/app\/config\/IniItemsTest.php:20\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse ArrayIterator;\nuse IteratorAggregate;\nclass IniItems implements IteratorAggregate\n{\n    private function __construct(private readonly array $items)\n    {\n    }\n    public static function fromAssocArray(array $items): self\n    {\n        return new self($items);\n    }\n    public function asArray(): array\n    {\n        return $this->items;\n    }\n    public function getIterator(): ArrayIterator\n    {\n        return new ArrayIterator($this->items);\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nuse ArrayIterator;\nuse IteratorAggregate;\nclass IniItems implements IteratorAggregate\n{\n    private function __construct(private readonly array $items)\n    {\n    }\n    public static function fromAssocArray(array $items): self\n    {\n        return new self($items);\n    }\n    protected function asArray(): array\n    {\n        return $this->items;\n    }\n    public function getIterator(): ArrayIterator\n    {\n        return new ArrayIterator($this->items);\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/IniItems.php","originalStartLine":24},"diff":"@@ @@\n     {\n         return new self($items);\n     }\n-    public function asArray(): array\n+    protected function asArray(): array\n     {\n         return $this->items;\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.2e9ab85fa2e5f7e336273224301589c9.infection.xml\n\nE\n\nTime: 00:00.001, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\config\\IniItemsTest::testCanBeUsedAsArray\nError: Call to protected method norsk\\api\\app\\config\\IniItems::asArray() from scope norsk\\api\\app\\config\\IniItemsTest\n\n\/app\/api\/tests\/unit\/app\/config\/IniItemsTest.php:20\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nclass Path\n{\n    private function __construct(private readonly string $path)\n    {\n    }\n    public static function fromString(string $path): self\n    {\n        return new self($path);\n    }\n    public function asString(): string\n    {\n        return $this->path;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nclass Path\n{\n    private function __construct(private readonly string $path)\n    {\n    }\n    protected static function fromString(string $path): self\n    {\n        return new self($path);\n    }\n    public function asString(): string\n    {\n        return $this->path;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/Path.php","originalStartLine":14},"diff":"@@ @@\n     private function __construct(private readonly string $path)\n     {\n     }\n-    public static function fromString(string $path): self\n+    protected static function fromString(string $path): self\n     {\n         return new self($path);\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.53fe149414eba2896ebed2fc6ceb254b.infection.xml\n\nE                                                                   1 \/ 1 (100%)\n\nTime: 00:00.001, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\config\\PathTest::testCanBeUsedAsString\nError: Call to protected method norsk\\api\\app\\config\\Path::fromString() from scope norsk\\api\\app\\config\\PathTest\n\n\/app\/api\/tests\/unit\/app\/config\/PathTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nclass Path\n{\n    private function __construct(private readonly string $path)\n    {\n    }\n    public static function fromString(string $path): self\n    {\n        return new self($path);\n    }\n    public function asString(): string\n    {\n        return $this->path;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\config;\n\nclass Path\n{\n    private function __construct(private readonly string $path)\n    {\n    }\n    public static function fromString(string $path): self\n    {\n        return new self($path);\n    }\n    protected function asString(): string\n    {\n        return $this->path;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/config\/Path.php","originalStartLine":20},"diff":"@@ @@\n     {\n         return new self($path);\n     }\n-    public function asString(): string\n+    protected function asString(): string\n     {\n         return $this->path;\n     }\n }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.eb9a4c516285e40d180c02e8565c4aa3.infection.xml\n\nE                                                                   1 \/ 1 (100%)\n\nTime: 00:00.001, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\config\\PathTest::testCanBeUsedAsString\nError: Call to protected method norsk\\api\\app\\config\\Path::asString() from scope norsk\\api\\app\\config\\PathTest\n\n\/app\/api\/tests\/unit\/app\/config\/PathTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"IfNegation","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse norsk\\api\\app\\response\\UnauthorizedResponse;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\shared\\responses\\ErrorResponse;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface as RequestHandler;\nuse Throwable;\nclass Authentication implements MiddlewareInterface\n{\n    private const string AUTHORIZATION = 'Authorization';\n    public function __construct(private readonly JwtManagement $jwtManagement, private readonly Session $session, private readonly Url $url)\n    {\n    }\n    public function process(Request $request, RequestHandler $handler): ResponseInterface\n    {\n        try {\n            if ($this->AuthorizationHeaderDoesNotExist($request)) {\n                return UnauthorizedResponse::noHeader($this->url);\n            }\n            $this->jwtManagement->validate($request, $this->session);\n        } catch (Throwable $throwable) {\n            return ErrorResponse::unauthorized($this->url, $throwable);\n        }\n        return $handler->handle($request);\n    }\n    private function AuthorizationHeaderDoesNotExist(Request $request): bool\n    {\n        return count($request->getHeader(self::AUTHORIZATION)) < 1;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse norsk\\api\\app\\response\\UnauthorizedResponse;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\shared\\responses\\ErrorResponse;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface as RequestHandler;\nuse Throwable;\nclass Authentication implements MiddlewareInterface\n{\n    private const string AUTHORIZATION = 'Authorization';\n    public function __construct(private readonly JwtManagement $jwtManagement, private readonly Session $session, private readonly Url $url)\n    {\n    }\n    public function process(Request $request, RequestHandler $handler): ResponseInterface\n    {\n        try {\n            if (!$this->AuthorizationHeaderDoesNotExist($request)) {\n                return UnauthorizedResponse::noHeader($this->url);\n            }\n            $this->jwtManagement->validate($request, $this->session);\n        } catch (Throwable $throwable) {\n            return ErrorResponse::unauthorized($this->url, $throwable);\n        }\n        return $handler->handle($request);\n    }\n    private function AuthorizationHeaderDoesNotExist(Request $request): bool\n    {\n        return count($request->getHeader(self::AUTHORIZATION)) < 1;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/Authentication.php","originalStartLine":32},"diff":"@@ @@\n     public function process(Request $request, RequestHandler $handler): ResponseInterface\n     {\n         try {\n-            if ($this->AuthorizationHeaderDoesNotExist($request)) {\n+            if (!$this->AuthorizationHeaderDoesNotExist($request)) {\n                 return UnauthorizedResponse::noHeader($this->url);\n             }\n             $this->jwtManagement->validate($request, $this->session);","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.0787b7b3ce1260a296025db1fbd8e3ce.infection.xml\n\nF\n\nTime: 00:00.005, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\AuthenticationTest::testCanProcessAValidRequest\nExpectation failed for method name is \"handle\" when invoked 1 time.\nMethod was expected to be called 1 time, actually called 0 times.\n\nFAILURES!\nTests: 1, Assertions: 1, Failures: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse norsk\\api\\app\\response\\UnauthorizedResponse;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\shared\\responses\\ErrorResponse;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface as RequestHandler;\nuse Throwable;\nclass Authentication implements MiddlewareInterface\n{\n    private const string AUTHORIZATION = 'Authorization';\n    public function __construct(private readonly JwtManagement $jwtManagement, private readonly Session $session, private readonly Url $url)\n    {\n    }\n    public function process(Request $request, RequestHandler $handler): ResponseInterface\n    {\n        try {\n            if ($this->AuthorizationHeaderDoesNotExist($request)) {\n                return UnauthorizedResponse::noHeader($this->url);\n            }\n            $this->jwtManagement->validate($request, $this->session);\n        } catch (Throwable $throwable) {\n            return ErrorResponse::unauthorized($this->url, $throwable);\n        }\n        return $handler->handle($request);\n    }\n    private function AuthorizationHeaderDoesNotExist(Request $request): bool\n    {\n        return count($request->getHeader(self::AUTHORIZATION)) < 1;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse norsk\\api\\app\\response\\UnauthorizedResponse;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\shared\\responses\\ErrorResponse;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface as RequestHandler;\nuse Throwable;\nclass Authentication implements MiddlewareInterface\n{\n    private const string AUTHORIZATION = 'Authorization';\n    public function __construct(private readonly JwtManagement $jwtManagement, private readonly Session $session, private readonly Url $url)\n    {\n    }\n    public function process(Request $request, RequestHandler $handler): ResponseInterface\n    {\n        try {\n            if ($this->AuthorizationHeaderDoesNotExist($request)) {\n                return UnauthorizedResponse::noHeader($this->url);\n            }\n            \n        } catch (Throwable $throwable) {\n            return ErrorResponse::unauthorized($this->url, $throwable);\n        }\n        return $handler->handle($request);\n    }\n    private function AuthorizationHeaderDoesNotExist(Request $request): bool\n    {\n        return count($request->getHeader(self::AUTHORIZATION)) < 1;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/Authentication.php","originalStartLine":36},"diff":"@@ @@\n             if ($this->AuthorizationHeaderDoesNotExist($request)) {\n                 return UnauthorizedResponse::noHeader($this->url);\n             }\n-            $this->jwtManagement->validate($request, $this->session);\n+            \n         } catch (Throwable $throwable) {\n             return ErrorResponse::unauthorized($this->url, $throwable);\n         }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.7a56b66420af9811407a78de73ecb208.infection.xml\n\nF\n\nTime: 00:00.005, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\AuthenticationTest::testCanProcessAValidRequest\nExpectation failed for method name is \"validate\" when invoked 1 time.\nMethod was expected to be called 1 time, actually called 0 times.\n\nFAILURES!\nTests: 1, Assertions: 2, Failures: 1."},{"mutator":{"mutatorName":"LessThan","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse norsk\\api\\app\\response\\UnauthorizedResponse;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\shared\\responses\\ErrorResponse;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface as RequestHandler;\nuse Throwable;\nclass Authentication implements MiddlewareInterface\n{\n    private const string AUTHORIZATION = 'Authorization';\n    public function __construct(private readonly JwtManagement $jwtManagement, private readonly Session $session, private readonly Url $url)\n    {\n    }\n    public function process(Request $request, RequestHandler $handler): ResponseInterface\n    {\n        try {\n            if ($this->AuthorizationHeaderDoesNotExist($request)) {\n                return UnauthorizedResponse::noHeader($this->url);\n            }\n            $this->jwtManagement->validate($request, $this->session);\n        } catch (Throwable $throwable) {\n            return ErrorResponse::unauthorized($this->url, $throwable);\n        }\n        return $handler->handle($request);\n    }\n    private function AuthorizationHeaderDoesNotExist(Request $request): bool\n    {\n        return count($request->getHeader(self::AUTHORIZATION)) < 1;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse norsk\\api\\app\\response\\UnauthorizedResponse;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\shared\\responses\\ErrorResponse;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface as RequestHandler;\nuse Throwable;\nclass Authentication implements MiddlewareInterface\n{\n    private const string AUTHORIZATION = 'Authorization';\n    public function __construct(private readonly JwtManagement $jwtManagement, private readonly Session $session, private readonly Url $url)\n    {\n    }\n    public function process(Request $request, RequestHandler $handler): ResponseInterface\n    {\n        try {\n            if ($this->AuthorizationHeaderDoesNotExist($request)) {\n                return UnauthorizedResponse::noHeader($this->url);\n            }\n            $this->jwtManagement->validate($request, $this->session);\n        } catch (Throwable $throwable) {\n            return ErrorResponse::unauthorized($this->url, $throwable);\n        }\n        return $handler->handle($request);\n    }\n    private function AuthorizationHeaderDoesNotExist(Request $request): bool\n    {\n        return count($request->getHeader(self::AUTHORIZATION)) <= 1;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/Authentication.php","originalStartLine":47},"diff":"@@ @@\n     }\n     private function AuthorizationHeaderDoesNotExist(Request $request): bool\n     {\n-        return count($request->getHeader(self::AUTHORIZATION)) < 1;\n+        return count($request->getHeader(self::AUTHORIZATION)) <= 1;\n     }\n }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.a81ffc058022a24c3d5faaa586a0c5f0.infection.xml\n\nF\n\nTime: 00:00.005, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\AuthenticationTest::testCanProcessAValidRequest\nExpectation failed for method name is \"handle\" when invoked 1 time.\nMethod was expected to be called 1 time, actually called 0 times.\n\nFAILURES!\nTests: 1, Assertions: 1, Failures: 1."},{"mutator":{"mutatorName":"LessThanNegotiation","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse norsk\\api\\app\\response\\UnauthorizedResponse;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\shared\\responses\\ErrorResponse;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface as RequestHandler;\nuse Throwable;\nclass Authentication implements MiddlewareInterface\n{\n    private const string AUTHORIZATION = 'Authorization';\n    public function __construct(private readonly JwtManagement $jwtManagement, private readonly Session $session, private readonly Url $url)\n    {\n    }\n    public function process(Request $request, RequestHandler $handler): ResponseInterface\n    {\n        try {\n            if ($this->AuthorizationHeaderDoesNotExist($request)) {\n                return UnauthorizedResponse::noHeader($this->url);\n            }\n            $this->jwtManagement->validate($request, $this->session);\n        } catch (Throwable $throwable) {\n            return ErrorResponse::unauthorized($this->url, $throwable);\n        }\n        return $handler->handle($request);\n    }\n    private function AuthorizationHeaderDoesNotExist(Request $request): bool\n    {\n        return count($request->getHeader(self::AUTHORIZATION)) < 1;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse norsk\\api\\app\\response\\UnauthorizedResponse;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\shared\\responses\\ErrorResponse;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface as RequestHandler;\nuse Throwable;\nclass Authentication implements MiddlewareInterface\n{\n    private const string AUTHORIZATION = 'Authorization';\n    public function __construct(private readonly JwtManagement $jwtManagement, private readonly Session $session, private readonly Url $url)\n    {\n    }\n    public function process(Request $request, RequestHandler $handler): ResponseInterface\n    {\n        try {\n            if ($this->AuthorizationHeaderDoesNotExist($request)) {\n                return UnauthorizedResponse::noHeader($this->url);\n            }\n            $this->jwtManagement->validate($request, $this->session);\n        } catch (Throwable $throwable) {\n            return ErrorResponse::unauthorized($this->url, $throwable);\n        }\n        return $handler->handle($request);\n    }\n    private function AuthorizationHeaderDoesNotExist(Request $request): bool\n    {\n        return count($request->getHeader(self::AUTHORIZATION)) >= 1;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/Authentication.php","originalStartLine":47},"diff":"@@ @@\n     }\n     private function AuthorizationHeaderDoesNotExist(Request $request): bool\n     {\n-        return count($request->getHeader(self::AUTHORIZATION)) < 1;\n+        return count($request->getHeader(self::AUTHORIZATION)) >= 1;\n     }\n }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.3cc45363a1d278346ad0d7f8173e91f8.infection.xml\n\nF\n\nTime: 00:00.005, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\AuthenticationTest::testCanProcessAValidRequest\nExpectation failed for method name is \"handle\" when invoked 1 time.\nMethod was expected to be called 1 time, actually called 0 times.\n\nFAILURES!\nTests: 1, Assertions: 1, Failures: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nclass AuthenticationAlgorithm\n{\n    private function __construct(private readonly string $algorithm)\n    {\n    }\n    public static function by(string $algorithm): self\n    {\n        self::ensureAlgorithmIsJwtValid($algorithm);\n        return new self($algorithm);\n    }\n    private static function ensureAlgorithmIsJwtValid(string $algorithm): void\n    {\n        $algorithmList = self::getAlgorithmList();\n        if (!in_array($algorithm, $algorithmList)) {\n            throw new InvalidArgumentException('Algorithm has no valid format');\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getAlgorithmList(): array\n    {\n        return ['HS256', 'HS384', 'HS512', 'PS256', 'PS384', 'PS512', 'RS256', 'RS384', 'RS512', 'ES256', 'ES256K', 'ES384', 'ES512', 'EdDSA'];\n    }\n    public function asString(): string\n    {\n        return $this->algorithm;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nclass AuthenticationAlgorithm\n{\n    private function __construct(private readonly string $algorithm)\n    {\n    }\n    protected static function by(string $algorithm): self\n    {\n        self::ensureAlgorithmIsJwtValid($algorithm);\n        return new self($algorithm);\n    }\n    private static function ensureAlgorithmIsJwtValid(string $algorithm): void\n    {\n        $algorithmList = self::getAlgorithmList();\n        if (!in_array($algorithm, $algorithmList)) {\n            throw new InvalidArgumentException('Algorithm has no valid format');\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getAlgorithmList(): array\n    {\n        return ['HS256', 'HS384', 'HS512', 'PS256', 'PS384', 'PS512', 'RS256', 'RS384', 'RS512', 'ES256', 'ES256K', 'ES384', 'ES512', 'EdDSA'];\n    }\n    public function asString(): string\n    {\n        return $this->algorithm;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/AuthenticationAlgorithm.php","originalStartLine":16},"diff":"@@ @@\n     private function __construct(private readonly string $algorithm)\n     {\n     }\n-    public static function by(string $algorithm): self\n+    protected static function by(string $algorithm): self\n     {\n         self::ensureAlgorithmIsJwtValid($algorithm);\n         return new self($algorithm);","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.449697ad095d22e4f0c8d84b3a357057.infection.xml\n\nE\n\nTime: 00:00.001, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithmTest::testCanBeUsedAsString\nError: Call to protected method norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm::by() from scope norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithmTest\n\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/AuthenticationAlgorithmTest.php:16\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nclass AuthenticationAlgorithm\n{\n    private function __construct(private readonly string $algorithm)\n    {\n    }\n    public static function by(string $algorithm): self\n    {\n        self::ensureAlgorithmIsJwtValid($algorithm);\n        return new self($algorithm);\n    }\n    private static function ensureAlgorithmIsJwtValid(string $algorithm): void\n    {\n        $algorithmList = self::getAlgorithmList();\n        if (!in_array($algorithm, $algorithmList)) {\n            throw new InvalidArgumentException('Algorithm has no valid format');\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getAlgorithmList(): array\n    {\n        return ['HS256', 'HS384', 'HS512', 'PS256', 'PS384', 'PS512', 'RS256', 'RS384', 'RS512', 'ES256', 'ES256K', 'ES384', 'ES512', 'EdDSA'];\n    }\n    public function asString(): string\n    {\n        return $this->algorithm;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nclass AuthenticationAlgorithm\n{\n    private function __construct(private readonly string $algorithm)\n    {\n    }\n    public static function by(string $algorithm): self\n    {\n        \n        return new self($algorithm);\n    }\n    private static function ensureAlgorithmIsJwtValid(string $algorithm): void\n    {\n        $algorithmList = self::getAlgorithmList();\n        if (!in_array($algorithm, $algorithmList)) {\n            throw new InvalidArgumentException('Algorithm has no valid format');\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getAlgorithmList(): array\n    {\n        return ['HS256', 'HS384', 'HS512', 'PS256', 'PS384', 'PS512', 'RS256', 'RS384', 'RS512', 'ES256', 'ES256K', 'ES384', 'ES512', 'EdDSA'];\n    }\n    public function asString(): string\n    {\n        return $this->algorithm;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/AuthenticationAlgorithm.php","originalStartLine":18},"diff":"@@ @@\n     }\n     public static function by(string $algorithm): self\n     {\n-        self::ensureAlgorithmIsJwtValid($algorithm);\n+        \n         return new self($algorithm);\n     }\n     private static function ensureAlgorithmIsJwtValid(string $algorithm): void","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.fa5343a84e393b5bee192e6e2294fa5d.infection.xml\n\n.F                                                                  2 \/ 2 (100%)\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithmTest::testThrowsExceptionIfAlgorithmIsUnknown\nFailed asserting that exception of type \"InvalidArgumentException\" is thrown.\n\nFAILURES!\nTests: 2, Assertions: 2, Failures: 1."},{"mutator":{"mutatorName":"LogicalNot","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nclass AuthenticationAlgorithm\n{\n    private function __construct(private readonly string $algorithm)\n    {\n    }\n    public static function by(string $algorithm): self\n    {\n        self::ensureAlgorithmIsJwtValid($algorithm);\n        return new self($algorithm);\n    }\n    private static function ensureAlgorithmIsJwtValid(string $algorithm): void\n    {\n        $algorithmList = self::getAlgorithmList();\n        if (!in_array($algorithm, $algorithmList)) {\n            throw new InvalidArgumentException('Algorithm has no valid format');\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getAlgorithmList(): array\n    {\n        return ['HS256', 'HS384', 'HS512', 'PS256', 'PS384', 'PS512', 'RS256', 'RS384', 'RS512', 'ES256', 'ES256K', 'ES384', 'ES512', 'EdDSA'];\n    }\n    public function asString(): string\n    {\n        return $this->algorithm;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nclass AuthenticationAlgorithm\n{\n    private function __construct(private readonly string $algorithm)\n    {\n    }\n    public static function by(string $algorithm): self\n    {\n        self::ensureAlgorithmIsJwtValid($algorithm);\n        return new self($algorithm);\n    }\n    private static function ensureAlgorithmIsJwtValid(string $algorithm): void\n    {\n        $algorithmList = self::getAlgorithmList();\n        if (in_array($algorithm, $algorithmList)) {\n            throw new InvalidArgumentException('Algorithm has no valid format');\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getAlgorithmList(): array\n    {\n        return ['HS256', 'HS384', 'HS512', 'PS256', 'PS384', 'PS512', 'RS256', 'RS384', 'RS512', 'ES256', 'ES256K', 'ES384', 'ES512', 'EdDSA'];\n    }\n    public function asString(): string\n    {\n        return $this->algorithm;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/AuthenticationAlgorithm.php","originalStartLine":28},"diff":"@@ @@\n     private static function ensureAlgorithmIsJwtValid(string $algorithm): void\n     {\n         $algorithmList = self::getAlgorithmList();\n-        if (!in_array($algorithm, $algorithmList)) {\n+        if (in_array($algorithm, $algorithmList)) {\n             throw new InvalidArgumentException('Algorithm has no valid format');\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.6603003080911c3d1ad692de6e1cd3a4.infection.xml\n\nE\n\nTime: 00:00.001, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithmTest::testCanBeUsedAsString\nInvalidArgumentException: Algorithm has no valid format\n\n\/app\/api\/src\/app\/identityAccessManagement\/AuthenticationAlgorithm.php:21\n\/app\/api\/src\/app\/identityAccessManagement\/AuthenticationAlgorithm.php:14\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/AuthenticationAlgorithmTest.php:16\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Throw_","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nclass AuthenticationAlgorithm\n{\n    private function __construct(private readonly string $algorithm)\n    {\n    }\n    public static function by(string $algorithm): self\n    {\n        self::ensureAlgorithmIsJwtValid($algorithm);\n        return new self($algorithm);\n    }\n    private static function ensureAlgorithmIsJwtValid(string $algorithm): void\n    {\n        $algorithmList = self::getAlgorithmList();\n        if (!in_array($algorithm, $algorithmList)) {\n            throw new InvalidArgumentException('Algorithm has no valid format');\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getAlgorithmList(): array\n    {\n        return ['HS256', 'HS384', 'HS512', 'PS256', 'PS384', 'PS512', 'RS256', 'RS384', 'RS512', 'ES256', 'ES256K', 'ES384', 'ES512', 'EdDSA'];\n    }\n    public function asString(): string\n    {\n        return $this->algorithm;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nclass AuthenticationAlgorithm\n{\n    private function __construct(private readonly string $algorithm)\n    {\n    }\n    public static function by(string $algorithm): self\n    {\n        self::ensureAlgorithmIsJwtValid($algorithm);\n        return new self($algorithm);\n    }\n    private static function ensureAlgorithmIsJwtValid(string $algorithm): void\n    {\n        $algorithmList = self::getAlgorithmList();\n        if (!in_array($algorithm, $algorithmList)) {\n            new InvalidArgumentException('Algorithm has no valid format');\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getAlgorithmList(): array\n    {\n        return ['HS256', 'HS384', 'HS512', 'PS256', 'PS384', 'PS512', 'RS256', 'RS384', 'RS512', 'ES256', 'ES256K', 'ES384', 'ES512', 'EdDSA'];\n    }\n    public function asString(): string\n    {\n        return $this->algorithm;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/AuthenticationAlgorithm.php","originalStartLine":29},"diff":"@@ @@\n     {\n         $algorithmList = self::getAlgorithmList();\n         if (!in_array($algorithm, $algorithmList)) {\n-            throw new InvalidArgumentException('Algorithm has no valid format');\n+            new InvalidArgumentException('Algorithm has no valid format');\n         }\n     }\n     \/**","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.c9c1bddb2db5620908703d806217e4a5.infection.xml\n\n.F                                                                  2 \/ 2 (100%)\n\nTime: 00:00.001, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithmTest::testThrowsExceptionIfAlgorithmIsUnknown\nFailed asserting that exception of type \"InvalidArgumentException\" is thrown.\n\nFAILURES!\nTests: 2, Assertions: 2, Failures: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nclass AuthenticationAlgorithm\n{\n    private function __construct(private readonly string $algorithm)\n    {\n    }\n    public static function by(string $algorithm): self\n    {\n        self::ensureAlgorithmIsJwtValid($algorithm);\n        return new self($algorithm);\n    }\n    private static function ensureAlgorithmIsJwtValid(string $algorithm): void\n    {\n        $algorithmList = self::getAlgorithmList();\n        if (!in_array($algorithm, $algorithmList)) {\n            throw new InvalidArgumentException('Algorithm has no valid format');\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getAlgorithmList(): array\n    {\n        return ['HS256', 'HS384', 'HS512', 'PS256', 'PS384', 'PS512', 'RS256', 'RS384', 'RS512', 'ES256', 'ES256K', 'ES384', 'ES512', 'EdDSA'];\n    }\n    public function asString(): string\n    {\n        return $this->algorithm;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nclass AuthenticationAlgorithm\n{\n    private function __construct(private readonly string $algorithm)\n    {\n    }\n    public static function by(string $algorithm): self\n    {\n        self::ensureAlgorithmIsJwtValid($algorithm);\n        return new self($algorithm);\n    }\n    private static function ensureAlgorithmIsJwtValid(string $algorithm): void\n    {\n        $algorithmList = self::getAlgorithmList();\n        if (!in_array($algorithm, $algorithmList)) {\n            throw new InvalidArgumentException('Algorithm has no valid format');\n        }\n    }\n    \/**\n     * @return string[]\n     *\/\n    private static function getAlgorithmList(): array\n    {\n        return ['HS256', 'HS384', 'HS512', 'PS256', 'PS384', 'PS512', 'RS256', 'RS384', 'RS512', 'ES256', 'ES256K', 'ES384', 'ES512', 'EdDSA'];\n    }\n    protected function asString(): string\n    {\n        return $this->algorithm;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/AuthenticationAlgorithm.php","originalStartLine":58},"diff":"@@ @@\n     {\n         return ['HS256', 'HS384', 'HS512', 'PS256', 'PS384', 'PS512', 'RS256', 'RS384', 'RS512', 'ES256', 'ES256K', 'ES384', 'ES512', 'EdDSA'];\n     }\n-    public function asString(): string\n+    protected function asString(): string\n     {\n         return $this->algorithm;\n     }\n }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.c60f68b00a35e2aa6cd6a275375c9a22.infection.xml\n\nE\n\nTime: 00:00.001, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithmTest::testCanBeUsedAsString\nError: Call to protected method norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithm::asString() from scope norsk\\api\\app\\identityAccessManagement\\AuthenticationAlgorithmTest\n\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/AuthenticationAlgorithmTest.php:16\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nclass AuthenticationKey\n{\n    private function __construct(private readonly string $key)\n    {\n    }\n    public static function by(string $key): self\n    {\n        return new self($key);\n    }\n    public function asString(): string\n    {\n        return $this->key;\n    }\n    public function asBase64String(): string\n    {\n        return base64_encode($this->key);\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nclass AuthenticationKey\n{\n    private function __construct(private readonly string $key)\n    {\n    }\n    protected static function by(string $key): self\n    {\n        return new self($key);\n    }\n    public function asString(): string\n    {\n        return $this->key;\n    }\n    public function asBase64String(): string\n    {\n        return base64_encode($this->key);\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/AuthenticationKey.php","originalStartLine":14},"diff":"@@ @@\n     private function __construct(private readonly string $key)\n     {\n     }\n-    public static function by(string $key): self\n+    protected static function by(string $key): self\n     {\n         return new self($key);\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.750196381fca0000c2246cd589d7fe67.infection.xml\n\nE\n\nTime: 00:00.001, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\AuthenticationKeyTest::testCanBeUsedAsString\nError: Call to protected method norsk\\api\\app\\identityAccessManagement\\AuthenticationKey::by() from scope norsk\\api\\app\\identityAccessManagement\\AuthenticationKeyTest\n\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/AuthenticationKeyTest.php:15\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nclass AuthenticationKey\n{\n    private function __construct(private readonly string $key)\n    {\n    }\n    public static function by(string $key): self\n    {\n        return new self($key);\n    }\n    public function asString(): string\n    {\n        return $this->key;\n    }\n    public function asBase64String(): string\n    {\n        return base64_encode($this->key);\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nclass AuthenticationKey\n{\n    private function __construct(private readonly string $key)\n    {\n    }\n    public static function by(string $key): self\n    {\n        return new self($key);\n    }\n    protected function asString(): string\n    {\n        return $this->key;\n    }\n    public function asBase64String(): string\n    {\n        return base64_encode($this->key);\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/AuthenticationKey.php","originalStartLine":20},"diff":"@@ @@\n     {\n         return new self($key);\n     }\n-    public function asString(): string\n+    protected function asString(): string\n     {\n         return $this->key;\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.1333efa7d3dae34ffab3eac59ea3e603.infection.xml\n\nE\n\nTime: 00:00.001, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\AuthenticationKeyTest::testCanBeUsedAsString\nError: Call to protected method norsk\\api\\app\\identityAccessManagement\\AuthenticationKey::asString() from scope norsk\\api\\app\\identityAccessManagement\\AuthenticationKeyTest\n\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/AuthenticationKeyTest.php:15\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nclass AuthenticationKey\n{\n    private function __construct(private readonly string $key)\n    {\n    }\n    public static function by(string $key): self\n    {\n        return new self($key);\n    }\n    public function asString(): string\n    {\n        return $this->key;\n    }\n    public function asBase64String(): string\n    {\n        return base64_encode($this->key);\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nclass AuthenticationKey\n{\n    private function __construct(private readonly string $key)\n    {\n    }\n    public static function by(string $key): self\n    {\n        return new self($key);\n    }\n    public function asString(): string\n    {\n        return $this->key;\n    }\n    protected function asBase64String(): string\n    {\n        return base64_encode($this->key);\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/AuthenticationKey.php","originalStartLine":26},"diff":"@@ @@\n     {\n         return $this->key;\n     }\n-    public function asBase64String(): string\n+    protected function asBase64String(): string\n     {\n         return base64_encode($this->key);\n     }\n }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.585a422408a9b4d9c407e2290f61b558.infection.xml\n\n.E                                                                  2 \/ 2 (100%)\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\AuthenticationKeyTest::testCanBeUsedAsBase64String\nError: Call to protected method norsk\\api\\app\\identityAccessManagement\\AuthenticationKey::asBase64String() from scope norsk\\api\\app\\identityAccessManagement\\AuthenticationKeyTest\n\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/AuthenticationKeyTest.php:21\n\nERRORS!\nTests: 2, Assertions: 1, Errors: 1."},{"mutator":{"mutatorName":"IfNegation","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\response\\UnauthorizedResponse;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\shared\\responses\\ErrorResponse;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface as RequestHandler;\nuse Throwable;\nclass Authorization implements MiddlewareInterface\n{\n    public function __construct(private readonly Logger $logger, private readonly UsersReader $usersReader, private readonly Url $url)\n    {\n    }\n    public function process(Request $request, RequestHandler $handler): ResponseInterface\n    {\n        $userName = null;\n        try {\n            if (Session::isValidManager()) {\n                $userName = Session::getUserName();\n                $this->usersReader->isActiveManager($userName);\n                $logMessage = LogMessage::fromString('Authenticated manager: ' . $userName->asString());\n                $this->logger->info($logMessage);\n                return $handler->handle($request);\n            }\n        } catch (Throwable $throwable) {\n            $logMessage = $this->getLogMessage($userName);\n            $this->logger->info(LogMessage::fromString($logMessage));\n            $this->logger->error($throwable);\n            return ErrorResponse::unauthorized($this->url, $throwable);\n        }\n        return UnauthorizedResponse::noRights($this->url);\n    }\n    private function getLogMessage(?UserName $userName): string\n    {\n        if ($userName instanceof UserName) {\n            return 'Could not authenticate manager: ' . $userName->asString();\n        }\n        return 'Could not authenticate manager without user name.';\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\response\\UnauthorizedResponse;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\shared\\responses\\ErrorResponse;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface as RequestHandler;\nuse Throwable;\nclass Authorization implements MiddlewareInterface\n{\n    public function __construct(private readonly Logger $logger, private readonly UsersReader $usersReader, private readonly Url $url)\n    {\n    }\n    public function process(Request $request, RequestHandler $handler): ResponseInterface\n    {\n        $userName = null;\n        try {\n            if (!Session::isValidManager()) {\n                $userName = Session::getUserName();\n                $this->usersReader->isActiveManager($userName);\n                $logMessage = LogMessage::fromString('Authenticated manager: ' . $userName->asString());\n                $this->logger->info($logMessage);\n                return $handler->handle($request);\n            }\n        } catch (Throwable $throwable) {\n            $logMessage = $this->getLogMessage($userName);\n            $this->logger->info(LogMessage::fromString($logMessage));\n            $this->logger->error($throwable);\n            return ErrorResponse::unauthorized($this->url, $throwable);\n        }\n        return UnauthorizedResponse::noRights($this->url);\n    }\n    private function getLogMessage(?UserName $userName): string\n    {\n        if ($userName instanceof UserName) {\n            return 'Could not authenticate manager: ' . $userName->asString();\n        }\n        return 'Could not authenticate manager without user name.';\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/Authorization.php","originalStartLine":34},"diff":"@@ @@\n     {\n         $userName = null;\n         try {\n-            if (Session::isValidManager()) {\n+            if (!Session::isValidManager()) {\n                 $userName = Session::getUserName();\n                 $this->usersReader->isActiveManager($userName);\n                 $logMessage = LogMessage::fromString('Authenticated manager: ' . $userName->asString());","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.735b50a33cef864ca6eb114efa8bc422.infection.xml\n\nF\n\nTime: 00:00.005, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\AuthorizationTest::testCanReturnSuccessfulAuthorization\nExpectation failed for method name is \"info\" when invoked 1 time.\nMethod was expected to be called 1 time, actually called 0 times.\n\nFAILURES!\nTests: 1, Assertions: 1, Failures: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\response\\UnauthorizedResponse;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\shared\\responses\\ErrorResponse;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface as RequestHandler;\nuse Throwable;\nclass Authorization implements MiddlewareInterface\n{\n    public function __construct(private readonly Logger $logger, private readonly UsersReader $usersReader, private readonly Url $url)\n    {\n    }\n    public function process(Request $request, RequestHandler $handler): ResponseInterface\n    {\n        $userName = null;\n        try {\n            if (Session::isValidManager()) {\n                $userName = Session::getUserName();\n                $this->usersReader->isActiveManager($userName);\n                $logMessage = LogMessage::fromString('Authenticated manager: ' . $userName->asString());\n                $this->logger->info($logMessage);\n                return $handler->handle($request);\n            }\n        } catch (Throwable $throwable) {\n            $logMessage = $this->getLogMessage($userName);\n            $this->logger->info(LogMessage::fromString($logMessage));\n            $this->logger->error($throwable);\n            return ErrorResponse::unauthorized($this->url, $throwable);\n        }\n        return UnauthorizedResponse::noRights($this->url);\n    }\n    private function getLogMessage(?UserName $userName): string\n    {\n        if ($userName instanceof UserName) {\n            return 'Could not authenticate manager: ' . $userName->asString();\n        }\n        return 'Could not authenticate manager without user name.';\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\response\\UnauthorizedResponse;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\shared\\responses\\ErrorResponse;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface as RequestHandler;\nuse Throwable;\nclass Authorization implements MiddlewareInterface\n{\n    public function __construct(private readonly Logger $logger, private readonly UsersReader $usersReader, private readonly Url $url)\n    {\n    }\n    public function process(Request $request, RequestHandler $handler): ResponseInterface\n    {\n        $userName = null;\n        try {\n            if (Session::isValidManager()) {\n                $userName = Session::getUserName();\n                \n                $logMessage = LogMessage::fromString('Authenticated manager: ' . $userName->asString());\n                $this->logger->info($logMessage);\n                return $handler->handle($request);\n            }\n        } catch (Throwable $throwable) {\n            $logMessage = $this->getLogMessage($userName);\n            $this->logger->info(LogMessage::fromString($logMessage));\n            $this->logger->error($throwable);\n            return ErrorResponse::unauthorized($this->url, $throwable);\n        }\n        return UnauthorizedResponse::noRights($this->url);\n    }\n    private function getLogMessage(?UserName $userName): string\n    {\n        if ($userName instanceof UserName) {\n            return 'Could not authenticate manager: ' . $userName->asString();\n        }\n        return 'Could not authenticate manager without user name.';\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/Authorization.php","originalStartLine":36},"diff":"@@ @@\n         try {\n             if (Session::isValidManager()) {\n                 $userName = Session::getUserName();\n-                $this->usersReader->isActiveManager($userName);\n+                \n                 $logMessage = LogMessage::fromString('Authenticated manager: ' . $userName->asString());\n                 $this->logger->info($logMessage);\n                 return $handler->handle($request);","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.7ecc43136eab8c07e7a7ff0a20ca3ced.infection.xml\n\nF\n\nTime: 00:00.005, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\AuthorizationTest::testCanReturnSuccessfulAuthorization\nExpectation failed for method name is \"isActiveManager\" when invoked 1 time.\nMethod was expected to be called 1 time, actually called 0 times.\n\nFAILURES!\nTests: 1, Assertions: 4, Failures: 1."},{"mutator":{"mutatorName":"Concat","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\response\\UnauthorizedResponse;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\shared\\responses\\ErrorResponse;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface as RequestHandler;\nuse Throwable;\nclass Authorization implements MiddlewareInterface\n{\n    public function __construct(private readonly Logger $logger, private readonly UsersReader $usersReader, private readonly Url $url)\n    {\n    }\n    public function process(Request $request, RequestHandler $handler): ResponseInterface\n    {\n        $userName = null;\n        try {\n            if (Session::isValidManager()) {\n                $userName = Session::getUserName();\n                $this->usersReader->isActiveManager($userName);\n                $logMessage = LogMessage::fromString('Authenticated manager: ' . $userName->asString());\n                $this->logger->info($logMessage);\n                return $handler->handle($request);\n            }\n        } catch (Throwable $throwable) {\n            $logMessage = $this->getLogMessage($userName);\n            $this->logger->info(LogMessage::fromString($logMessage));\n            $this->logger->error($throwable);\n            return ErrorResponse::unauthorized($this->url, $throwable);\n        }\n        return UnauthorizedResponse::noRights($this->url);\n    }\n    private function getLogMessage(?UserName $userName): string\n    {\n        if ($userName instanceof UserName) {\n            return 'Could not authenticate manager: ' . $userName->asString();\n        }\n        return 'Could not authenticate manager without user name.';\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\response\\UnauthorizedResponse;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\shared\\responses\\ErrorResponse;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface as RequestHandler;\nuse Throwable;\nclass Authorization implements MiddlewareInterface\n{\n    public function __construct(private readonly Logger $logger, private readonly UsersReader $usersReader, private readonly Url $url)\n    {\n    }\n    public function process(Request $request, RequestHandler $handler): ResponseInterface\n    {\n        $userName = null;\n        try {\n            if (Session::isValidManager()) {\n                $userName = Session::getUserName();\n                $this->usersReader->isActiveManager($userName);\n                $logMessage = LogMessage::fromString($userName->asString() . 'Authenticated manager: ');\n                $this->logger->info($logMessage);\n                return $handler->handle($request);\n            }\n        } catch (Throwable $throwable) {\n            $logMessage = $this->getLogMessage($userName);\n            $this->logger->info(LogMessage::fromString($logMessage));\n            $this->logger->error($throwable);\n            return ErrorResponse::unauthorized($this->url, $throwable);\n        }\n        return UnauthorizedResponse::noRights($this->url);\n    }\n    private function getLogMessage(?UserName $userName): string\n    {\n        if ($userName instanceof UserName) {\n            return 'Could not authenticate manager: ' . $userName->asString();\n        }\n        return 'Could not authenticate manager without user name.';\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/Authorization.php","originalStartLine":38},"diff":"@@ @@\n             if (Session::isValidManager()) {\n                 $userName = Session::getUserName();\n                 $this->usersReader->isActiveManager($userName);\n-                $logMessage = LogMessage::fromString('Authenticated manager: ' . $userName->asString());\n+                $logMessage = LogMessage::fromString($userName->asString() . 'Authenticated manager: ');\n                 $this->logger->info($logMessage);\n                 return $handler->handle($request);\n             }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.6ff1041546292ce90f8b48c299ee5daa.infection.xml\n\nF\n\nTime: 00:00.004, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\AuthorizationTest::testCanReturnSuccessfulAuthorization\nnorsk\\api\\app\\logging\\Logger::info(norsk\\api\\app\\logging\\LogMessage Object (...)): void was not expected to be called more than once.\n\n\/app\/api\/src\/app\/identityAccessManagement\/Authorization.php:36\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/AuthorizationTest.php:68\n\nFAILURES!\nTests: 1, Assertions: 3, Failures: 1."},{"mutator":{"mutatorName":"ConcatOperandRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\response\\UnauthorizedResponse;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\shared\\responses\\ErrorResponse;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface as RequestHandler;\nuse Throwable;\nclass Authorization implements MiddlewareInterface\n{\n    public function __construct(private readonly Logger $logger, private readonly UsersReader $usersReader, private readonly Url $url)\n    {\n    }\n    public function process(Request $request, RequestHandler $handler): ResponseInterface\n    {\n        $userName = null;\n        try {\n            if (Session::isValidManager()) {\n                $userName = Session::getUserName();\n                $this->usersReader->isActiveManager($userName);\n                $logMessage = LogMessage::fromString('Authenticated manager: ' . $userName->asString());\n                $this->logger->info($logMessage);\n                return $handler->handle($request);\n            }\n        } catch (Throwable $throwable) {\n            $logMessage = $this->getLogMessage($userName);\n            $this->logger->info(LogMessage::fromString($logMessage));\n            $this->logger->error($throwable);\n            return ErrorResponse::unauthorized($this->url, $throwable);\n        }\n        return UnauthorizedResponse::noRights($this->url);\n    }\n    private function getLogMessage(?UserName $userName): string\n    {\n        if ($userName instanceof UserName) {\n            return 'Could not authenticate manager: ' . $userName->asString();\n        }\n        return 'Could not authenticate manager without user name.';\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\response\\UnauthorizedResponse;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\shared\\responses\\ErrorResponse;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface as RequestHandler;\nuse Throwable;\nclass Authorization implements MiddlewareInterface\n{\n    public function __construct(private readonly Logger $logger, private readonly UsersReader $usersReader, private readonly Url $url)\n    {\n    }\n    public function process(Request $request, RequestHandler $handler): ResponseInterface\n    {\n        $userName = null;\n        try {\n            if (Session::isValidManager()) {\n                $userName = Session::getUserName();\n                $this->usersReader->isActiveManager($userName);\n                $logMessage = LogMessage::fromString($userName->asString());\n                $this->logger->info($logMessage);\n                return $handler->handle($request);\n            }\n        } catch (Throwable $throwable) {\n            $logMessage = $this->getLogMessage($userName);\n            $this->logger->info(LogMessage::fromString($logMessage));\n            $this->logger->error($throwable);\n            return ErrorResponse::unauthorized($this->url, $throwable);\n        }\n        return UnauthorizedResponse::noRights($this->url);\n    }\n    private function getLogMessage(?UserName $userName): string\n    {\n        if ($userName instanceof UserName) {\n            return 'Could not authenticate manager: ' . $userName->asString();\n        }\n        return 'Could not authenticate manager without user name.';\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/Authorization.php","originalStartLine":38},"diff":"@@ @@\n             if (Session::isValidManager()) {\n                 $userName = Session::getUserName();\n                 $this->usersReader->isActiveManager($userName);\n-                $logMessage = LogMessage::fromString('Authenticated manager: ' . $userName->asString());\n+                $logMessage = LogMessage::fromString($userName->asString());\n                 $this->logger->info($logMessage);\n                 return $handler->handle($request);\n             }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.f8324f0f52b50a678632212f7b3b4dda.infection.xml\n\nF\n\nTime: 00:00.005, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\AuthorizationTest::testCanReturnSuccessfulAuthorization\nnorsk\\api\\app\\logging\\Logger::info(norsk\\api\\app\\logging\\LogMessage Object (...)): void was not expected to be called more than once.\n\n\/app\/api\/src\/app\/identityAccessManagement\/Authorization.php:36\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/AuthorizationTest.php:68\n\nFAILURES!\nTests: 1, Assertions: 3, Failures: 1."},{"mutator":{"mutatorName":"ConcatOperandRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\response\\UnauthorizedResponse;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\shared\\responses\\ErrorResponse;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface as RequestHandler;\nuse Throwable;\nclass Authorization implements MiddlewareInterface\n{\n    public function __construct(private readonly Logger $logger, private readonly UsersReader $usersReader, private readonly Url $url)\n    {\n    }\n    public function process(Request $request, RequestHandler $handler): ResponseInterface\n    {\n        $userName = null;\n        try {\n            if (Session::isValidManager()) {\n                $userName = Session::getUserName();\n                $this->usersReader->isActiveManager($userName);\n                $logMessage = LogMessage::fromString('Authenticated manager: ' . $userName->asString());\n                $this->logger->info($logMessage);\n                return $handler->handle($request);\n            }\n        } catch (Throwable $throwable) {\n            $logMessage = $this->getLogMessage($userName);\n            $this->logger->info(LogMessage::fromString($logMessage));\n            $this->logger->error($throwable);\n            return ErrorResponse::unauthorized($this->url, $throwable);\n        }\n        return UnauthorizedResponse::noRights($this->url);\n    }\n    private function getLogMessage(?UserName $userName): string\n    {\n        if ($userName instanceof UserName) {\n            return 'Could not authenticate manager: ' . $userName->asString();\n        }\n        return 'Could not authenticate manager without user name.';\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\response\\UnauthorizedResponse;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\shared\\responses\\ErrorResponse;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface as RequestHandler;\nuse Throwable;\nclass Authorization implements MiddlewareInterface\n{\n    public function __construct(private readonly Logger $logger, private readonly UsersReader $usersReader, private readonly Url $url)\n    {\n    }\n    public function process(Request $request, RequestHandler $handler): ResponseInterface\n    {\n        $userName = null;\n        try {\n            if (Session::isValidManager()) {\n                $userName = Session::getUserName();\n                $this->usersReader->isActiveManager($userName);\n                $logMessage = LogMessage::fromString('Authenticated manager: ');\n                $this->logger->info($logMessage);\n                return $handler->handle($request);\n            }\n        } catch (Throwable $throwable) {\n            $logMessage = $this->getLogMessage($userName);\n            $this->logger->info(LogMessage::fromString($logMessage));\n            $this->logger->error($throwable);\n            return ErrorResponse::unauthorized($this->url, $throwable);\n        }\n        return UnauthorizedResponse::noRights($this->url);\n    }\n    private function getLogMessage(?UserName $userName): string\n    {\n        if ($userName instanceof UserName) {\n            return 'Could not authenticate manager: ' . $userName->asString();\n        }\n        return 'Could not authenticate manager without user name.';\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/Authorization.php","originalStartLine":38},"diff":"@@ @@\n             if (Session::isValidManager()) {\n                 $userName = Session::getUserName();\n                 $this->usersReader->isActiveManager($userName);\n-                $logMessage = LogMessage::fromString('Authenticated manager: ' . $userName->asString());\n+                $logMessage = LogMessage::fromString('Authenticated manager: ');\n                 $this->logger->info($logMessage);\n                 return $handler->handle($request);\n             }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.ae394e861ec8b6c583ec3abc600e4d0f.infection.xml\n\nF\n\nTime: 00:00.004, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\AuthorizationTest::testCanReturnSuccessfulAuthorization\nnorsk\\api\\app\\logging\\Logger::info(norsk\\api\\app\\logging\\LogMessage Object (...)): void was not expected to be called more than once.\n\n\/app\/api\/src\/app\/identityAccessManagement\/Authorization.php:36\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/AuthorizationTest.php:68\n\nFAILURES!\nTests: 1, Assertions: 3, Failures: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\response\\UnauthorizedResponse;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\shared\\responses\\ErrorResponse;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface as RequestHandler;\nuse Throwable;\nclass Authorization implements MiddlewareInterface\n{\n    public function __construct(private readonly Logger $logger, private readonly UsersReader $usersReader, private readonly Url $url)\n    {\n    }\n    public function process(Request $request, RequestHandler $handler): ResponseInterface\n    {\n        $userName = null;\n        try {\n            if (Session::isValidManager()) {\n                $userName = Session::getUserName();\n                $this->usersReader->isActiveManager($userName);\n                $logMessage = LogMessage::fromString('Authenticated manager: ' . $userName->asString());\n                $this->logger->info($logMessage);\n                return $handler->handle($request);\n            }\n        } catch (Throwable $throwable) {\n            $logMessage = $this->getLogMessage($userName);\n            $this->logger->info(LogMessage::fromString($logMessage));\n            $this->logger->error($throwable);\n            return ErrorResponse::unauthorized($this->url, $throwable);\n        }\n        return UnauthorizedResponse::noRights($this->url);\n    }\n    private function getLogMessage(?UserName $userName): string\n    {\n        if ($userName instanceof UserName) {\n            return 'Could not authenticate manager: ' . $userName->asString();\n        }\n        return 'Could not authenticate manager without user name.';\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\response\\UnauthorizedResponse;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\shared\\responses\\ErrorResponse;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface as RequestHandler;\nuse Throwable;\nclass Authorization implements MiddlewareInterface\n{\n    public function __construct(private readonly Logger $logger, private readonly UsersReader $usersReader, private readonly Url $url)\n    {\n    }\n    public function process(Request $request, RequestHandler $handler): ResponseInterface\n    {\n        $userName = null;\n        try {\n            if (Session::isValidManager()) {\n                $userName = Session::getUserName();\n                $this->usersReader->isActiveManager($userName);\n                $logMessage = LogMessage::fromString('Authenticated manager: ' . $userName->asString());\n                \n                return $handler->handle($request);\n            }\n        } catch (Throwable $throwable) {\n            $logMessage = $this->getLogMessage($userName);\n            $this->logger->info(LogMessage::fromString($logMessage));\n            $this->logger->error($throwable);\n            return ErrorResponse::unauthorized($this->url, $throwable);\n        }\n        return UnauthorizedResponse::noRights($this->url);\n    }\n    private function getLogMessage(?UserName $userName): string\n    {\n        if ($userName instanceof UserName) {\n            return 'Could not authenticate manager: ' . $userName->asString();\n        }\n        return 'Could not authenticate manager without user name.';\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/Authorization.php","originalStartLine":39},"diff":"@@ @@\n                 $userName = Session::getUserName();\n                 $this->usersReader->isActiveManager($userName);\n                 $logMessage = LogMessage::fromString('Authenticated manager: ' . $userName->asString());\n-                $this->logger->info($logMessage);\n+                \n                 return $handler->handle($request);\n             }\n         } catch (Throwable $throwable) {","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.2aeda07512ec09b88850e2813d988f9c.infection.xml\n\nF\n\nTime: 00:00.005, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\AuthorizationTest::testCanReturnSuccessfulAuthorization\nExpectation failed for method name is \"info\" when invoked 1 time.\nMethod was expected to be called 1 time, actually called 0 times.\n\nFAILURES!\nTests: 1, Assertions: 3, Failures: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\response\\UnauthorizedResponse;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\shared\\responses\\ErrorResponse;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface as RequestHandler;\nuse Throwable;\nclass Authorization implements MiddlewareInterface\n{\n    public function __construct(private readonly Logger $logger, private readonly UsersReader $usersReader, private readonly Url $url)\n    {\n    }\n    public function process(Request $request, RequestHandler $handler): ResponseInterface\n    {\n        $userName = null;\n        try {\n            if (Session::isValidManager()) {\n                $userName = Session::getUserName();\n                $this->usersReader->isActiveManager($userName);\n                $logMessage = LogMessage::fromString('Authenticated manager: ' . $userName->asString());\n                $this->logger->info($logMessage);\n                return $handler->handle($request);\n            }\n        } catch (Throwable $throwable) {\n            $logMessage = $this->getLogMessage($userName);\n            $this->logger->info(LogMessage::fromString($logMessage));\n            $this->logger->error($throwable);\n            return ErrorResponse::unauthorized($this->url, $throwable);\n        }\n        return UnauthorizedResponse::noRights($this->url);\n    }\n    private function getLogMessage(?UserName $userName): string\n    {\n        if ($userName instanceof UserName) {\n            return 'Could not authenticate manager: ' . $userName->asString();\n        }\n        return 'Could not authenticate manager without user name.';\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\response\\UnauthorizedResponse;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\shared\\responses\\ErrorResponse;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface as RequestHandler;\nuse Throwable;\nclass Authorization implements MiddlewareInterface\n{\n    public function __construct(private readonly Logger $logger, private readonly UsersReader $usersReader, private readonly Url $url)\n    {\n    }\n    public function process(Request $request, RequestHandler $handler): ResponseInterface\n    {\n        $userName = null;\n        try {\n            if (Session::isValidManager()) {\n                $userName = Session::getUserName();\n                $this->usersReader->isActiveManager($userName);\n                $logMessage = LogMessage::fromString('Authenticated manager: ' . $userName->asString());\n                $this->logger->info($logMessage);\n                return $handler->handle($request);\n            }\n        } catch (Throwable $throwable) {\n            $logMessage = $this->getLogMessage($userName);\n            \n            $this->logger->error($throwable);\n            return ErrorResponse::unauthorized($this->url, $throwable);\n        }\n        return UnauthorizedResponse::noRights($this->url);\n    }\n    private function getLogMessage(?UserName $userName): string\n    {\n        if ($userName instanceof UserName) {\n            return 'Could not authenticate manager: ' . $userName->asString();\n        }\n        return 'Could not authenticate manager without user name.';\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/Authorization.php","originalStartLine":45},"diff":"@@ @@\n             }\n         } catch (Throwable $throwable) {\n             $logMessage = $this->getLogMessage($userName);\n-            $this->logger->info(LogMessage::fromString($logMessage));\n+            \n             $this->logger->error($throwable);\n             return ErrorResponse::unauthorized($this->url, $throwable);\n         }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.d6feca18ac0a353f9d0d76e215437cc6.infection.xml\n\n...F\n\nTime: 00:00.007, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\AuthorizationTest::testCanHandleErrorIfUserNameExists\nExpectation failed for method name is \"info\" when invoked 1 time.\nMethod was expected to be called 1 time, actually called 0 times.\n\nFAILURES!\nTests: 4, Assertions: 21, Failures: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\response\\UnauthorizedResponse;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\shared\\responses\\ErrorResponse;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface as RequestHandler;\nuse Throwable;\nclass Authorization implements MiddlewareInterface\n{\n    public function __construct(private readonly Logger $logger, private readonly UsersReader $usersReader, private readonly Url $url)\n    {\n    }\n    public function process(Request $request, RequestHandler $handler): ResponseInterface\n    {\n        $userName = null;\n        try {\n            if (Session::isValidManager()) {\n                $userName = Session::getUserName();\n                $this->usersReader->isActiveManager($userName);\n                $logMessage = LogMessage::fromString('Authenticated manager: ' . $userName->asString());\n                $this->logger->info($logMessage);\n                return $handler->handle($request);\n            }\n        } catch (Throwable $throwable) {\n            $logMessage = $this->getLogMessage($userName);\n            $this->logger->info(LogMessage::fromString($logMessage));\n            $this->logger->error($throwable);\n            return ErrorResponse::unauthorized($this->url, $throwable);\n        }\n        return UnauthorizedResponse::noRights($this->url);\n    }\n    private function getLogMessage(?UserName $userName): string\n    {\n        if ($userName instanceof UserName) {\n            return 'Could not authenticate manager: ' . $userName->asString();\n        }\n        return 'Could not authenticate manager without user name.';\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\response\\UnauthorizedResponse;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\shared\\responses\\ErrorResponse;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface as RequestHandler;\nuse Throwable;\nclass Authorization implements MiddlewareInterface\n{\n    public function __construct(private readonly Logger $logger, private readonly UsersReader $usersReader, private readonly Url $url)\n    {\n    }\n    public function process(Request $request, RequestHandler $handler): ResponseInterface\n    {\n        $userName = null;\n        try {\n            if (Session::isValidManager()) {\n                $userName = Session::getUserName();\n                $this->usersReader->isActiveManager($userName);\n                $logMessage = LogMessage::fromString('Authenticated manager: ' . $userName->asString());\n                $this->logger->info($logMessage);\n                return $handler->handle($request);\n            }\n        } catch (Throwable $throwable) {\n            $logMessage = $this->getLogMessage($userName);\n            $this->logger->info(LogMessage::fromString($logMessage));\n            \n            return ErrorResponse::unauthorized($this->url, $throwable);\n        }\n        return UnauthorizedResponse::noRights($this->url);\n    }\n    private function getLogMessage(?UserName $userName): string\n    {\n        if ($userName instanceof UserName) {\n            return 'Could not authenticate manager: ' . $userName->asString();\n        }\n        return 'Could not authenticate manager without user name.';\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/Authorization.php","originalStartLine":46},"diff":"@@ @@\n         } catch (Throwable $throwable) {\n             $logMessage = $this->getLogMessage($userName);\n             $this->logger->info(LogMessage::fromString($logMessage));\n-            $this->logger->error($throwable);\n+            \n             return ErrorResponse::unauthorized($this->url, $throwable);\n         }\n         return UnauthorizedResponse::noRights($this->url);","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.444409b9d1607e7d71ceb6a804e820fb.infection.xml\n\n...F\n\nTime: 00:00.007, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\AuthorizationTest::testCanHandleErrorIfUserNameExists\nExpectation failed for method name is \"error\" when invoked 1 time.\nMethod was expected to be called 1 time, actually called 0 times.\n\nFAILURES!\nTests: 4, Assertions: 21, Failures: 1."},{"mutator":{"mutatorName":"InstanceOf_","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\response\\UnauthorizedResponse;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\shared\\responses\\ErrorResponse;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface as RequestHandler;\nuse Throwable;\nclass Authorization implements MiddlewareInterface\n{\n    public function __construct(private readonly Logger $logger, private readonly UsersReader $usersReader, private readonly Url $url)\n    {\n    }\n    public function process(Request $request, RequestHandler $handler): ResponseInterface\n    {\n        $userName = null;\n        try {\n            if (Session::isValidManager()) {\n                $userName = Session::getUserName();\n                $this->usersReader->isActiveManager($userName);\n                $logMessage = LogMessage::fromString('Authenticated manager: ' . $userName->asString());\n                $this->logger->info($logMessage);\n                return $handler->handle($request);\n            }\n        } catch (Throwable $throwable) {\n            $logMessage = $this->getLogMessage($userName);\n            $this->logger->info(LogMessage::fromString($logMessage));\n            $this->logger->error($throwable);\n            return ErrorResponse::unauthorized($this->url, $throwable);\n        }\n        return UnauthorizedResponse::noRights($this->url);\n    }\n    private function getLogMessage(?UserName $userName): string\n    {\n        if ($userName instanceof UserName) {\n            return 'Could not authenticate manager: ' . $userName->asString();\n        }\n        return 'Could not authenticate manager without user name.';\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\response\\UnauthorizedResponse;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\shared\\responses\\ErrorResponse;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface as RequestHandler;\nuse Throwable;\nclass Authorization implements MiddlewareInterface\n{\n    public function __construct(private readonly Logger $logger, private readonly UsersReader $usersReader, private readonly Url $url)\n    {\n    }\n    public function process(Request $request, RequestHandler $handler): ResponseInterface\n    {\n        $userName = null;\n        try {\n            if (Session::isValidManager()) {\n                $userName = Session::getUserName();\n                $this->usersReader->isActiveManager($userName);\n                $logMessage = LogMessage::fromString('Authenticated manager: ' . $userName->asString());\n                $this->logger->info($logMessage);\n                return $handler->handle($request);\n            }\n        } catch (Throwable $throwable) {\n            $logMessage = $this->getLogMessage($userName);\n            $this->logger->info(LogMessage::fromString($logMessage));\n            $this->logger->error($throwable);\n            return ErrorResponse::unauthorized($this->url, $throwable);\n        }\n        return UnauthorizedResponse::noRights($this->url);\n    }\n    private function getLogMessage(?UserName $userName): string\n    {\n        if (true) {\n            return 'Could not authenticate manager: ' . $userName->asString();\n        }\n        return 'Could not authenticate manager without user name.';\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/Authorization.php","originalStartLine":57},"diff":"@@ @@\n     }\n     private function getLogMessage(?UserName $userName): string\n     {\n-        if ($userName instanceof UserName) {\n+        if (true) {\n             return 'Could not authenticate manager: ' . $userName->asString();\n         }\n         return 'Could not authenticate manager without user name.';\n     }\n }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.0907be00e4176537c6e02d77bc38c91d.infection.xml\n\n....E                                                               5 \/ 5 (100%)\n\nTime: 00:00.007, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\AuthorizationTest::testCanHandleErrorIfUserNameIsEmpty\nError: Call to a member function asString() on null\n\n\/app\/api\/src\/app\/identityAccessManagement\/Authorization.php:45\n\/app\/api\/src\/app\/identityAccessManagement\/Authorization.php:35\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/AuthorizationTest.php:188\n\nERRORS!\nTests: 5, Assertions: 24, Errors: 1."},{"mutator":{"mutatorName":"InstanceOf_","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\response\\UnauthorizedResponse;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\shared\\responses\\ErrorResponse;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface as RequestHandler;\nuse Throwable;\nclass Authorization implements MiddlewareInterface\n{\n    public function __construct(private readonly Logger $logger, private readonly UsersReader $usersReader, private readonly Url $url)\n    {\n    }\n    public function process(Request $request, RequestHandler $handler): ResponseInterface\n    {\n        $userName = null;\n        try {\n            if (Session::isValidManager()) {\n                $userName = Session::getUserName();\n                $this->usersReader->isActiveManager($userName);\n                $logMessage = LogMessage::fromString('Authenticated manager: ' . $userName->asString());\n                $this->logger->info($logMessage);\n                return $handler->handle($request);\n            }\n        } catch (Throwable $throwable) {\n            $logMessage = $this->getLogMessage($userName);\n            $this->logger->info(LogMessage::fromString($logMessage));\n            $this->logger->error($throwable);\n            return ErrorResponse::unauthorized($this->url, $throwable);\n        }\n        return UnauthorizedResponse::noRights($this->url);\n    }\n    private function getLogMessage(?UserName $userName): string\n    {\n        if ($userName instanceof UserName) {\n            return 'Could not authenticate manager: ' . $userName->asString();\n        }\n        return 'Could not authenticate manager without user name.';\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\response\\UnauthorizedResponse;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\shared\\responses\\ErrorResponse;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface as RequestHandler;\nuse Throwable;\nclass Authorization implements MiddlewareInterface\n{\n    public function __construct(private readonly Logger $logger, private readonly UsersReader $usersReader, private readonly Url $url)\n    {\n    }\n    public function process(Request $request, RequestHandler $handler): ResponseInterface\n    {\n        $userName = null;\n        try {\n            if (Session::isValidManager()) {\n                $userName = Session::getUserName();\n                $this->usersReader->isActiveManager($userName);\n                $logMessage = LogMessage::fromString('Authenticated manager: ' . $userName->asString());\n                $this->logger->info($logMessage);\n                return $handler->handle($request);\n            }\n        } catch (Throwable $throwable) {\n            $logMessage = $this->getLogMessage($userName);\n            $this->logger->info(LogMessage::fromString($logMessage));\n            $this->logger->error($throwable);\n            return ErrorResponse::unauthorized($this->url, $throwable);\n        }\n        return UnauthorizedResponse::noRights($this->url);\n    }\n    private function getLogMessage(?UserName $userName): string\n    {\n        if (false) {\n            return 'Could not authenticate manager: ' . $userName->asString();\n        }\n        return 'Could not authenticate manager without user name.';\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/Authorization.php","originalStartLine":57},"diff":"@@ @@\n     }\n     private function getLogMessage(?UserName $userName): string\n     {\n-        if ($userName instanceof UserName) {\n+        if (false) {\n             return 'Could not authenticate manager: ' . $userName->asString();\n         }\n         return 'Could not authenticate manager without user name.';\n     }\n }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.f786418bdc89fb3f2e4f7a29129c7c23.infection.xml\n\n...F\n\nTime: 00:00.009, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\AuthorizationTest::testCanHandleErrorIfUserNameExists\nExpectation failed for method name is \"info\" when invoked 1 time\nParameter 0 for invocation norsk\\api\\app\\logging\\Logger::info(norsk\\api\\app\\logging\\LogMessage Object (...)): void does not match expected value.\nFailed asserting that two objects are equal.\n--- Expected\n+++ Actual\n@@ @@\n norsk\\api\\app\\logging\\LogMessage Object (\n-    'message' => 'Could not authenticate manager: someUsername'\n+    'message' => 'Could not authenticate manager without user name.'\n )\n\n\/app\/api\/src\/app\/identityAccessManagement\/Authorization.php:36\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/AuthorizationTest.php:151\n\nFAILURES!\nTests: 4, Assertions: 18, Failures: 1."},{"mutator":{"mutatorName":"Concat","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\response\\UnauthorizedResponse;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\shared\\responses\\ErrorResponse;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface as RequestHandler;\nuse Throwable;\nclass Authorization implements MiddlewareInterface\n{\n    public function __construct(private readonly Logger $logger, private readonly UsersReader $usersReader, private readonly Url $url)\n    {\n    }\n    public function process(Request $request, RequestHandler $handler): ResponseInterface\n    {\n        $userName = null;\n        try {\n            if (Session::isValidManager()) {\n                $userName = Session::getUserName();\n                $this->usersReader->isActiveManager($userName);\n                $logMessage = LogMessage::fromString('Authenticated manager: ' . $userName->asString());\n                $this->logger->info($logMessage);\n                return $handler->handle($request);\n            }\n        } catch (Throwable $throwable) {\n            $logMessage = $this->getLogMessage($userName);\n            $this->logger->info(LogMessage::fromString($logMessage));\n            $this->logger->error($throwable);\n            return ErrorResponse::unauthorized($this->url, $throwable);\n        }\n        return UnauthorizedResponse::noRights($this->url);\n    }\n    private function getLogMessage(?UserName $userName): string\n    {\n        if ($userName instanceof UserName) {\n            return 'Could not authenticate manager: ' . $userName->asString();\n        }\n        return 'Could not authenticate manager without user name.';\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\response\\UnauthorizedResponse;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\shared\\responses\\ErrorResponse;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface as RequestHandler;\nuse Throwable;\nclass Authorization implements MiddlewareInterface\n{\n    public function __construct(private readonly Logger $logger, private readonly UsersReader $usersReader, private readonly Url $url)\n    {\n    }\n    public function process(Request $request, RequestHandler $handler): ResponseInterface\n    {\n        $userName = null;\n        try {\n            if (Session::isValidManager()) {\n                $userName = Session::getUserName();\n                $this->usersReader->isActiveManager($userName);\n                $logMessage = LogMessage::fromString('Authenticated manager: ' . $userName->asString());\n                $this->logger->info($logMessage);\n                return $handler->handle($request);\n            }\n        } catch (Throwable $throwable) {\n            $logMessage = $this->getLogMessage($userName);\n            $this->logger->info(LogMessage::fromString($logMessage));\n            $this->logger->error($throwable);\n            return ErrorResponse::unauthorized($this->url, $throwable);\n        }\n        return UnauthorizedResponse::noRights($this->url);\n    }\n    private function getLogMessage(?UserName $userName): string\n    {\n        if ($userName instanceof UserName) {\n            return $userName->asString() . 'Could not authenticate manager: ';\n        }\n        return 'Could not authenticate manager without user name.';\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/Authorization.php","originalStartLine":58},"diff":"@@ @@\n     private function getLogMessage(?UserName $userName): string\n     {\n         if ($userName instanceof UserName) {\n-            return 'Could not authenticate manager: ' . $userName->asString();\n+            return $userName->asString() . 'Could not authenticate manager: ';\n         }\n         return 'Could not authenticate manager without user name.';\n     }\n }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.52ea19905fd72f474c7e839c5d6e9fe8.infection.xml\n\n...F\n\nTime: 00:00.007, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\AuthorizationTest::testCanHandleErrorIfUserNameExists\nExpectation failed for method name is \"info\" when invoked 1 time\nParameter 0 for invocation norsk\\api\\app\\logging\\Logger::info(norsk\\api\\app\\logging\\LogMessage Object (...)): void does not match expected value.\nFailed asserting that two objects are equal.\n--- Expected\n+++ Actual\n@@ @@\n norsk\\api\\app\\logging\\LogMessage Object (\n-    'message' => 'Could not authenticate manager: someUsername'\n+    'message' => 'someUsernameCould not authenticate manager: '\n )\n\n\/app\/api\/src\/app\/identityAccessManagement\/Authorization.php:36\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/AuthorizationTest.php:151\n\nFAILURES!\nTests: 4, Assertions: 18, Failures: 1."},{"mutator":{"mutatorName":"ConcatOperandRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\response\\UnauthorizedResponse;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\shared\\responses\\ErrorResponse;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface as RequestHandler;\nuse Throwable;\nclass Authorization implements MiddlewareInterface\n{\n    public function __construct(private readonly Logger $logger, private readonly UsersReader $usersReader, private readonly Url $url)\n    {\n    }\n    public function process(Request $request, RequestHandler $handler): ResponseInterface\n    {\n        $userName = null;\n        try {\n            if (Session::isValidManager()) {\n                $userName = Session::getUserName();\n                $this->usersReader->isActiveManager($userName);\n                $logMessage = LogMessage::fromString('Authenticated manager: ' . $userName->asString());\n                $this->logger->info($logMessage);\n                return $handler->handle($request);\n            }\n        } catch (Throwable $throwable) {\n            $logMessage = $this->getLogMessage($userName);\n            $this->logger->info(LogMessage::fromString($logMessage));\n            $this->logger->error($throwable);\n            return ErrorResponse::unauthorized($this->url, $throwable);\n        }\n        return UnauthorizedResponse::noRights($this->url);\n    }\n    private function getLogMessage(?UserName $userName): string\n    {\n        if ($userName instanceof UserName) {\n            return 'Could not authenticate manager: ' . $userName->asString();\n        }\n        return 'Could not authenticate manager without user name.';\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\response\\UnauthorizedResponse;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\shared\\responses\\ErrorResponse;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface as RequestHandler;\nuse Throwable;\nclass Authorization implements MiddlewareInterface\n{\n    public function __construct(private readonly Logger $logger, private readonly UsersReader $usersReader, private readonly Url $url)\n    {\n    }\n    public function process(Request $request, RequestHandler $handler): ResponseInterface\n    {\n        $userName = null;\n        try {\n            if (Session::isValidManager()) {\n                $userName = Session::getUserName();\n                $this->usersReader->isActiveManager($userName);\n                $logMessage = LogMessage::fromString('Authenticated manager: ' . $userName->asString());\n                $this->logger->info($logMessage);\n                return $handler->handle($request);\n            }\n        } catch (Throwable $throwable) {\n            $logMessage = $this->getLogMessage($userName);\n            $this->logger->info(LogMessage::fromString($logMessage));\n            $this->logger->error($throwable);\n            return ErrorResponse::unauthorized($this->url, $throwable);\n        }\n        return UnauthorizedResponse::noRights($this->url);\n    }\n    private function getLogMessage(?UserName $userName): string\n    {\n        if ($userName instanceof UserName) {\n            return $userName->asString();\n        }\n        return 'Could not authenticate manager without user name.';\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/Authorization.php","originalStartLine":58},"diff":"@@ @@\n     private function getLogMessage(?UserName $userName): string\n     {\n         if ($userName instanceof UserName) {\n-            return 'Could not authenticate manager: ' . $userName->asString();\n+            return $userName->asString();\n         }\n         return 'Could not authenticate manager without user name.';\n     }\n }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.cc12762ce8b9159f7cda632082540984.infection.xml\n\n...F\n\nTime: 00:00.007, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\AuthorizationTest::testCanHandleErrorIfUserNameExists\nExpectation failed for method name is \"info\" when invoked 1 time\nParameter 0 for invocation norsk\\api\\app\\logging\\Logger::info(norsk\\api\\app\\logging\\LogMessage Object (...)): void does not match expected value.\nFailed asserting that two objects are equal.\n--- Expected\n+++ Actual\n@@ @@\n norsk\\api\\app\\logging\\LogMessage Object (\n-    'message' => 'Could not authenticate manager: someUsername'\n+    'message' => 'someUsername'\n )\n\n\/app\/api\/src\/app\/identityAccessManagement\/Authorization.php:36\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/AuthorizationTest.php:151\n\nFAILURES!\nTests: 4, Assertions: 18, Failures: 1."},{"mutator":{"mutatorName":"ConcatOperandRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\response\\UnauthorizedResponse;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\shared\\responses\\ErrorResponse;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface as RequestHandler;\nuse Throwable;\nclass Authorization implements MiddlewareInterface\n{\n    public function __construct(private readonly Logger $logger, private readonly UsersReader $usersReader, private readonly Url $url)\n    {\n    }\n    public function process(Request $request, RequestHandler $handler): ResponseInterface\n    {\n        $userName = null;\n        try {\n            if (Session::isValidManager()) {\n                $userName = Session::getUserName();\n                $this->usersReader->isActiveManager($userName);\n                $logMessage = LogMessage::fromString('Authenticated manager: ' . $userName->asString());\n                $this->logger->info($logMessage);\n                return $handler->handle($request);\n            }\n        } catch (Throwable $throwable) {\n            $logMessage = $this->getLogMessage($userName);\n            $this->logger->info(LogMessage::fromString($logMessage));\n            $this->logger->error($throwable);\n            return ErrorResponse::unauthorized($this->url, $throwable);\n        }\n        return UnauthorizedResponse::noRights($this->url);\n    }\n    private function getLogMessage(?UserName $userName): string\n    {\n        if ($userName instanceof UserName) {\n            return 'Could not authenticate manager: ' . $userName->asString();\n        }\n        return 'Could not authenticate manager without user name.';\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\response\\UnauthorizedResponse;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\shared\\responses\\ErrorResponse;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface as RequestHandler;\nuse Throwable;\nclass Authorization implements MiddlewareInterface\n{\n    public function __construct(private readonly Logger $logger, private readonly UsersReader $usersReader, private readonly Url $url)\n    {\n    }\n    public function process(Request $request, RequestHandler $handler): ResponseInterface\n    {\n        $userName = null;\n        try {\n            if (Session::isValidManager()) {\n                $userName = Session::getUserName();\n                $this->usersReader->isActiveManager($userName);\n                $logMessage = LogMessage::fromString('Authenticated manager: ' . $userName->asString());\n                $this->logger->info($logMessage);\n                return $handler->handle($request);\n            }\n        } catch (Throwable $throwable) {\n            $logMessage = $this->getLogMessage($userName);\n            $this->logger->info(LogMessage::fromString($logMessage));\n            $this->logger->error($throwable);\n            return ErrorResponse::unauthorized($this->url, $throwable);\n        }\n        return UnauthorizedResponse::noRights($this->url);\n    }\n    private function getLogMessage(?UserName $userName): string\n    {\n        if ($userName instanceof UserName) {\n            return 'Could not authenticate manager: ';\n        }\n        return 'Could not authenticate manager without user name.';\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/Authorization.php","originalStartLine":58},"diff":"@@ @@\n     private function getLogMessage(?UserName $userName): string\n     {\n         if ($userName instanceof UserName) {\n-            return 'Could not authenticate manager: ' . $userName->asString();\n+            return 'Could not authenticate manager: ';\n         }\n         return 'Could not authenticate manager without user name.';\n     }\n }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.9b9d110796fb193979fb50d19147180e.infection.xml\n\n...F\n\nTime: 00:00.007, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\AuthorizationTest::testCanHandleErrorIfUserNameExists\nExpectation failed for method name is \"info\" when invoked 1 time\nParameter 0 for invocation norsk\\api\\app\\logging\\Logger::info(norsk\\api\\app\\logging\\LogMessage Object (...)): void does not match expected value.\nFailed asserting that two objects are equal.\n--- Expected\n+++ Actual\n@@ @@\n norsk\\api\\app\\logging\\LogMessage Object (\n-    'message' => 'Could not authenticate manager: someUsername'\n+    'message' => 'Could not authenticate manager: '\n )\n\n\/app\/api\/src\/app\/identityAccessManagement\/Authorization.php:36\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/AuthorizationTest.php:151\n\nFAILURES!\nTests: 4, Assertions: 18, Failures: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse DateTimeImmutable;\nuse DateTimeZone;\nuse Psr\\Clock\\ClockInterface;\nclass Clock implements ClockInterface\n{\n    private const string EUROPE_BERLIN = 'Europe\/Berlin';\n    public function __construct(private DateTimeImmutable $clock)\n    {\n        $this->clock = $clock->setTimezone(new DateTimeZone(self::EUROPE_BERLIN));\n    }\n    public function now(): DateTimeImmutable\n    {\n        return new DateTimeImmutable('now', new DateTimeZone(self::EUROPE_BERLIN));\n    }\n    public function addSeconds(int $seconds): self\n    {\n        $newTime = $this->clock->modify('+' . $seconds . ' seconds');\n        $newTime = $newTime->setTimezone(new DateTimeZone(self::EUROPE_BERLIN));\n        return new self($newTime);\n    }\n    public function getTimestamp(): int\n    {\n        return $this->clock->getTimestamp();\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse DateTimeImmutable;\nuse DateTimeZone;\nuse Psr\\Clock\\ClockInterface;\nclass Clock implements ClockInterface\n{\n    private const string EUROPE_BERLIN = 'Europe\/Berlin';\n    public function __construct(private DateTimeImmutable $clock)\n    {\n        $this->clock = $clock->setTimezone(new DateTimeZone(self::EUROPE_BERLIN));\n    }\n    public function now(): DateTimeImmutable\n    {\n        return new DateTimeImmutable('now', new DateTimeZone(self::EUROPE_BERLIN));\n    }\n    protected function addSeconds(int $seconds): self\n    {\n        $newTime = $this->clock->modify('+' . $seconds . ' seconds');\n        $newTime = $newTime->setTimezone(new DateTimeZone(self::EUROPE_BERLIN));\n        return new self($newTime);\n    }\n    public function getTimestamp(): int\n    {\n        return $this->clock->getTimestamp();\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/Clock.php","originalStartLine":28},"diff":"@@ @@\n     {\n         return new DateTimeImmutable('now', new DateTimeZone(self::EUROPE_BERLIN));\n     }\n-    public function addSeconds(int $seconds): self\n+    protected function addSeconds(int $seconds): self\n     {\n         $newTime = $this->clock->modify('+' . $seconds . ' seconds');\n         $newTime = $newTime->setTimezone(new DateTimeZone(self::EUROPE_BERLIN));","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.56a83679edaf0425ed99e357ce0b94be.infection.xml\n\n.E\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\ClockTest::testCanAddSecondsToTimestamp\nError: Call to protected method norsk\\api\\app\\identityAccessManagement\\Clock::addSeconds() from scope norsk\\api\\app\\identityAccessManagement\\ClockTest\n\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/ClockTest.php:30\n\nERRORS!\nTests: 2, Assertions: 1, Errors: 1."},{"mutator":{"mutatorName":"Concat","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse DateTimeImmutable;\nuse DateTimeZone;\nuse Psr\\Clock\\ClockInterface;\nclass Clock implements ClockInterface\n{\n    private const string EUROPE_BERLIN = 'Europe\/Berlin';\n    public function __construct(private DateTimeImmutable $clock)\n    {\n        $this->clock = $clock->setTimezone(new DateTimeZone(self::EUROPE_BERLIN));\n    }\n    public function now(): DateTimeImmutable\n    {\n        return new DateTimeImmutable('now', new DateTimeZone(self::EUROPE_BERLIN));\n    }\n    public function addSeconds(int $seconds): self\n    {\n        $newTime = $this->clock->modify('+' . $seconds . ' seconds');\n        $newTime = $newTime->setTimezone(new DateTimeZone(self::EUROPE_BERLIN));\n        return new self($newTime);\n    }\n    public function getTimestamp(): int\n    {\n        return $this->clock->getTimestamp();\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse DateTimeImmutable;\nuse DateTimeZone;\nuse Psr\\Clock\\ClockInterface;\nclass Clock implements ClockInterface\n{\n    private const string EUROPE_BERLIN = 'Europe\/Berlin';\n    public function __construct(private DateTimeImmutable $clock)\n    {\n        $this->clock = $clock->setTimezone(new DateTimeZone(self::EUROPE_BERLIN));\n    }\n    public function now(): DateTimeImmutable\n    {\n        return new DateTimeImmutable('now', new DateTimeZone(self::EUROPE_BERLIN));\n    }\n    public function addSeconds(int $seconds): self\n    {\n        $newTime = $this->clock->modify($seconds . '+' . ' seconds');\n        $newTime = $newTime->setTimezone(new DateTimeZone(self::EUROPE_BERLIN));\n        return new self($newTime);\n    }\n    public function getTimestamp(): int\n    {\n        return $this->clock->getTimestamp();\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/Clock.php","originalStartLine":30},"diff":"@@ @@\n     }\n     public function addSeconds(int $seconds): self\n     {\n-        $newTime = $this->clock->modify('+' . $seconds . ' seconds');\n+        $newTime = $this->clock->modify($seconds . '+' . ' seconds');\n         $newTime = $newTime->setTimezone(new DateTimeZone(self::EUROPE_BERLIN));\n         return new self($newTime);\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.c4aa8d65a9bb0cd7225f5ee9ffed5958.infection.xml\n\n.E\n\nTime: 00:00.001, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\ClockTest::testCanAddSecondsToTimestamp\nDateMalformedStringException: DateTimeImmutable::modify(): Failed to parse time string (7200+ seconds) at position 4 (+): Unexpected character\n\n\/app\/api\/src\/app\/identityAccessManagement\/Clock.php:22\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/ClockTest.php:30\n\nERRORS!\nTests: 2, Assertions: 1, Errors: 1."},{"mutator":{"mutatorName":"ConcatOperandRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse DateTimeImmutable;\nuse DateTimeZone;\nuse Psr\\Clock\\ClockInterface;\nclass Clock implements ClockInterface\n{\n    private const string EUROPE_BERLIN = 'Europe\/Berlin';\n    public function __construct(private DateTimeImmutable $clock)\n    {\n        $this->clock = $clock->setTimezone(new DateTimeZone(self::EUROPE_BERLIN));\n    }\n    public function now(): DateTimeImmutable\n    {\n        return new DateTimeImmutable('now', new DateTimeZone(self::EUROPE_BERLIN));\n    }\n    public function addSeconds(int $seconds): self\n    {\n        $newTime = $this->clock->modify('+' . $seconds . ' seconds');\n        $newTime = $newTime->setTimezone(new DateTimeZone(self::EUROPE_BERLIN));\n        return new self($newTime);\n    }\n    public function getTimestamp(): int\n    {\n        return $this->clock->getTimestamp();\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse DateTimeImmutable;\nuse DateTimeZone;\nuse Psr\\Clock\\ClockInterface;\nclass Clock implements ClockInterface\n{\n    private const string EUROPE_BERLIN = 'Europe\/Berlin';\n    public function __construct(private DateTimeImmutable $clock)\n    {\n        $this->clock = $clock->setTimezone(new DateTimeZone(self::EUROPE_BERLIN));\n    }\n    public function now(): DateTimeImmutable\n    {\n        return new DateTimeImmutable('now', new DateTimeZone(self::EUROPE_BERLIN));\n    }\n    public function addSeconds(int $seconds): self\n    {\n        $newTime = $this->clock->modify('+' . ' seconds');\n        $newTime = $newTime->setTimezone(new DateTimeZone(self::EUROPE_BERLIN));\n        return new self($newTime);\n    }\n    public function getTimestamp(): int\n    {\n        return $this->clock->getTimestamp();\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/Clock.php","originalStartLine":30},"diff":"@@ @@\n     }\n     public function addSeconds(int $seconds): self\n     {\n-        $newTime = $this->clock->modify('+' . $seconds . ' seconds');\n+        $newTime = $this->clock->modify('+' . ' seconds');\n         $newTime = $newTime->setTimezone(new DateTimeZone(self::EUROPE_BERLIN));\n         return new self($newTime);\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.53c091dcd3dadf75e28ba5cc3ca0ee15.infection.xml\n\n.E\n\nTime: 00:00.001, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\ClockTest::testCanAddSecondsToTimestamp\nDateMalformedStringException: DateTimeImmutable::modify(): Failed to parse time string (+ seconds) at position 0 (+): Unexpected character\n\n\/app\/api\/src\/app\/identityAccessManagement\/Clock.php:22\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/ClockTest.php:30\n\nERRORS!\nTests: 2, Assertions: 1, Errors: 1."},{"mutator":{"mutatorName":"Concat","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse DateTimeImmutable;\nuse DateTimeZone;\nuse Psr\\Clock\\ClockInterface;\nclass Clock implements ClockInterface\n{\n    private const string EUROPE_BERLIN = 'Europe\/Berlin';\n    public function __construct(private DateTimeImmutable $clock)\n    {\n        $this->clock = $clock->setTimezone(new DateTimeZone(self::EUROPE_BERLIN));\n    }\n    public function now(): DateTimeImmutable\n    {\n        return new DateTimeImmutable('now', new DateTimeZone(self::EUROPE_BERLIN));\n    }\n    public function addSeconds(int $seconds): self\n    {\n        $newTime = $this->clock->modify('+' . $seconds . ' seconds');\n        $newTime = $newTime->setTimezone(new DateTimeZone(self::EUROPE_BERLIN));\n        return new self($newTime);\n    }\n    public function getTimestamp(): int\n    {\n        return $this->clock->getTimestamp();\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse DateTimeImmutable;\nuse DateTimeZone;\nuse Psr\\Clock\\ClockInterface;\nclass Clock implements ClockInterface\n{\n    private const string EUROPE_BERLIN = 'Europe\/Berlin';\n    public function __construct(private DateTimeImmutable $clock)\n    {\n        $this->clock = $clock->setTimezone(new DateTimeZone(self::EUROPE_BERLIN));\n    }\n    public function now(): DateTimeImmutable\n    {\n        return new DateTimeImmutable('now', new DateTimeZone(self::EUROPE_BERLIN));\n    }\n    public function addSeconds(int $seconds): self\n    {\n        $newTime = $this->clock->modify('+' . ' seconds' . $seconds);\n        $newTime = $newTime->setTimezone(new DateTimeZone(self::EUROPE_BERLIN));\n        return new self($newTime);\n    }\n    public function getTimestamp(): int\n    {\n        return $this->clock->getTimestamp();\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/Clock.php","originalStartLine":30},"diff":"@@ @@\n     }\n     public function addSeconds(int $seconds): self\n     {\n-        $newTime = $this->clock->modify('+' . $seconds . ' seconds');\n+        $newTime = $this->clock->modify('+' . ' seconds' . $seconds);\n         $newTime = $newTime->setTimezone(new DateTimeZone(self::EUROPE_BERLIN));\n         return new self($newTime);\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.91143d6eb4d1c1512d8171b64ab30ce5.infection.xml\n\n.E\n\nTime: 00:00.001, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\ClockTest::testCanAddSecondsToTimestamp\nDateMalformedStringException: DateTimeImmutable::modify(): Failed to parse time string (+ seconds7200) at position 0 (+): Unexpected character\n\n\/app\/api\/src\/app\/identityAccessManagement\/Clock.php:22\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/ClockTest.php:30\n\nERRORS!\nTests: 2, Assertions: 1, Errors: 1."},{"mutator":{"mutatorName":"ConcatOperandRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse DateTimeImmutable;\nuse DateTimeZone;\nuse Psr\\Clock\\ClockInterface;\nclass Clock implements ClockInterface\n{\n    private const string EUROPE_BERLIN = 'Europe\/Berlin';\n    public function __construct(private DateTimeImmutable $clock)\n    {\n        $this->clock = $clock->setTimezone(new DateTimeZone(self::EUROPE_BERLIN));\n    }\n    public function now(): DateTimeImmutable\n    {\n        return new DateTimeImmutable('now', new DateTimeZone(self::EUROPE_BERLIN));\n    }\n    public function addSeconds(int $seconds): self\n    {\n        $newTime = $this->clock->modify('+' . $seconds . ' seconds');\n        $newTime = $newTime->setTimezone(new DateTimeZone(self::EUROPE_BERLIN));\n        return new self($newTime);\n    }\n    public function getTimestamp(): int\n    {\n        return $this->clock->getTimestamp();\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse DateTimeImmutable;\nuse DateTimeZone;\nuse Psr\\Clock\\ClockInterface;\nclass Clock implements ClockInterface\n{\n    private const string EUROPE_BERLIN = 'Europe\/Berlin';\n    public function __construct(private DateTimeImmutable $clock)\n    {\n        $this->clock = $clock->setTimezone(new DateTimeZone(self::EUROPE_BERLIN));\n    }\n    public function now(): DateTimeImmutable\n    {\n        return new DateTimeImmutable('now', new DateTimeZone(self::EUROPE_BERLIN));\n    }\n    public function addSeconds(int $seconds): self\n    {\n        $newTime = $this->clock->modify('+' . $seconds);\n        $newTime = $newTime->setTimezone(new DateTimeZone(self::EUROPE_BERLIN));\n        return new self($newTime);\n    }\n    public function getTimestamp(): int\n    {\n        return $this->clock->getTimestamp();\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/Clock.php","originalStartLine":30},"diff":"@@ @@\n     }\n     public function addSeconds(int $seconds): self\n     {\n-        $newTime = $this->clock->modify('+' . $seconds . ' seconds');\n+        $newTime = $this->clock->modify('+' . $seconds);\n         $newTime = $newTime->setTimezone(new DateTimeZone(self::EUROPE_BERLIN));\n         return new self($newTime);\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.9904a1a801db2ab0d88f2fea3e657e43.infection.xml\n\n.E\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\ClockTest::testCanAddSecondsToTimestamp\nDateMalformedStringException: DateTimeImmutable::modify(): Failed to parse time string (+7200) at position 4 (0): Unexpected character\n\n\/app\/api\/src\/app\/identityAccessManagement\/Clock.php:22\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/ClockTest.php:30\n\nERRORS!\nTests: 2, Assertions: 1, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse DateTimeImmutable;\nuse DateTimeZone;\nuse Psr\\Clock\\ClockInterface;\nclass Clock implements ClockInterface\n{\n    private const string EUROPE_BERLIN = 'Europe\/Berlin';\n    public function __construct(private DateTimeImmutable $clock)\n    {\n        $this->clock = $clock->setTimezone(new DateTimeZone(self::EUROPE_BERLIN));\n    }\n    public function now(): DateTimeImmutable\n    {\n        return new DateTimeImmutable('now', new DateTimeZone(self::EUROPE_BERLIN));\n    }\n    public function addSeconds(int $seconds): self\n    {\n        $newTime = $this->clock->modify('+' . $seconds . ' seconds');\n        $newTime = $newTime->setTimezone(new DateTimeZone(self::EUROPE_BERLIN));\n        return new self($newTime);\n    }\n    public function getTimestamp(): int\n    {\n        return $this->clock->getTimestamp();\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse DateTimeImmutable;\nuse DateTimeZone;\nuse Psr\\Clock\\ClockInterface;\nclass Clock implements ClockInterface\n{\n    private const string EUROPE_BERLIN = 'Europe\/Berlin';\n    public function __construct(private DateTimeImmutable $clock)\n    {\n        $this->clock = $clock->setTimezone(new DateTimeZone(self::EUROPE_BERLIN));\n    }\n    public function now(): DateTimeImmutable\n    {\n        return new DateTimeImmutable('now', new DateTimeZone(self::EUROPE_BERLIN));\n    }\n    public function addSeconds(int $seconds): self\n    {\n        $newTime = $this->clock->modify('+' . $seconds . ' seconds');\n        $newTime = $newTime->setTimezone(new DateTimeZone(self::EUROPE_BERLIN));\n        return new self($newTime);\n    }\n    protected function getTimestamp(): int\n    {\n        return $this->clock->getTimestamp();\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/Clock.php","originalStartLine":37},"diff":"@@ @@\n         $newTime = $newTime->setTimezone(new DateTimeZone(self::EUROPE_BERLIN));\n         return new self($newTime);\n     }\n-    public function getTimestamp(): int\n+    protected function getTimestamp(): int\n     {\n         return $this->clock->getTimestamp();\n     }\n }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.31e0e219ec003feced77feaef41c9ea5.infection.xml\n\nE\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\ClockTest::testCanGetTimestamp\nError: Call to protected method norsk\\api\\app\\identityAccessManagement\\Clock::getTimestamp() from scope norsk\\api\\app\\identityAccessManagement\\ClockTest\n\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/ClockTest.php:22\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse DateTimeImmutable;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\UsersReader;\nreadonly class IdentityAccessManagementFactory\n{\n    public function __construct(private AppConfig $appConfig, private Logger $logger, private UsersReader $usersReader, private Url $url)\n    {\n    }\n    public function createAuthorization(): Authorization\n    {\n        return new Authorization($this->logger, $this->usersReader, $this->url);\n    }\n    public function createAuthentication(Session $session): Authentication\n    {\n        return new Authentication($this->createJwtManagement(), $session, $this->url);\n    }\n    public function createJwtManagement(): JwtManagement\n    {\n        return new JwtManagement($this->appConfig, $this->createClock(), $this->logger, $this->usersReader);\n    }\n    private function createClock(): Clock\n    {\n        return new Clock(new DateTimeImmutable('now'));\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse DateTimeImmutable;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\UsersReader;\nreadonly class IdentityAccessManagementFactory\n{\n    public function __construct(private AppConfig $appConfig, private Logger $logger, private UsersReader $usersReader, private Url $url)\n    {\n    }\n    protected function createAuthorization(): Authorization\n    {\n        return new Authorization($this->logger, $this->usersReader, $this->url);\n    }\n    public function createAuthentication(Session $session): Authentication\n    {\n        return new Authentication($this->createJwtManagement(), $session, $this->url);\n    }\n    public function createJwtManagement(): JwtManagement\n    {\n        return new JwtManagement($this->appConfig, $this->createClock(), $this->logger, $this->usersReader);\n    }\n    private function createClock(): Clock\n    {\n        return new Clock(new DateTimeImmutable('now'));\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/IdentityAccessManagementFactory.php","originalStartLine":24},"diff":"@@ @@\n     public function __construct(private AppConfig $appConfig, private Logger $logger, private UsersReader $usersReader, private Url $url)\n     {\n     }\n-    public function createAuthorization(): Authorization\n+    protected function createAuthorization(): Authorization\n     {\n         return new Authorization($this->logger, $this->usersReader, $this->url);\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.07f775254ea5609d9ded7282509b5ea2.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\IdentityAccessManagementFactoryTest::testCanCreateAuthorization\nError: Call to protected method norsk\\api\\app\\identityAccessManagement\\IdentityAccessManagementFactory::createAuthorization() from scope norsk\\api\\app\\identityAccessManagement\\IdentityAccessManagementFactoryTest\n\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/IdentityAccessManagementFactoryTest.php:32\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse DateTimeImmutable;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\UsersReader;\nreadonly class IdentityAccessManagementFactory\n{\n    public function __construct(private AppConfig $appConfig, private Logger $logger, private UsersReader $usersReader, private Url $url)\n    {\n    }\n    public function createAuthorization(): Authorization\n    {\n        return new Authorization($this->logger, $this->usersReader, $this->url);\n    }\n    public function createAuthentication(Session $session): Authentication\n    {\n        return new Authentication($this->createJwtManagement(), $session, $this->url);\n    }\n    public function createJwtManagement(): JwtManagement\n    {\n        return new JwtManagement($this->appConfig, $this->createClock(), $this->logger, $this->usersReader);\n    }\n    private function createClock(): Clock\n    {\n        return new Clock(new DateTimeImmutable('now'));\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse DateTimeImmutable;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\UsersReader;\nreadonly class IdentityAccessManagementFactory\n{\n    public function __construct(private AppConfig $appConfig, private Logger $logger, private UsersReader $usersReader, private Url $url)\n    {\n    }\n    public function createAuthorization(): Authorization\n    {\n        return new Authorization($this->logger, $this->usersReader, $this->url);\n    }\n    protected function createAuthentication(Session $session): Authentication\n    {\n        return new Authentication($this->createJwtManagement(), $session, $this->url);\n    }\n    public function createJwtManagement(): JwtManagement\n    {\n        return new JwtManagement($this->appConfig, $this->createClock(), $this->logger, $this->usersReader);\n    }\n    private function createClock(): Clock\n    {\n        return new Clock(new DateTimeImmutable('now'));\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/IdentityAccessManagementFactory.php","originalStartLine":30},"diff":"@@ @@\n     {\n         return new Authorization($this->logger, $this->usersReader, $this->url);\n     }\n-    public function createAuthentication(Session $session): Authentication\n+    protected function createAuthentication(Session $session): Authentication\n     {\n         return new Authentication($this->createJwtManagement(), $session, $this->url);\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.f6e98a10c01fd3ee709bbc8ad71aa3bb.infection.xml\n\n.E\n\nTime: 00:00.003, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\IdentityAccessManagementFactoryTest::testCanCreateAuthentication\nError: Call to protected method norsk\\api\\app\\identityAccessManagement\\IdentityAccessManagementFactory::createAuthentication() from scope norsk\\api\\app\\identityAccessManagement\\IdentityAccessManagementFactoryTest\n\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/IdentityAccessManagementFactoryTest.php:39\n\nERRORS!\nTests: 2, Assertions: 1, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse DateTimeImmutable;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\UsersReader;\nreadonly class IdentityAccessManagementFactory\n{\n    public function __construct(private AppConfig $appConfig, private Logger $logger, private UsersReader $usersReader, private Url $url)\n    {\n    }\n    public function createAuthorization(): Authorization\n    {\n        return new Authorization($this->logger, $this->usersReader, $this->url);\n    }\n    public function createAuthentication(Session $session): Authentication\n    {\n        return new Authentication($this->createJwtManagement(), $session, $this->url);\n    }\n    public function createJwtManagement(): JwtManagement\n    {\n        return new JwtManagement($this->appConfig, $this->createClock(), $this->logger, $this->usersReader);\n    }\n    private function createClock(): Clock\n    {\n        return new Clock(new DateTimeImmutable('now'));\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse DateTimeImmutable;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\response\\Url;\nuse norsk\\api\\user\\UsersReader;\nreadonly class IdentityAccessManagementFactory\n{\n    public function __construct(private AppConfig $appConfig, private Logger $logger, private UsersReader $usersReader, private Url $url)\n    {\n    }\n    public function createAuthorization(): Authorization\n    {\n        return new Authorization($this->logger, $this->usersReader, $this->url);\n    }\n    public function createAuthentication(Session $session): Authentication\n    {\n        return new Authentication($this->createJwtManagement(), $session, $this->url);\n    }\n    protected function createJwtManagement(): JwtManagement\n    {\n        return new JwtManagement($this->appConfig, $this->createClock(), $this->logger, $this->usersReader);\n    }\n    private function createClock(): Clock\n    {\n        return new Clock(new DateTimeImmutable('now'));\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/IdentityAccessManagementFactory.php","originalStartLine":36},"diff":"@@ @@\n     {\n         return new Authentication($this->createJwtManagement(), $session, $this->url);\n     }\n-    public function createJwtManagement(): JwtManagement\n+    protected function createJwtManagement(): JwtManagement\n     {\n         return new JwtManagement($this->appConfig, $this->createClock(), $this->logger, $this->usersReader);\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.5bb8b56631132ae8a77d9430a8077b49.infection.xml\n\n..E                                                                 3 \/ 3 (100%)\n\nTime: 00:00.004, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\IdentityAccessManagementFactoryTest::testCanCreateJwtManagement\nError: Call to protected method norsk\\api\\app\\identityAccessManagement\\IdentityAccessManagementFactory::createJwtManagement() from scope norsk\\api\\app\\identityAccessManagement\\IdentityAccessManagementFactoryTest\n\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/IdentityAccessManagementFactoryTest.php:45\n\nERRORS!\nTests: 3, Assertions: 2, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nclass JsonWebToken\n{\n    private function __construct(private readonly string $token)\n    {\n    }\n    public static function fromString(string $token): self\n    {\n        self::ensureTokenIsJwtValid($token);\n        return new self($token);\n    }\n    private static function ensureTokenIsJwtValid(string $token): void\n    {\n        if (!preg_match(\"\/^([a-zA-Z0-9_=]{4,36})\\\\.([a-zA-Z0-9_=]{4,})\\\\.([a-zA-Z0-9_\\\\-+\\\\\/=]{4,86})\\$\/\", $token)) {\n            throw new InvalidArgumentException('Token has no valid format');\n        }\n    }\n    public static function fromBearerString(string $bearerToken): self\n    {\n        $jwtToken = str_replace('Bearer ', '', $bearerToken);\n        return new self($jwtToken);\n    }\n    public function asString(): string\n    {\n        return $this->token;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nclass JsonWebToken\n{\n    private function __construct(private readonly string $token)\n    {\n    }\n    protected static function fromString(string $token): self\n    {\n        self::ensureTokenIsJwtValid($token);\n        return new self($token);\n    }\n    private static function ensureTokenIsJwtValid(string $token): void\n    {\n        if (!preg_match(\"\/^([a-zA-Z0-9_=]{4,36})\\\\.([a-zA-Z0-9_=]{4,})\\\\.([a-zA-Z0-9_\\\\-+\\\\\/=]{4,86})\\$\/\", $token)) {\n            throw new InvalidArgumentException('Token has no valid format');\n        }\n    }\n    public static function fromBearerString(string $bearerToken): self\n    {\n        $jwtToken = str_replace('Bearer ', '', $bearerToken);\n        return new self($jwtToken);\n    }\n    public function asString(): string\n    {\n        return $this->token;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JsonWebToken.php","originalStartLine":16},"diff":"@@ @@\n     private function __construct(private readonly string $token)\n     {\n     }\n-    public static function fromString(string $token): self\n+    protected static function fromString(string $token): self\n     {\n         self::ensureTokenIsJwtValid($token);\n         return new self($token);","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.45ab2b62dd4b50b47a996cda1d279b4d.infection.xml\n\nE\n\nTime: 00:00.001, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\JsonWebTokenTest::testCanBeUsedAsStringFromPlainTokenString\nError: Call to protected method norsk\\api\\app\\identityAccessManagement\\JsonWebToken::fromString() from scope norsk\\api\\app\\identityAccessManagement\\JsonWebTokenTest\n\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JsonWebTokenTest.php:19\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nclass JsonWebToken\n{\n    private function __construct(private readonly string $token)\n    {\n    }\n    public static function fromString(string $token): self\n    {\n        self::ensureTokenIsJwtValid($token);\n        return new self($token);\n    }\n    private static function ensureTokenIsJwtValid(string $token): void\n    {\n        if (!preg_match(\"\/^([a-zA-Z0-9_=]{4,36})\\\\.([a-zA-Z0-9_=]{4,})\\\\.([a-zA-Z0-9_\\\\-+\\\\\/=]{4,86})\\$\/\", $token)) {\n            throw new InvalidArgumentException('Token has no valid format');\n        }\n    }\n    public static function fromBearerString(string $bearerToken): self\n    {\n        $jwtToken = str_replace('Bearer ', '', $bearerToken);\n        return new self($jwtToken);\n    }\n    public function asString(): string\n    {\n        return $this->token;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nclass JsonWebToken\n{\n    private function __construct(private readonly string $token)\n    {\n    }\n    public static function fromString(string $token): self\n    {\n        \n        return new self($token);\n    }\n    private static function ensureTokenIsJwtValid(string $token): void\n    {\n        if (!preg_match(\"\/^([a-zA-Z0-9_=]{4,36})\\\\.([a-zA-Z0-9_=]{4,})\\\\.([a-zA-Z0-9_\\\\-+\\\\\/=]{4,86})\\$\/\", $token)) {\n            throw new InvalidArgumentException('Token has no valid format');\n        }\n    }\n    public static function fromBearerString(string $bearerToken): self\n    {\n        $jwtToken = str_replace('Bearer ', '', $bearerToken);\n        return new self($jwtToken);\n    }\n    public function asString(): string\n    {\n        return $this->token;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JsonWebToken.php","originalStartLine":18},"diff":"@@ @@\n     }\n     public static function fromString(string $token): self\n     {\n-        self::ensureTokenIsJwtValid($token);\n+        \n         return new self($token);\n     }\n     private static function ensureTokenIsJwtValid(string $token): void","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.cf20de5bc1dd5af0ad7c6f3b87bd81b1.infection.xml\n\n.F\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JsonWebTokenTest::testThrowsExceptionIfTokenFormatIsNotJwt\nFailed asserting that exception of type \"InvalidArgumentException\" is thrown.\n\nFAILURES!\nTests: 2, Assertions: 2, Failures: 1."},{"mutator":{"mutatorName":"LogicalNot","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nclass JsonWebToken\n{\n    private function __construct(private readonly string $token)\n    {\n    }\n    public static function fromString(string $token): self\n    {\n        self::ensureTokenIsJwtValid($token);\n        return new self($token);\n    }\n    private static function ensureTokenIsJwtValid(string $token): void\n    {\n        if (!preg_match(\"\/^([a-zA-Z0-9_=]{4,36})\\\\.([a-zA-Z0-9_=]{4,})\\\\.([a-zA-Z0-9_\\\\-+\\\\\/=]{4,86})\\$\/\", $token)) {\n            throw new InvalidArgumentException('Token has no valid format');\n        }\n    }\n    public static function fromBearerString(string $bearerToken): self\n    {\n        $jwtToken = str_replace('Bearer ', '', $bearerToken);\n        return new self($jwtToken);\n    }\n    public function asString(): string\n    {\n        return $this->token;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nclass JsonWebToken\n{\n    private function __construct(private readonly string $token)\n    {\n    }\n    public static function fromString(string $token): self\n    {\n        self::ensureTokenIsJwtValid($token);\n        return new self($token);\n    }\n    private static function ensureTokenIsJwtValid(string $token): void\n    {\n        if (preg_match(\"\/^([a-zA-Z0-9_=]{4,36})\\\\.([a-zA-Z0-9_=]{4,})\\\\.([a-zA-Z0-9_\\\\-+\\\\\/=]{4,86})\\$\/\", $token)) {\n            throw new InvalidArgumentException('Token has no valid format');\n        }\n    }\n    public static function fromBearerString(string $bearerToken): self\n    {\n        $jwtToken = str_replace('Bearer ', '', $bearerToken);\n        return new self($jwtToken);\n    }\n    public function asString(): string\n    {\n        return $this->token;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JsonWebToken.php","originalStartLine":26},"diff":"@@ @@\n     }\n     private static function ensureTokenIsJwtValid(string $token): void\n     {\n-        if (!preg_match(\"\/^([a-zA-Z0-9_=]{4,36})\\\\.([a-zA-Z0-9_=]{4,})\\\\.([a-zA-Z0-9_\\\\-+\\\\\/=]{4,86})\\$\/\", $token)) {\n+        if (preg_match(\"\/^([a-zA-Z0-9_=]{4,36})\\\\.([a-zA-Z0-9_=]{4,})\\\\.([a-zA-Z0-9_\\\\-+\\\\\/=]{4,86})\\$\/\", $token)) {\n             throw new InvalidArgumentException('Token has no valid format');\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.e8c60201124be993089a5e0491da71e0.infection.xml\n\nE\n\nTime: 00:00.001, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\JsonWebTokenTest::testCanBeUsedAsStringFromPlainTokenString\nInvalidArgumentException: Token has no valid format\n\n\/app\/api\/src\/app\/identityAccessManagement\/JsonWebToken.php:20\n\/app\/api\/src\/app\/identityAccessManagement\/JsonWebToken.php:14\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JsonWebTokenTest.php:19\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Throw_","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nclass JsonWebToken\n{\n    private function __construct(private readonly string $token)\n    {\n    }\n    public static function fromString(string $token): self\n    {\n        self::ensureTokenIsJwtValid($token);\n        return new self($token);\n    }\n    private static function ensureTokenIsJwtValid(string $token): void\n    {\n        if (!preg_match(\"\/^([a-zA-Z0-9_=]{4,36})\\\\.([a-zA-Z0-9_=]{4,})\\\\.([a-zA-Z0-9_\\\\-+\\\\\/=]{4,86})\\$\/\", $token)) {\n            throw new InvalidArgumentException('Token has no valid format');\n        }\n    }\n    public static function fromBearerString(string $bearerToken): self\n    {\n        $jwtToken = str_replace('Bearer ', '', $bearerToken);\n        return new self($jwtToken);\n    }\n    public function asString(): string\n    {\n        return $this->token;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nclass JsonWebToken\n{\n    private function __construct(private readonly string $token)\n    {\n    }\n    public static function fromString(string $token): self\n    {\n        self::ensureTokenIsJwtValid($token);\n        return new self($token);\n    }\n    private static function ensureTokenIsJwtValid(string $token): void\n    {\n        if (!preg_match(\"\/^([a-zA-Z0-9_=]{4,36})\\\\.([a-zA-Z0-9_=]{4,})\\\\.([a-zA-Z0-9_\\\\-+\\\\\/=]{4,86})\\$\/\", $token)) {\n            new InvalidArgumentException('Token has no valid format');\n        }\n    }\n    public static function fromBearerString(string $bearerToken): self\n    {\n        $jwtToken = str_replace('Bearer ', '', $bearerToken);\n        return new self($jwtToken);\n    }\n    public function asString(): string\n    {\n        return $this->token;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JsonWebToken.php","originalStartLine":27},"diff":"@@ @@\n     private static function ensureTokenIsJwtValid(string $token): void\n     {\n         if (!preg_match(\"\/^([a-zA-Z0-9_=]{4,36})\\\\.([a-zA-Z0-9_=]{4,})\\\\.([a-zA-Z0-9_\\\\-+\\\\\/=]{4,86})\\$\/\", $token)) {\n-            throw new InvalidArgumentException('Token has no valid format');\n+            new InvalidArgumentException('Token has no valid format');\n         }\n     }\n     public static function fromBearerString(string $bearerToken): self","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.791a9d26bc1c75f02d28a213462bfed3.infection.xml\n\n.F\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JsonWebTokenTest::testThrowsExceptionIfTokenFormatIsNotJwt\nFailed asserting that exception of type \"InvalidArgumentException\" is thrown.\n\nFAILURES!\nTests: 2, Assertions: 2, Failures: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nclass JsonWebToken\n{\n    private function __construct(private readonly string $token)\n    {\n    }\n    public static function fromString(string $token): self\n    {\n        self::ensureTokenIsJwtValid($token);\n        return new self($token);\n    }\n    private static function ensureTokenIsJwtValid(string $token): void\n    {\n        if (!preg_match(\"\/^([a-zA-Z0-9_=]{4,36})\\\\.([a-zA-Z0-9_=]{4,})\\\\.([a-zA-Z0-9_\\\\-+\\\\\/=]{4,86})\\$\/\", $token)) {\n            throw new InvalidArgumentException('Token has no valid format');\n        }\n    }\n    public static function fromBearerString(string $bearerToken): self\n    {\n        $jwtToken = str_replace('Bearer ', '', $bearerToken);\n        return new self($jwtToken);\n    }\n    public function asString(): string\n    {\n        return $this->token;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nclass JsonWebToken\n{\n    private function __construct(private readonly string $token)\n    {\n    }\n    public static function fromString(string $token): self\n    {\n        self::ensureTokenIsJwtValid($token);\n        return new self($token);\n    }\n    private static function ensureTokenIsJwtValid(string $token): void\n    {\n        if (!preg_match(\"\/^([a-zA-Z0-9_=]{4,36})\\\\.([a-zA-Z0-9_=]{4,})\\\\.([a-zA-Z0-9_\\\\-+\\\\\/=]{4,86})\\$\/\", $token)) {\n            throw new InvalidArgumentException('Token has no valid format');\n        }\n    }\n    protected static function fromBearerString(string $bearerToken): self\n    {\n        $jwtToken = str_replace('Bearer ', '', $bearerToken);\n        return new self($jwtToken);\n    }\n    public function asString(): string\n    {\n        return $this->token;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JsonWebToken.php","originalStartLine":32},"diff":"@@ @@\n             throw new InvalidArgumentException('Token has no valid format');\n         }\n     }\n-    public static function fromBearerString(string $bearerToken): self\n+    protected static function fromBearerString(string $bearerToken): self\n     {\n         $jwtToken = str_replace('Bearer ', '', $bearerToken);\n         return new self($jwtToken);","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.603b6be43105b6d56528615dc8e75c76.infection.xml\n\n..E                                                                 3 \/ 3 (100%)\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\JsonWebTokenTest::testCanBeUsedAsStringFromBearerString\nError: Call to protected method norsk\\api\\app\\identityAccessManagement\\JsonWebToken::fromBearerString() from scope norsk\\api\\app\\identityAccessManagement\\JsonWebTokenTest\n\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JsonWebTokenTest.php:35\n\nERRORS!\nTests: 3, Assertions: 4, Errors: 1."},{"mutator":{"mutatorName":"UnwrapStrReplace","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nclass JsonWebToken\n{\n    private function __construct(private readonly string $token)\n    {\n    }\n    public static function fromString(string $token): self\n    {\n        self::ensureTokenIsJwtValid($token);\n        return new self($token);\n    }\n    private static function ensureTokenIsJwtValid(string $token): void\n    {\n        if (!preg_match(\"\/^([a-zA-Z0-9_=]{4,36})\\\\.([a-zA-Z0-9_=]{4,})\\\\.([a-zA-Z0-9_\\\\-+\\\\\/=]{4,86})\\$\/\", $token)) {\n            throw new InvalidArgumentException('Token has no valid format');\n        }\n    }\n    public static function fromBearerString(string $bearerToken): self\n    {\n        $jwtToken = str_replace('Bearer ', '', $bearerToken);\n        return new self($jwtToken);\n    }\n    public function asString(): string\n    {\n        return $this->token;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nclass JsonWebToken\n{\n    private function __construct(private readonly string $token)\n    {\n    }\n    public static function fromString(string $token): self\n    {\n        self::ensureTokenIsJwtValid($token);\n        return new self($token);\n    }\n    private static function ensureTokenIsJwtValid(string $token): void\n    {\n        if (!preg_match(\"\/^([a-zA-Z0-9_=]{4,36})\\\\.([a-zA-Z0-9_=]{4,})\\\\.([a-zA-Z0-9_\\\\-+\\\\\/=]{4,86})\\$\/\", $token)) {\n            throw new InvalidArgumentException('Token has no valid format');\n        }\n    }\n    public static function fromBearerString(string $bearerToken): self\n    {\n        $jwtToken = $bearerToken;\n        return new self($jwtToken);\n    }\n    public function asString(): string\n    {\n        return $this->token;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JsonWebToken.php","originalStartLine":34},"diff":"@@ @@\n     }\n     public static function fromBearerString(string $bearerToken): self\n     {\n-        $jwtToken = str_replace('Bearer ', '', $bearerToken);\n+        $jwtToken = $bearerToken;\n         return new self($jwtToken);\n     }\n     public function asString(): string","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.cbfbd8703e03937a2ce6876e45d02d81.infection.xml\n\n..F                                                                 3 \/ 3 (100%)\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JsonWebTokenTest::testCanBeUsedAsStringFromBearerString\nFailed asserting that two strings are identical.\n--- Expected\n+++ Actual\n@@ @@\n-'xzJhb.eyJzdWIicCI6MTY1NTIxODAwOX0.ceU31GO4x6QscCNHS4_6GDVq4A'\n+'Bearer xzJhb.eyJzdWIicCI6MTY1NTIxODAwOX0.ceU31GO4x6QscCNHS4_6GDVq4A'\n\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JsonWebTokenTest.php:35\n\nFAILURES!\nTests: 3, Assertions: 5, Failures: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nclass JsonWebToken\n{\n    private function __construct(private readonly string $token)\n    {\n    }\n    public static function fromString(string $token): self\n    {\n        self::ensureTokenIsJwtValid($token);\n        return new self($token);\n    }\n    private static function ensureTokenIsJwtValid(string $token): void\n    {\n        if (!preg_match(\"\/^([a-zA-Z0-9_=]{4,36})\\\\.([a-zA-Z0-9_=]{4,})\\\\.([a-zA-Z0-9_\\\\-+\\\\\/=]{4,86})\\$\/\", $token)) {\n            throw new InvalidArgumentException('Token has no valid format');\n        }\n    }\n    public static function fromBearerString(string $bearerToken): self\n    {\n        $jwtToken = str_replace('Bearer ', '', $bearerToken);\n        return new self($jwtToken);\n    }\n    public function asString(): string\n    {\n        return $this->token;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nclass JsonWebToken\n{\n    private function __construct(private readonly string $token)\n    {\n    }\n    public static function fromString(string $token): self\n    {\n        self::ensureTokenIsJwtValid($token);\n        return new self($token);\n    }\n    private static function ensureTokenIsJwtValid(string $token): void\n    {\n        if (!preg_match(\"\/^([a-zA-Z0-9_=]{4,36})\\\\.([a-zA-Z0-9_=]{4,})\\\\.([a-zA-Z0-9_\\\\-+\\\\\/=]{4,86})\\$\/\", $token)) {\n            throw new InvalidArgumentException('Token has no valid format');\n        }\n    }\n    public static function fromBearerString(string $bearerToken): self\n    {\n        $jwtToken = str_replace('Bearer ', '', $bearerToken);\n        return new self($jwtToken);\n    }\n    protected function asString(): string\n    {\n        return $this->token;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JsonWebToken.php","originalStartLine":40},"diff":"@@ @@\n         $jwtToken = str_replace('Bearer ', '', $bearerToken);\n         return new self($jwtToken);\n     }\n-    public function asString(): string\n+    protected function asString(): string\n     {\n         return $this->token;\n     }\n }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.ab1a6895b611ba6071b1ae8acb147132.infection.xml\n\nE\n\nTime: 00:00.001, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\JsonWebTokenTest::testCanBeUsedAsStringFromPlainTokenString\nError: Call to protected method norsk\\api\\app\\identityAccessManagement\\JsonWebToken::asString() from scope norsk\\api\\app\\identityAccessManagement\\JsonWebTokenTest\n\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JsonWebTokenTest.php:19\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nuse norsk\\api\\shared\\SanitizedClientInput;\nreadonly class JwtAudience\n{\n    private function __construct(private string $jwtAudience)\n    {\n    }\n    public static function by(string $jwtAudience): self\n    {\n        $trimmed = trim($jwtAudience);\n        self::ensureIsNotEmpty($trimmed);\n        return new self(SanitizedClientInput::of($trimmed)->asString());\n    }\n    private static function ensureIsNotEmpty(string $jwtAudience): void\n    {\n        if ($jwtAudience === '') {\n            throw new InvalidArgumentException('Audience in JWT cannot be empty.');\n        }\n    }\n    public function asString(): string\n    {\n        return $this->jwtAudience;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nuse norsk\\api\\shared\\SanitizedClientInput;\nreadonly class JwtAudience\n{\n    private function __construct(private string $jwtAudience)\n    {\n    }\n    protected static function by(string $jwtAudience): self\n    {\n        $trimmed = trim($jwtAudience);\n        self::ensureIsNotEmpty($trimmed);\n        return new self(SanitizedClientInput::of($trimmed)->asString());\n    }\n    private static function ensureIsNotEmpty(string $jwtAudience): void\n    {\n        if ($jwtAudience === '') {\n            throw new InvalidArgumentException('Audience in JWT cannot be empty.');\n        }\n    }\n    public function asString(): string\n    {\n        return $this->jwtAudience;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtAudience.php","originalStartLine":17},"diff":"@@ @@\n     private function __construct(private string $jwtAudience)\n     {\n     }\n-    public static function by(string $jwtAudience): self\n+    protected static function by(string $jwtAudience): self\n     {\n         $trimmed = trim($jwtAudience);\n         self::ensureIsNotEmpty($trimmed);","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.2d91cd6045b976f731e9207ba3b49848.infection.xml\n\nE\n\nTime: 00:00.001, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtAudienceTest::testCanBeUsedAsString\nError: Call to protected method norsk\\api\\app\\identityAccessManagement\\JwtAudience::by() from scope norsk\\api\\app\\identityAccessManagement\\JwtAudienceTest\n\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtAudienceTest.php:16\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"UnwrapTrim","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nuse norsk\\api\\shared\\SanitizedClientInput;\nreadonly class JwtAudience\n{\n    private function __construct(private string $jwtAudience)\n    {\n    }\n    public static function by(string $jwtAudience): self\n    {\n        $trimmed = trim($jwtAudience);\n        self::ensureIsNotEmpty($trimmed);\n        return new self(SanitizedClientInput::of($trimmed)->asString());\n    }\n    private static function ensureIsNotEmpty(string $jwtAudience): void\n    {\n        if ($jwtAudience === '') {\n            throw new InvalidArgumentException('Audience in JWT cannot be empty.');\n        }\n    }\n    public function asString(): string\n    {\n        return $this->jwtAudience;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nuse norsk\\api\\shared\\SanitizedClientInput;\nreadonly class JwtAudience\n{\n    private function __construct(private string $jwtAudience)\n    {\n    }\n    public static function by(string $jwtAudience): self\n    {\n        $trimmed = $jwtAudience;\n        self::ensureIsNotEmpty($trimmed);\n        return new self(SanitizedClientInput::of($trimmed)->asString());\n    }\n    private static function ensureIsNotEmpty(string $jwtAudience): void\n    {\n        if ($jwtAudience === '') {\n            throw new InvalidArgumentException('Audience in JWT cannot be empty.');\n        }\n    }\n    public function asString(): string\n    {\n        return $this->jwtAudience;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtAudience.php","originalStartLine":19},"diff":"@@ @@\n     }\n     public static function by(string $jwtAudience): self\n     {\n-        $trimmed = trim($jwtAudience);\n+        $trimmed = $jwtAudience;\n         self::ensureIsNotEmpty($trimmed);\n         return new self(SanitizedClientInput::of($trimmed)->asString());\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.ce6024356b3280641a14084192e88b7f.infection.xml\n\n.F                                                                  2 \/ 2 (100%)\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtAudienceTest::testThrowsExceptionIfFirstNameIsEmpty\nFailed asserting that exception of type \"InvalidArgumentException\" is thrown.\n\nFAILURES!\nTests: 2, Assertions: 2, Failures: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nuse norsk\\api\\shared\\SanitizedClientInput;\nreadonly class JwtAudience\n{\n    private function __construct(private string $jwtAudience)\n    {\n    }\n    public static function by(string $jwtAudience): self\n    {\n        $trimmed = trim($jwtAudience);\n        self::ensureIsNotEmpty($trimmed);\n        return new self(SanitizedClientInput::of($trimmed)->asString());\n    }\n    private static function ensureIsNotEmpty(string $jwtAudience): void\n    {\n        if ($jwtAudience === '') {\n            throw new InvalidArgumentException('Audience in JWT cannot be empty.');\n        }\n    }\n    public function asString(): string\n    {\n        return $this->jwtAudience;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nuse norsk\\api\\shared\\SanitizedClientInput;\nreadonly class JwtAudience\n{\n    private function __construct(private string $jwtAudience)\n    {\n    }\n    public static function by(string $jwtAudience): self\n    {\n        $trimmed = trim($jwtAudience);\n        \n        return new self(SanitizedClientInput::of($trimmed)->asString());\n    }\n    private static function ensureIsNotEmpty(string $jwtAudience): void\n    {\n        if ($jwtAudience === '') {\n            throw new InvalidArgumentException('Audience in JWT cannot be empty.');\n        }\n    }\n    public function asString(): string\n    {\n        return $this->jwtAudience;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtAudience.php","originalStartLine":21},"diff":"@@ @@\n     public static function by(string $jwtAudience): self\n     {\n         $trimmed = trim($jwtAudience);\n-        self::ensureIsNotEmpty($trimmed);\n+        \n         return new self(SanitizedClientInput::of($trimmed)->asString());\n     }\n     private static function ensureIsNotEmpty(string $jwtAudience): void","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.a9412f493a1a8b50f289fbf034414537.infection.xml\n\n.F                                                                  2 \/ 2 (100%)\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtAudienceTest::testThrowsExceptionIfFirstNameIsEmpty\nFailed asserting that exception of type \"InvalidArgumentException\" is thrown.\n\nFAILURES!\nTests: 2, Assertions: 2, Failures: 1."},{"mutator":{"mutatorName":"Identical","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nuse norsk\\api\\shared\\SanitizedClientInput;\nreadonly class JwtAudience\n{\n    private function __construct(private string $jwtAudience)\n    {\n    }\n    public static function by(string $jwtAudience): self\n    {\n        $trimmed = trim($jwtAudience);\n        self::ensureIsNotEmpty($trimmed);\n        return new self(SanitizedClientInput::of($trimmed)->asString());\n    }\n    private static function ensureIsNotEmpty(string $jwtAudience): void\n    {\n        if ($jwtAudience === '') {\n            throw new InvalidArgumentException('Audience in JWT cannot be empty.');\n        }\n    }\n    public function asString(): string\n    {\n        return $this->jwtAudience;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nuse norsk\\api\\shared\\SanitizedClientInput;\nreadonly class JwtAudience\n{\n    private function __construct(private string $jwtAudience)\n    {\n    }\n    public static function by(string $jwtAudience): self\n    {\n        $trimmed = trim($jwtAudience);\n        self::ensureIsNotEmpty($trimmed);\n        return new self(SanitizedClientInput::of($trimmed)->asString());\n    }\n    private static function ensureIsNotEmpty(string $jwtAudience): void\n    {\n        if ($jwtAudience !== '') {\n            throw new InvalidArgumentException('Audience in JWT cannot be empty.');\n        }\n    }\n    public function asString(): string\n    {\n        return $this->jwtAudience;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtAudience.php","originalStartLine":29},"diff":"@@ @@\n     }\n     private static function ensureIsNotEmpty(string $jwtAudience): void\n     {\n-        if ($jwtAudience === '') {\n+        if ($jwtAudience !== '') {\n             throw new InvalidArgumentException('Audience in JWT cannot be empty.');\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.dae3b03ab50a0541964ae1f07a2207f3.infection.xml\n\nE\n\nTime: 00:00.001, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtAudienceTest::testCanBeUsedAsString\nInvalidArgumentException: Audience in JWT cannot be empty.\n\n\/app\/api\/src\/app\/identityAccessManagement\/JwtAudience.php:22\n\/app\/api\/src\/app\/identityAccessManagement\/JwtAudience.php:16\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtAudienceTest.php:16\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Throw_","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nuse norsk\\api\\shared\\SanitizedClientInput;\nreadonly class JwtAudience\n{\n    private function __construct(private string $jwtAudience)\n    {\n    }\n    public static function by(string $jwtAudience): self\n    {\n        $trimmed = trim($jwtAudience);\n        self::ensureIsNotEmpty($trimmed);\n        return new self(SanitizedClientInput::of($trimmed)->asString());\n    }\n    private static function ensureIsNotEmpty(string $jwtAudience): void\n    {\n        if ($jwtAudience === '') {\n            throw new InvalidArgumentException('Audience in JWT cannot be empty.');\n        }\n    }\n    public function asString(): string\n    {\n        return $this->jwtAudience;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nuse norsk\\api\\shared\\SanitizedClientInput;\nreadonly class JwtAudience\n{\n    private function __construct(private string $jwtAudience)\n    {\n    }\n    public static function by(string $jwtAudience): self\n    {\n        $trimmed = trim($jwtAudience);\n        self::ensureIsNotEmpty($trimmed);\n        return new self(SanitizedClientInput::of($trimmed)->asString());\n    }\n    private static function ensureIsNotEmpty(string $jwtAudience): void\n    {\n        if ($jwtAudience === '') {\n            new InvalidArgumentException('Audience in JWT cannot be empty.');\n        }\n    }\n    public function asString(): string\n    {\n        return $this->jwtAudience;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtAudience.php","originalStartLine":30},"diff":"@@ @@\n     private static function ensureIsNotEmpty(string $jwtAudience): void\n     {\n         if ($jwtAudience === '') {\n-            throw new InvalidArgumentException('Audience in JWT cannot be empty.');\n+            new InvalidArgumentException('Audience in JWT cannot be empty.');\n         }\n     }\n     public function asString(): string","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.f6d02f1d22b69e233a55fa37df4fcebf.infection.xml\n\n.F                                                                  2 \/ 2 (100%)\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtAudienceTest::testThrowsExceptionIfFirstNameIsEmpty\nFailed asserting that exception of type \"InvalidArgumentException\" is thrown.\n\nFAILURES!\nTests: 2, Assertions: 2, Failures: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nuse norsk\\api\\shared\\SanitizedClientInput;\nreadonly class JwtAudience\n{\n    private function __construct(private string $jwtAudience)\n    {\n    }\n    public static function by(string $jwtAudience): self\n    {\n        $trimmed = trim($jwtAudience);\n        self::ensureIsNotEmpty($trimmed);\n        return new self(SanitizedClientInput::of($trimmed)->asString());\n    }\n    private static function ensureIsNotEmpty(string $jwtAudience): void\n    {\n        if ($jwtAudience === '') {\n            throw new InvalidArgumentException('Audience in JWT cannot be empty.');\n        }\n    }\n    public function asString(): string\n    {\n        return $this->jwtAudience;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nuse norsk\\api\\shared\\SanitizedClientInput;\nreadonly class JwtAudience\n{\n    private function __construct(private string $jwtAudience)\n    {\n    }\n    public static function by(string $jwtAudience): self\n    {\n        $trimmed = trim($jwtAudience);\n        self::ensureIsNotEmpty($trimmed);\n        return new self(SanitizedClientInput::of($trimmed)->asString());\n    }\n    private static function ensureIsNotEmpty(string $jwtAudience): void\n    {\n        if ($jwtAudience === '') {\n            throw new InvalidArgumentException('Audience in JWT cannot be empty.');\n        }\n    }\n    protected function asString(): string\n    {\n        return $this->jwtAudience;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtAudience.php","originalStartLine":35},"diff":"@@ @@\n             throw new InvalidArgumentException('Audience in JWT cannot be empty.');\n         }\n     }\n-    public function asString(): string\n+    protected function asString(): string\n     {\n         return $this->jwtAudience;\n     }\n }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.c5d6bbaa497efd571d76dec4b4a7197d.infection.xml\n\nE\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtAudienceTest::testCanBeUsedAsString\nError: Call to protected method norsk\\api\\app\\identityAccessManagement\\JwtAudience::asString() from scope norsk\\api\\app\\identityAccessManagement\\JwtAudienceTest\n\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtAudienceTest.php:16\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nreadonly class JwtConfig\n{\n    private function __construct(private AuthenticationKey $authKey, private AuthenticationAlgorithm $algorithm, private JwtSubject $subject, private JwtAudience $audience)\n    {\n    }\n    public static function fromCredentials(AuthenticationKey $authKey, AuthenticationAlgorithm $algorithm, JwtSubject $subject, JwtAudience $audience): self\n    {\n        return new self($authKey, $algorithm, $subject, $audience);\n    }\n    public function getAuthKey(): AuthenticationKey\n    {\n        return $this->authKey;\n    }\n    public function getAlgorithm(): AuthenticationAlgorithm\n    {\n        return $this->algorithm;\n    }\n    public function getSubject(): JwtSubject\n    {\n        return $this->subject;\n    }\n    public function getAudience(): JwtAudience\n    {\n        return $this->audience;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nreadonly class JwtConfig\n{\n    private function __construct(private AuthenticationKey $authKey, private AuthenticationAlgorithm $algorithm, private JwtSubject $subject, private JwtAudience $audience)\n    {\n    }\n    protected static function fromCredentials(AuthenticationKey $authKey, AuthenticationAlgorithm $algorithm, JwtSubject $subject, JwtAudience $audience): self\n    {\n        return new self($authKey, $algorithm, $subject, $audience);\n    }\n    public function getAuthKey(): AuthenticationKey\n    {\n        return $this->authKey;\n    }\n    public function getAlgorithm(): AuthenticationAlgorithm\n    {\n        return $this->algorithm;\n    }\n    public function getSubject(): JwtSubject\n    {\n        return $this->subject;\n    }\n    public function getAudience(): JwtAudience\n    {\n        return $this->audience;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtConfig.php","originalStartLine":18},"diff":"@@ @@\n     private function __construct(private AuthenticationKey $authKey, private AuthenticationAlgorithm $algorithm, private JwtSubject $subject, private JwtAudience $audience)\n     {\n     }\n-    public static function fromCredentials(AuthenticationKey $authKey, AuthenticationAlgorithm $algorithm, JwtSubject $subject, JwtAudience $audience): self\n+    protected static function fromCredentials(AuthenticationKey $authKey, AuthenticationAlgorithm $algorithm, JwtSubject $subject, JwtAudience $audience): self\n     {\n         return new self($authKey, $algorithm, $subject, $audience);\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.47d5c56eea1b15412d7e412dea070d0c.infection.xml\n\nE\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtConfigTest::testCanGetAlgorithm\nError: Call to protected method norsk\\api\\app\\identityAccessManagement\\JwtConfig::fromCredentials() from scope norsk\\api\\app\\identityAccessManagement\\JwtConfigTest\n\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtConfigTest.php:67\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nreadonly class JwtConfig\n{\n    private function __construct(private AuthenticationKey $authKey, private AuthenticationAlgorithm $algorithm, private JwtSubject $subject, private JwtAudience $audience)\n    {\n    }\n    public static function fromCredentials(AuthenticationKey $authKey, AuthenticationAlgorithm $algorithm, JwtSubject $subject, JwtAudience $audience): self\n    {\n        return new self($authKey, $algorithm, $subject, $audience);\n    }\n    public function getAuthKey(): AuthenticationKey\n    {\n        return $this->authKey;\n    }\n    public function getAlgorithm(): AuthenticationAlgorithm\n    {\n        return $this->algorithm;\n    }\n    public function getSubject(): JwtSubject\n    {\n        return $this->subject;\n    }\n    public function getAudience(): JwtAudience\n    {\n        return $this->audience;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nreadonly class JwtConfig\n{\n    private function __construct(private AuthenticationKey $authKey, private AuthenticationAlgorithm $algorithm, private JwtSubject $subject, private JwtAudience $audience)\n    {\n    }\n    public static function fromCredentials(AuthenticationKey $authKey, AuthenticationAlgorithm $algorithm, JwtSubject $subject, JwtAudience $audience): self\n    {\n        return new self($authKey, $algorithm, $subject, $audience);\n    }\n    protected function getAuthKey(): AuthenticationKey\n    {\n        return $this->authKey;\n    }\n    public function getAlgorithm(): AuthenticationAlgorithm\n    {\n        return $this->algorithm;\n    }\n    public function getSubject(): JwtSubject\n    {\n        return $this->subject;\n    }\n    public function getAudience(): JwtAudience\n    {\n        return $this->audience;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtConfig.php","originalStartLine":28},"diff":"@@ @@\n     {\n         return new self($authKey, $algorithm, $subject, $audience);\n     }\n-    public function getAuthKey(): AuthenticationKey\n+    protected function getAuthKey(): AuthenticationKey\n     {\n         return $this->authKey;\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.8ace21e78001343bb6db35ea5bdfe4c2.infection.xml\n\n.E\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtConfigTest::testCanGetAuthKey\nError: Call to protected method norsk\\api\\app\\identityAccessManagement\\JwtConfig::getAuthKey() from scope norsk\\api\\app\\identityAccessManagement\\JwtConfigTest\n\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtConfigTest.php:37\n\nERRORS!\nTests: 2, Assertions: 1, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nreadonly class JwtConfig\n{\n    private function __construct(private AuthenticationKey $authKey, private AuthenticationAlgorithm $algorithm, private JwtSubject $subject, private JwtAudience $audience)\n    {\n    }\n    public static function fromCredentials(AuthenticationKey $authKey, AuthenticationAlgorithm $algorithm, JwtSubject $subject, JwtAudience $audience): self\n    {\n        return new self($authKey, $algorithm, $subject, $audience);\n    }\n    public function getAuthKey(): AuthenticationKey\n    {\n        return $this->authKey;\n    }\n    public function getAlgorithm(): AuthenticationAlgorithm\n    {\n        return $this->algorithm;\n    }\n    public function getSubject(): JwtSubject\n    {\n        return $this->subject;\n    }\n    public function getAudience(): JwtAudience\n    {\n        return $this->audience;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nreadonly class JwtConfig\n{\n    private function __construct(private AuthenticationKey $authKey, private AuthenticationAlgorithm $algorithm, private JwtSubject $subject, private JwtAudience $audience)\n    {\n    }\n    public static function fromCredentials(AuthenticationKey $authKey, AuthenticationAlgorithm $algorithm, JwtSubject $subject, JwtAudience $audience): self\n    {\n        return new self($authKey, $algorithm, $subject, $audience);\n    }\n    public function getAuthKey(): AuthenticationKey\n    {\n        return $this->authKey;\n    }\n    protected function getAlgorithm(): AuthenticationAlgorithm\n    {\n        return $this->algorithm;\n    }\n    public function getSubject(): JwtSubject\n    {\n        return $this->subject;\n    }\n    public function getAudience(): JwtAudience\n    {\n        return $this->audience;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtConfig.php","originalStartLine":34},"diff":"@@ @@\n     {\n         return $this->authKey;\n     }\n-    public function getAlgorithm(): AuthenticationAlgorithm\n+    protected function getAlgorithm(): AuthenticationAlgorithm\n     {\n         return $this->algorithm;\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.0da7d05c98c2643711c03c8782f6e492.infection.xml\n\nE\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtConfigTest::testCanGetAlgorithm\nError: Call to protected method norsk\\api\\app\\identityAccessManagement\\JwtConfig::getAlgorithm() from scope norsk\\api\\app\\identityAccessManagement\\JwtConfigTest\n\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtConfigTest.php:28\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nreadonly class JwtConfig\n{\n    private function __construct(private AuthenticationKey $authKey, private AuthenticationAlgorithm $algorithm, private JwtSubject $subject, private JwtAudience $audience)\n    {\n    }\n    public static function fromCredentials(AuthenticationKey $authKey, AuthenticationAlgorithm $algorithm, JwtSubject $subject, JwtAudience $audience): self\n    {\n        return new self($authKey, $algorithm, $subject, $audience);\n    }\n    public function getAuthKey(): AuthenticationKey\n    {\n        return $this->authKey;\n    }\n    public function getAlgorithm(): AuthenticationAlgorithm\n    {\n        return $this->algorithm;\n    }\n    public function getSubject(): JwtSubject\n    {\n        return $this->subject;\n    }\n    public function getAudience(): JwtAudience\n    {\n        return $this->audience;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nreadonly class JwtConfig\n{\n    private function __construct(private AuthenticationKey $authKey, private AuthenticationAlgorithm $algorithm, private JwtSubject $subject, private JwtAudience $audience)\n    {\n    }\n    public static function fromCredentials(AuthenticationKey $authKey, AuthenticationAlgorithm $algorithm, JwtSubject $subject, JwtAudience $audience): self\n    {\n        return new self($authKey, $algorithm, $subject, $audience);\n    }\n    public function getAuthKey(): AuthenticationKey\n    {\n        return $this->authKey;\n    }\n    public function getAlgorithm(): AuthenticationAlgorithm\n    {\n        return $this->algorithm;\n    }\n    protected function getSubject(): JwtSubject\n    {\n        return $this->subject;\n    }\n    public function getAudience(): JwtAudience\n    {\n        return $this->audience;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtConfig.php","originalStartLine":40},"diff":"@@ @@\n     {\n         return $this->algorithm;\n     }\n-    public function getSubject(): JwtSubject\n+    protected function getSubject(): JwtSubject\n     {\n         return $this->subject;\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.fccca3b67e5fbe1f8620648915b7fcb6.infection.xml\n\n..E\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtConfigTest::testCanGetSubject\nError: Call to protected method norsk\\api\\app\\identityAccessManagement\\JwtConfig::getSubject() from scope norsk\\api\\app\\identityAccessManagement\\JwtConfigTest\n\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtConfigTest.php:46\n\nERRORS!\nTests: 3, Assertions: 2, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nreadonly class JwtConfig\n{\n    private function __construct(private AuthenticationKey $authKey, private AuthenticationAlgorithm $algorithm, private JwtSubject $subject, private JwtAudience $audience)\n    {\n    }\n    public static function fromCredentials(AuthenticationKey $authKey, AuthenticationAlgorithm $algorithm, JwtSubject $subject, JwtAudience $audience): self\n    {\n        return new self($authKey, $algorithm, $subject, $audience);\n    }\n    public function getAuthKey(): AuthenticationKey\n    {\n        return $this->authKey;\n    }\n    public function getAlgorithm(): AuthenticationAlgorithm\n    {\n        return $this->algorithm;\n    }\n    public function getSubject(): JwtSubject\n    {\n        return $this->subject;\n    }\n    public function getAudience(): JwtAudience\n    {\n        return $this->audience;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nreadonly class JwtConfig\n{\n    private function __construct(private AuthenticationKey $authKey, private AuthenticationAlgorithm $algorithm, private JwtSubject $subject, private JwtAudience $audience)\n    {\n    }\n    public static function fromCredentials(AuthenticationKey $authKey, AuthenticationAlgorithm $algorithm, JwtSubject $subject, JwtAudience $audience): self\n    {\n        return new self($authKey, $algorithm, $subject, $audience);\n    }\n    public function getAuthKey(): AuthenticationKey\n    {\n        return $this->authKey;\n    }\n    public function getAlgorithm(): AuthenticationAlgorithm\n    {\n        return $this->algorithm;\n    }\n    public function getSubject(): JwtSubject\n    {\n        return $this->subject;\n    }\n    protected function getAudience(): JwtAudience\n    {\n        return $this->audience;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtConfig.php","originalStartLine":46},"diff":"@@ @@\n     {\n         return $this->subject;\n     }\n-    public function getAudience(): JwtAudience\n+    protected function getAudience(): JwtAudience\n     {\n         return $this->audience;\n     }\n }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.691781ce3ed0aa6284f3a7811d0559f2.infection.xml\n\n...E                                                                4 \/ 4 (100%)\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtConfigTest::testCanGetAudience\nError: Call to protected method norsk\\api\\app\\identityAccessManagement\\JwtConfig::getAudience() from scope norsk\\api\\app\\identityAccessManagement\\JwtConfigTest\n\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtConfigTest.php:55\n\nERRORS!\nTests: 4, Assertions: 3, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    protected function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":42},"diff":"@@ @@\n     public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n     {\n     }\n-    public function create(ValidatedUser $validatedUser): JsonWebToken\n+    protected function create(ValidatedUser $validatedUser): JsonWebToken\n     {\n         $role = $validatedUser->getRole();\n         $jwtConfig = $this->appConfig->getJwtConfig();","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.4e57a938d3eaf8e2dea8bef112ec2dd2.infection.xml\n\n........E\n\nTime: 00:00.013, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testCanCreateJwt\nError: Call to protected method norsk\\api\\app\\identityAccessManagement\\JwtManagement::create() from scope norsk\\api\\app\\identityAccessManagement\\JwtManagementTest\n\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtManagementTest.php:145\n\nERRORS!\nTests: 9, Assertions: 44, Errors: 1."},{"mutator":{"mutatorName":"ArrayItemRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":48},"diff":"@@ @@\n         $role = $validatedUser->getRole();\n         $jwtConfig = $this->appConfig->getJwtConfig();\n         $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n-        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n+        $payload = ['aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n         $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n         return JsonWebToken::fromString($jwt);\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.029451b2d3b6e5c01142741c0c625542.infection.xml\n\n........F\n\nTime: 00:00.013, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testCanCreateJwt\nJwt should be created\nFailed asserting that two objects are equal.\n--- Expected\n+++ Actual\n@@ @@\n norsk\\api\\app\\identityAccessManagement\\JsonWebToken Object (\n-    'token' => 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJub3JzayBhcHAiLCJhdWQiOiJOb3JzayBDbGllbnQiLCJpYXQiOjE3Mjc0NTg5MTIsImV4cCI6MTcyNzQ2NjExMiwic2NvcGUiOiJpczp1c2VyIiwibmlja25hbWUiOiIifQ.1cVB-zr8uAJ0ADp4ACOv-wxwlg8esC3xhfwPsdvqgNg'\n+    'token' => 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhdWQiOiJOb3JzayBDbGllbnQiLCJpYXQiOjE3Mjc0NTg5MTIsImV4cCI6MTcyNzQ2NjExMiwic2NvcGUiOiJpczp1c2VyIiwibmlja25hbWUiOiIifQ.zQNrWOfnhdLGSVYt70S0Sy0nQr8i1QzBg05Tyu94MKQ'\n )\n\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtManagementTest.php:147\n\nFAILURES!\nTests: 9, Assertions: 45, Failures: 1."},{"mutator":{"mutatorName":"ArrayItem","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' > $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":49},"diff":"@@ @@\n         $role = $validatedUser->getRole();\n         $jwtConfig = $this->appConfig->getJwtConfig();\n         $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n-        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n+        $payload = ['sub' > $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n         $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n         return JsonWebToken::fromString($jwt);\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.f48e53ec003ca409c3e9a3bb875afe2a.infection.xml\n\n........F\n\nTime: 00:00.013, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testCanCreateJwt\nJwt should be created\nFailed asserting that two objects are equal.\n--- Expected\n+++ Actual\n@@ @@\n norsk\\api\\app\\identityAccessManagement\\JsonWebToken Object (\n-    'token' => 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJub3JzayBhcHAiLCJhdWQiOiJOb3JzayBDbGllbnQiLCJpYXQiOjE3Mjc0NTg5MTIsImV4cCI6MTcyNzQ2NjExMiwic2NvcGUiOiJpczp1c2VyIiwibmlja25hbWUiOiIifQ.1cVB-zr8uAJ0ADp4ACOv-wxwlg8esC3xhfwPsdvqgNg'\n+    'token' => 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyIwIjp0cnVlLCJhdWQiOiJOb3JzayBDbGllbnQiLCJpYXQiOjE3Mjc0NTg5MTIsImV4cCI6MTcyNzQ2NjExMiwic2NvcGUiOiJpczp1c2VyIiwibmlja25hbWUiOiIifQ.euf7eFP7odXLmSWAuiAkB-4-g296VwYMF6sTStPIasM'\n )\n\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtManagementTest.php:147\n\nFAILURES!\nTests: 9, Assertions: 45, Failures: 1."},{"mutator":{"mutatorName":"ArrayItem","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' > $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":50},"diff":"@@ @@\n         $role = $validatedUser->getRole();\n         $jwtConfig = $this->appConfig->getJwtConfig();\n         $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n-        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n+        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' > $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n         $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n         return JsonWebToken::fromString($jwt);\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.34e6fa180e3fdae5d6c7995cbc4c8b6a.infection.xml\n\n........F\n\nTime: 00:00.012, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testCanCreateJwt\nJwt should be created\nFailed asserting that two objects are equal.\n--- Expected\n+++ Actual\n@@ @@\n norsk\\api\\app\\identityAccessManagement\\JsonWebToken Object (\n-    'token' => '...yJzdWIiOiJub3JzayBhcHAiLCJhdWQiOiJOb3JzayBDbGllbnQiLCJpYXQiOjE3Mjc0NTg5MTIsImV4cCI6MTcyNzQ2NjExMiwic2NvcGUiOiJpczp1c2VyIiwibmlja25hbWUiOiIifQ.1cVB-zr8uAJ0ADp4ACOv-wxwlg8esC3xhfwPsdvqgNg'\n+    'token' => '...yJzdWIiOiJub3JzayBhcHAiLCIwIjp0cnVlLCJpYXQiOjE3Mjc0NTg5MTIsImV4cCI6MTcyNzQ2NjExMiwic2NvcGUiOiJpczp1c2VyIiwibmlja25hbWUiOiIifQ.YdOgcyPMuRrMWQr8DsnF1YJZHyfK-Q98hdmIaoF9Q-4'\n )\n\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtManagementTest.php:147\n\nFAILURES!\nTests: 9, Assertions: 45, Failures: 1."},{"mutator":{"mutatorName":"ArrayItem","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' > $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":51},"diff":"@@ @@\n         $role = $validatedUser->getRole();\n         $jwtConfig = $this->appConfig->getJwtConfig();\n         $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n-        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n+        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' > $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n         $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n         return JsonWebToken::fromString($jwt);\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.e60dd1134ef60b09ad10f8bfd0deabed.infection.xml\n\n........F\n\nTime: 00:00.012, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testCanCreateJwt\nJwt should be created\nFailed asserting that two objects are equal.\n--- Expected\n+++ Actual\n@@ @@\n norsk\\api\\app\\identityAccessManagement\\JsonWebToken Object (\n-    'token' => '...WQiOiJOb3JzayBDbGllbnQiLCJpYXQiOjE3Mjc0NTg5MTIsImV4cCI6MTcyNzQ2NjExMiwic2NvcGUiOiJpczp1c2VyIiwibmlja25hbWUiOiIifQ.1cVB-zr8uAJ0ADp4ACOv-wxwlg8esC3xhfwPsdvqgNg'\n+    'token' => '...WQiOiJOb3JzayBDbGllbnQiLCIwIjp0cnVlLCJleHAiOjE3Mjc0NjYxMTIsInNjb3BlIjoiaXM6dXNlciIsIm5pY2tuYW1lIjoiIn0.jKPbjPQcJGhA8vBedfdgqjjNmtGqffRBi-tIbODnwWs'\n )\n\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtManagementTest.php:147\n\nFAILURES!\nTests: 9, Assertions: 45, Failures: 1."},{"mutator":{"mutatorName":"ArrayItem","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' > $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":52},"diff":"@@ @@\n         $role = $validatedUser->getRole();\n         $jwtConfig = $this->appConfig->getJwtConfig();\n         $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n-        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n+        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' > $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n         $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n         return JsonWebToken::fromString($jwt);\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.8d4acf38cd77ea3ea2ace854ba643ef4.infection.xml\n\n........F\n\nTime: 00:00.011, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testCanCreateJwt\nJwt should be created\nFailed asserting that two objects are equal.\n--- Expected\n+++ Actual\n@@ @@\n norsk\\api\\app\\identityAccessManagement\\JsonWebToken Object (\n-    'token' => '...LCJpYXQiOjE3Mjc0NTg5MTIsImV4cCI6MTcyNzQ2NjExMiwic2NvcGUiOiJpczp1c2VyIiwibmlja25hbWUiOiIifQ.1cVB-zr8uAJ0ADp4ACOv-wxwlg8esC3xhfwPsdvqgNg'\n+    'token' => '...LCJpYXQiOjE3Mjc0NTg5MTIsIjAiOnRydWUsInNjb3BlIjoiaXM6dXNlciIsIm5pY2tuYW1lIjoiIn0.GyFoOtMv1oWxl21YIiUWWeXFoVN9mdZ3DABZzlP0WCo'\n )\n\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtManagementTest.php:147\n\nFAILURES!\nTests: 9, Assertions: 45, Failures: 1."},{"mutator":{"mutatorName":"Concat","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => $role->value . \"is:\", 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":53},"diff":"@@ @@\n         $role = $validatedUser->getRole();\n         $jwtConfig = $this->appConfig->getJwtConfig();\n         $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n-        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n+        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => $role->value . \"is:\", 'nickname' => $validatedUser->getUsername()->asString()];\n         $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n         return JsonWebToken::fromString($jwt);\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.87ba774508127aaa3247e12246bb59bf.infection.xml\n\n........F\n\nTime: 00:00.011, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testCanCreateJwt\nJwt should be created\nFailed asserting that two objects are equal.\n--- Expected\n+++ Actual\n@@ @@\n norsk\\api\\app\\identityAccessManagement\\JsonWebToken Object (\n-    'token' => '...cyNzQ2NjExMiwic2NvcGUiOiJpczp1c2VyIiwibmlja25hbWUiOiIifQ.1cVB-zr8uAJ0ADp4ACOv-wxwlg8esC3xhfwPsdvqgNg'\n+    'token' => '...cyNzQ2NjExMiwic2NvcGUiOiJ1c2VyaXM6Iiwibmlja25hbWUiOiIifQ.0MVbQAA4poQVQCAhUUDlGF9HGwDj7vB61TGMyRTk64s'\n )\n\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtManagementTest.php:147\n\nFAILURES!\nTests: 9, Assertions: 45, Failures: 1."},{"mutator":{"mutatorName":"ConcatOperandRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":53},"diff":"@@ @@\n         $role = $validatedUser->getRole();\n         $jwtConfig = $this->appConfig->getJwtConfig();\n         $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n-        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n+        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n         $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n         return JsonWebToken::fromString($jwt);\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.9fc2b30e96b4ff0dcaa22d4eaa7116b9.infection.xml\n\n........F\n\nTime: 00:00.011, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testCanCreateJwt\nJwt should be created\nFailed asserting that two objects are equal.\n--- Expected\n+++ Actual\n@@ @@\n norsk\\api\\app\\identityAccessManagement\\JsonWebToken Object (\n-    'token' => '...cyNzQ2NjExMiwic2NvcGUiOiJpczp1c2VyIiwibmlja25hbWUiOiIifQ.1cVB-zr8uAJ0ADp4ACOv-wxwlg8esC3xhfwPsdvqgNg'\n+    'token' => '...cyNzQ2NjExMiwic2NvcGUiOiJ1c2VyIiwibmlja25hbWUiOiIifQ.-X54oFSs8WLikoDqlFus4SODKWkr-Ai3IH-D66ixxCg'\n )\n\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtManagementTest.php:147\n\nFAILURES!\nTests: 9, Assertions: 45, Failures: 1."},{"mutator":{"mutatorName":"ConcatOperandRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\", 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":53},"diff":"@@ @@\n         $role = $validatedUser->getRole();\n         $jwtConfig = $this->appConfig->getJwtConfig();\n         $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n-        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n+        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\", 'nickname' => $validatedUser->getUsername()->asString()];\n         $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n         return JsonWebToken::fromString($jwt);\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.6a46bfadcfd0e88543604b1aa85c5722.infection.xml\n\n........F\n\nTime: 00:00.011, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testCanCreateJwt\nJwt should be created\nFailed asserting that two objects are equal.\n--- Expected\n+++ Actual\n@@ @@\n norsk\\api\\app\\identityAccessManagement\\JsonWebToken Object (\n-    'token' => '...zQ2NjExMiwic2NvcGUiOiJpczp1c2VyIiwibmlja25hbWUiOiIifQ.1cVB-zr8uAJ0ADp4ACOv-wxwlg8esC3xhfwPsdvqgNg'\n+    'token' => '...zQ2NjExMiwic2NvcGUiOiJpczoiLCJuaWNrbmFtZSI6IiJ9.VJPdgrlTzkrOl42lHKwBuHxT2V9l4pstXwsOYV-QG1c'\n )\n\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtManagementTest.php:147\n\nFAILURES!\nTests: 9, Assertions: 45, Failures: 1."},{"mutator":{"mutatorName":"ArrayItem","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' > $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":54},"diff":"@@ @@\n         $role = $validatedUser->getRole();\n         $jwtConfig = $this->appConfig->getJwtConfig();\n         $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n-        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n+        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' > $validatedUser->getUsername()->asString()];\n         $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n         return JsonWebToken::fromString($jwt);\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.f2c27b0685d9c64163b63e2dae7f3bd0.infection.xml\n\n........F\n\nTime: 00:00.012, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testCanCreateJwt\nJwt should be created\nFailed asserting that two objects are equal.\n--- Expected\n+++ Actual\n@@ @@\n norsk\\api\\app\\identityAccessManagement\\JsonWebToken Object (\n-    'token' => '...ic2NvcGUiOiJpczp1c2VyIiwibmlja25hbWUiOiIifQ.1cVB-zr8uAJ0ADp4ACOv-wxwlg8esC3xhfwPsdvqgNg'\n+    'token' => '...ic2NvcGUiOiJpczp1c2VyIiwiMCI6dHJ1ZX0.0p-NxSBjkZi6RVTnuwAFv8LVoHYGEozS862C1nusw0o'\n )\n\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtManagementTest.php:147\n\nFAILURES!\nTests: 9, Assertions: 45, Failures: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    protected function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":67},"diff":"@@ @@\n         $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n         return JsonWebToken::fromString($jwt);\n     }\n-    public function validate(ServerRequestInterface $request, Session $session): void\n+    protected function validate(ServerRequestInterface $request, Session $session): void\n     {\n         $tokenString = $request->getHeader('Authorization')[0];\n         $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.a78e1d819229b4162372bdfeb6ea4eb5.infection.xml\n\nE\n\nTime: 00:00.007, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testCanValidateGivenTokenForScope with data set \"user\" ('validUserTokenWithTime.jwt')\nError: Call to protected method norsk\\api\\app\\identityAccessManagement\\JwtManagement::validate() from scope norsk\\api\\app\\identityAccessManagement\\JwtManagementTest\n\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtManagementTest.php:215\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"IncrementInteger","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[1];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":69},"diff":"@@ @@\n     }\n     public function validate(ServerRequestInterface $request, Session $session): void\n     {\n-        $tokenString = $request->getHeader('Authorization')[0];\n+        $tokenString = $request->getHeader('Authorization')[1];\n         $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n         $decodedPayload = $this->validateJwtToken($token);\n         $this->validateJwtContent($decodedPayload, $session);","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.8535904ea8059d7689f9639322c5526d.infection.xml\n\nE\n\nTime: 00:00.009, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testCanValidateGivenTokenForScope with data set \"user\" ('validUserTokenWithTime.jwt')\nTypeError: norsk\\api\\shared\\SanitizedClientInput::of(): Argument #1 ($string) must be of type string, null given, called in \/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php on line 44\n\n\/app\/api\/src\/shared\/SanitizedClientInput.php:17\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:44\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtManagementTest.php:215\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1, Warnings: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        \n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":73},"diff":"@@ @@\n         $tokenString = $request->getHeader('Authorization')[0];\n         $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n         $decodedPayload = $this->validateJwtToken($token);\n-        $this->validateJwtContent($decodedPayload, $session);\n+        \n         $this->logger->info(LogMessage::fromString('Jwt is valid'));\n     }\n     private function validateJwtToken(JsonWebToken $token): stdClass","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.221fd76933d34ce80465b8a6799b03d9.infection.xml\n\nF\n\nTime: 00:00.008, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testCanValidateGivenTokenForScope with data set \"user\" ('validUserTokenWithTime.jwt')\nExpectation failed for method name is \"addJwtContent\" when invoked 1 time.\nMethod was expected to be called 1 time, actually called 0 times.\n\nFAILURES!\nTests: 1, Assertions: 4, Failures: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        \n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":75},"diff":"@@ @@\n         $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n         $decodedPayload = $this->validateJwtToken($token);\n         $this->validateJwtContent($decodedPayload, $session);\n-        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n+        \n     }\n     private function validateJwtToken(JsonWebToken $token): stdClass\n     {","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.e5d10c1ffd0c2deafa892ab38ea8de8c.infection.xml\n\nF\n\nTime: 00:00.007, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testCanValidateGivenTokenForScope with data set \"user\" ('validUserTokenWithTime.jwt')\nExpectation failed for method name is \"info\" when invoked 1 time.\nMethod was expected to be called 1 time, actually called 0 times.\n\nFAILURES!\nTests: 1, Assertions: 2, Failures: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            \n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":88},"diff":"@@ @@\n             $headersCodec = $jwtConfig->getAlgorithm()->asString();\n             return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n         } catch (Throwable $throwable) {\n-            $this->logger->error($throwable);\n+            \n             return match (true) {\n                 $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                 $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.a97332b2034c3385302cfb27e1d80f5a.infection.xml\n\n....F\n\nTime: 00:00.010, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testThrowsExceptionIfTokenIsInvalid with data set \"TokenExpired\" ('invalidExpired.jwt', 'Token expired')\nExpectation failed for method name is \"error\" when invoked 1 time.\nMethod was expected to be called 1 time, actually called 0 times.\n\nFAILURES!\nTests: 5, Assertions: 25, Failures: 1."},{"mutator":{"mutatorName":"MatchArmRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":90},"diff":"@@ @@\n         } catch (Throwable $throwable) {\n             $this->logger->error($throwable);\n             return match (true) {\n-                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                 $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                 $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                 default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.a997d7f9ff8993d79499b321e27350a6.infection.xml\n\n....F\n\nTime: 00:00.009, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testThrowsExceptionIfTokenIsInvalid with data set \"TokenExpired\" ('invalidExpired.jwt', 'Token expired')\nFailed asserting that exception message 'Invalid token: Expired token' contains 'Token expired'.\n\nFAILURES!\nTests: 5, Assertions: 22, Failures: 1."},{"mutator":{"mutatorName":"MatchArmRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":90},"diff":"@@ @@\n             $this->logger->error($throwable);\n             return match (true) {\n                 $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n-                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                 $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                 default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n             };","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.67bea293f28a608ab5ec84764122b0fd.infection.xml\n\n.....F\n\nTime: 00:00.009, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testThrowsExceptionIfTokenIsInvalid with data set \"SignatureInvalid\" ('invalidSignature.jwt', 'Invalid token signature')\nFailed asserting that exception message 'Invalid token: Signature verification failed' contains 'Invalid token signature'.\n\nFAILURES!\nTests: 6, Assertions: 28, Failures: 1."},{"mutator":{"mutatorName":"MatchArmRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":90},"diff":"@@ @@\n             return match (true) {\n                 $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                 $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n-                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                 default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n             };\n         }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.26ee8fa075ee98d9a065aaafe930885a.infection.xml\n\n......F\n\nTime: 00:00.010, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testThrowsExceptionIfTokenIsInvalid with data set \"BeforeValid\" ('invalidNotValidYet.jwt', 'Token not valid yet')\nFailed asserting that exception message 'Invalid token: Cannot handle token with iat prior to 2200-09-28T13:37:27+0200' contains 'Token not valid yet'.\n\nFAILURES!\nTests: 7, Assertions: 34, Failures: 1."},{"mutator":{"mutatorName":"MatchArmRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":90},"diff":"@@ @@\n                 $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                 $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                 $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n-                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n             };\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.4f79ebb0404445f16c62aa423357ad78.infection.xml\n\n.......F\n\nTime: 00:00.015, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testThrowsExceptionIfTokenIsInvalid with data set \"GeneralInvalidToken\" ('invalid.jwt', 'Invalid token')\nFailed asserting that exception of type \"UnhandledMatchError\" matches expected exception \"RuntimeException\". Message was: \"Unhandled match case true\" at\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:61\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:45\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtManagementTest.php:291\n.\n\nFAILURES!\nTests: 8, Assertions: 39, Failures: 1."},{"mutator":{"mutatorName":"InstanceOf_","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                true => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":91},"diff":"@@ @@\n         } catch (Throwable $throwable) {\n             $this->logger->error($throwable);\n             return match (true) {\n-                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n+                true => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                 $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                 $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                 default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.60ebe7e8d4738904e784607888ed1a62.infection.xml\n\n.....F\n\nTime: 00:00.009, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testThrowsExceptionIfTokenIsInvalid with data set \"SignatureInvalid\" ('invalidSignature.jwt', 'Invalid token signature')\nFailed asserting that exception message 'Token expired: Signature verification failed' contains 'Invalid token signature'.\n\nFAILURES!\nTests: 6, Assertions: 28, Failures: 1."},{"mutator":{"mutatorName":"InstanceOf_","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                false => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":91},"diff":"@@ @@\n         } catch (Throwable $throwable) {\n             $this->logger->error($throwable);\n             return match (true) {\n-                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n+                false => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                 $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                 $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                 default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.e8692ea8f4020c021df7f2b41e8d2d9f.infection.xml\n\n....F\n\nTime: 00:00.009, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testThrowsExceptionIfTokenIsInvalid with data set \"TokenExpired\" ('invalidExpired.jwt', 'Token expired')\nFailed asserting that exception message 'Invalid token: Expired token' contains 'Token expired'.\n\nFAILURES!\nTests: 5, Assertions: 22, Failures: 1."},{"mutator":{"mutatorName":"Throw_","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":91},"diff":"@@ @@\n         } catch (Throwable $throwable) {\n             $this->logger->error($throwable);\n             return match (true) {\n-                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n+                $throwable instanceof ExpiredException => new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                 $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                 $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                 default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.c75e2e99832b87882c473a65a2f43a3a.infection.xml\n\n....F\n\nTime: 00:00.016, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testThrowsExceptionIfTokenIsInvalid with data set \"TokenExpired\" ('invalidExpired.jwt', 'Token expired')\nFailed asserting that exception of type \"TypeError\" matches expected exception \"RuntimeException\". Message was: \"norsk\\api\\app\\identityAccessManagement\\JwtManagement::validateJwtToken(): Return value must be of type stdClass, RuntimeException returned\" at\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:62\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:45\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtManagementTest.php:291\n.\n\nFAILURES!\nTests: 5, Assertions: 21, Failures: 1."},{"mutator":{"mutatorName":"ConcatOperandRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException($throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":92},"diff":"@@ @@\n         } catch (Throwable $throwable) {\n             $this->logger->error($throwable);\n             return match (true) {\n-                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n+                $throwable instanceof ExpiredException => throw new RuntimeException($throwable->getMessage()),\n                 $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                 $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                 default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.cd073d3cedb73fe7fc40a4d1da68f528.infection.xml\n\n....F\n\nTime: 00:00.012, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testThrowsExceptionIfTokenIsInvalid with data set \"TokenExpired\" ('invalidExpired.jwt', 'Token expired')\nFailed asserting that exception message 'Expired token' contains 'Token expired'.\n\nFAILURES!\nTests: 5, Assertions: 22, Failures: 1."},{"mutator":{"mutatorName":"InstanceOf_","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                true => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":94},"diff":"@@ @@\n             $this->logger->error($throwable);\n             return match (true) {\n                 $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n-                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n+                true => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                 $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                 default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n             };","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.cbaeffea952c59db9f099a96d01e797c.infection.xml\n\n......F\n\nTime: 00:00.012, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testThrowsExceptionIfTokenIsInvalid with data set \"BeforeValid\" ('invalidNotValidYet.jwt', 'Token not valid yet')\nFailed asserting that exception message 'Invalid token signature: Cannot handle token with iat prior to 2200-09-28T13:37:27+0200' contains 'Token not valid yet'.\n\nFAILURES!\nTests: 7, Assertions: 34, Failures: 1."},{"mutator":{"mutatorName":"InstanceOf_","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                false => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":94},"diff":"@@ @@\n             $this->logger->error($throwable);\n             return match (true) {\n                 $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n-                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n+                false => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                 $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                 default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n             };","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.7e99aba2c6f3e0344a2165b22631d475.infection.xml\n\n.....F\n\nTime: 00:00.010, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testThrowsExceptionIfTokenIsInvalid with data set \"SignatureInvalid\" ('invalidSignature.jwt', 'Invalid token signature')\nFailed asserting that exception message 'Invalid token: Signature verification failed' contains 'Invalid token signature'.\n\nFAILURES!\nTests: 6, Assertions: 28, Failures: 1."},{"mutator":{"mutatorName":"Throw_","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":94},"diff":"@@ @@\n             $this->logger->error($throwable);\n             return match (true) {\n                 $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n-                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n+                $throwable instanceof SignatureInvalidException => new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                 $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                 default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n             };","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.6c7f8871afca543bf8eff108adf948d7.infection.xml\n\n.....F\n\nTime: 00:00.010, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testThrowsExceptionIfTokenIsInvalid with data set \"SignatureInvalid\" ('invalidSignature.jwt', 'Invalid token signature')\nFailed asserting that exception of type \"TypeError\" matches expected exception \"RuntimeException\". Message was: \"norsk\\api\\app\\identityAccessManagement\\JwtManagement::validateJwtToken(): Return value must be of type stdClass, RuntimeException returned\" at\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:62\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:45\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtManagementTest.php:291\n.\n\nFAILURES!\nTests: 6, Assertions: 27, Failures: 1."},{"mutator":{"mutatorName":"ConcatOperandRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException($throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":95},"diff":"@@ @@\n             $this->logger->error($throwable);\n             return match (true) {\n                 $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n-                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n+                $throwable instanceof SignatureInvalidException => throw new RuntimeException($throwable->getMessage()),\n                 $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                 default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n             };","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.a75ffb1dc4a322e62d05a2adf58e0283.infection.xml\n\n.....F\n\nTime: 00:00.010, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testThrowsExceptionIfTokenIsInvalid with data set \"SignatureInvalid\" ('invalidSignature.jwt', 'Invalid token signature')\nFailed asserting that exception message 'Signature verification failed' contains 'Invalid token signature'.\n\nFAILURES!\nTests: 6, Assertions: 28, Failures: 1."},{"mutator":{"mutatorName":"InstanceOf_","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                true => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":97},"diff":"@@ @@\n             return match (true) {\n                 $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                 $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n-                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n+                true => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                 default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n             };\n         }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.c69fd326d97d75b712a8ab5d786f8e67.infection.xml\n\n.......F\n\nTime: 00:00.011, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testThrowsExceptionIfTokenIsInvalid with data set \"GeneralInvalidToken\" ('invalid.jwt', 'Invalid token')\nFailed asserting that exception message 'Token not valid yet: Incorrect key for this algorithm' contains 'Invalid token'.\n\nFAILURES!\nTests: 8, Assertions: 40, Failures: 1."},{"mutator":{"mutatorName":"InstanceOf_","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                false => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":97},"diff":"@@ @@\n             return match (true) {\n                 $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                 $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n-                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n+                false => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                 default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n             };\n         }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.2f3f5e198fa3449750afa054f0578e2c.infection.xml\n\n......F\n\nTime: 00:00.011, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testThrowsExceptionIfTokenIsInvalid with data set \"BeforeValid\" ('invalidNotValidYet.jwt', 'Token not valid yet')\nFailed asserting that exception message 'Invalid token: Cannot handle token with iat prior to 2200-09-28T13:37:27+0200' contains 'Token not valid yet'.\n\nFAILURES!\nTests: 7, Assertions: 34, Failures: 1."},{"mutator":{"mutatorName":"Throw_","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":97},"diff":"@@ @@\n             return match (true) {\n                 $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                 $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n-                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n+                $throwable instanceof BeforeValidException => new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                 default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n             };\n         }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.290890e51fe1d1c6f789207787e48b10.infection.xml\n\n......F\n\nTime: 00:00.010, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testThrowsExceptionIfTokenIsInvalid with data set \"BeforeValid\" ('invalidNotValidYet.jwt', 'Token not valid yet')\nFailed asserting that exception of type \"TypeError\" matches expected exception \"RuntimeException\". Message was: \"norsk\\api\\app\\identityAccessManagement\\JwtManagement::validateJwtToken(): Return value must be of type stdClass, RuntimeException returned\" at\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:62\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:45\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtManagementTest.php:291\n.\n\nFAILURES!\nTests: 7, Assertions: 33, Failures: 1."},{"mutator":{"mutatorName":"ConcatOperandRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException($throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":98},"diff":"@@ @@\n             return match (true) {\n                 $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                 $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n-                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n+                $throwable instanceof BeforeValidException => throw new RuntimeException($throwable->getMessage()),\n                 default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n             };\n         }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.4f3053f29dfb6a56e9712fab987ed6be.infection.xml\n\n......F\n\nTime: 00:00.010, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testThrowsExceptionIfTokenIsInvalid with data set \"BeforeValid\" ('invalidNotValidYet.jwt', 'Token not valid yet')\nFailed asserting that exception message 'Cannot handle token with iat prior to 2200-09-28T13:37:27+0200' contains 'Token not valid yet'.\n\nFAILURES!\nTests: 7, Assertions: 34, Failures: 1."},{"mutator":{"mutatorName":"ConcatOperandRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException($throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":101},"diff":"@@ @@\n                 $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                 $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                 $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n-                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n+                default => throw new RuntimeException($throwable->getMessage()),\n             };\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.98b68b0416d1174b77add7112190eaf4.infection.xml\n\n.......F\n\nTime: 00:00.011, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testThrowsExceptionIfTokenIsInvalid with data set \"GeneralInvalidToken\" ('invalid.jwt', 'Invalid token')\nFailed asserting that exception message 'Incorrect key for this algorithm' contains 'Invalid token'.\n\nFAILURES!\nTests: 8, Assertions: 40, Failures: 1."},{"mutator":{"mutatorName":"Throw_","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":101},"diff":"@@ @@\n                 $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                 $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                 $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n-                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n+                default => new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n             };\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.054a661a39be83fb19614d717e3346af.infection.xml\n\n.......F\n\nTime: 00:00.011, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testThrowsExceptionIfTokenIsInvalid with data set \"GeneralInvalidToken\" ('invalid.jwt', 'Invalid token')\nFailed asserting that exception of type \"TypeError\" matches expected exception \"RuntimeException\". Message was: \"norsk\\api\\app\\identityAccessManagement\\JwtManagement::validateJwtToken(): Return value must be of type stdClass, RuntimeException returned\" at\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:62\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:45\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtManagementTest.php:291\n.\n\nFAILURES!\nTests: 8, Assertions: 39, Failures: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        \n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":109},"diff":"@@ @@\n     }\n     private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n     {\n-        $this->ensureSubjectIsValid($decodedPayload);\n+        \n         $this->ensureAudienceIsValid($decodedPayload);\n         $payload = Payload::by($decodedPayload);\n         $session->addJwtContent($payload, $this->usersReader);","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.235f00d42305d95358de7b666ea16eb1.infection.xml\n\n..F\n\nTime: 00:00.011, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testThrowsExceptionIfTokenWasManipulated with data set \"notFromApp\" ('invalidTokenNotFromApp.jwt', 'Token was not generated by Api')\nnorsk\\api\\app\\logging\\Logger::info(norsk\\api\\app\\logging\\LogMessage Object (...)): void was not expected to be called.\n\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:47\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtManagementTest.php:251\n\nFAILURES!\nTests: 3, Assertions: 9, Failures: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        \n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":110},"diff":"@@ @@\n     private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n     {\n         $this->ensureSubjectIsValid($decodedPayload);\n-        $this->ensureAudienceIsValid($decodedPayload);\n+        \n         $payload = Payload::by($decodedPayload);\n         $session->addJwtContent($payload, $this->usersReader);\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.e4241981c2e2a20b0dc126a7414204b3.infection.xml\n\n...F\n\nTime: 00:00.009, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testThrowsExceptionIfTokenWasManipulated with data set \"manipulatedClient\" ('invalidTokenWithManipulatedClient.jwt', 'Token was not sent from Client')\nnorsk\\api\\app\\logging\\Logger::info(norsk\\api\\app\\logging\\LogMessage Object (...)): void was not expected to be called.\n\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:47\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtManagementTest.php:251\n\nFAILURES!\nTests: 4, Assertions: 15, Failures: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        \n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":113},"diff":"@@ @@\n         $this->ensureSubjectIsValid($decodedPayload);\n         $this->ensureAudienceIsValid($decodedPayload);\n         $payload = Payload::by($decodedPayload);\n-        $session->addJwtContent($payload, $this->usersReader);\n+        \n     }\n     private function ensureSubjectIsValid(stdClass $decodedPayload): void\n     {","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.6b1bf81a1ec82ab958ff84de23656113.infection.xml\n\nF\n\nTime: 00:00.007, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testCanValidateGivenTokenForScope with data set \"user\" ('validUserTokenWithTime.jwt')\nExpectation failed for method name is \"addJwtContent\" when invoked 1 time.\nMethod was expected to be called 1 time, actually called 0 times.\n\nFAILURES!\nTests: 1, Assertions: 4, Failures: 1."},{"mutator":{"mutatorName":"LogicalNot","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":119},"diff":"@@ @@\n     }\n     private function ensureSubjectIsValid(stdClass $decodedPayload): void\n     {\n-        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n+        if (property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n             throw new InvalidArgumentException('Token was not generated by Api');\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.41b870bba7d17f5c4bbb7e794174b6f3.infection.xml\n\nE\n\nTime: 00:00.007, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testCanValidateGivenTokenForScope with data set \"user\" ('validUserTokenWithTime.jwt')\nInvalidArgumentException: Token was not generated by Api\n\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:76\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:68\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:46\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtManagementTest.php:215\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"NotIdentical","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub === self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":119},"diff":"@@ @@\n     }\n     private function ensureSubjectIsValid(stdClass $decodedPayload): void\n     {\n-        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n+        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub === self::NORSK_APP_SUB) {\n             throw new InvalidArgumentException('Token was not generated by Api');\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.8f298f150d0c4bbe46b2fdc6183a9acb.infection.xml\n\nE\n\nTime: 00:00.007, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testCanValidateGivenTokenForScope with data set \"user\" ('validUserTokenWithTime.jwt')\nInvalidArgumentException: Token was not generated by Api\n\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:76\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:68\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:46\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtManagementTest.php:215\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"LogicalOr","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') && $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":119},"diff":"@@ @@\n     }\n     private function ensureSubjectIsValid(stdClass $decodedPayload): void\n     {\n-        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n+        if (!property_exists($decodedPayload, 'sub') && $decodedPayload->sub !== self::NORSK_APP_SUB) {\n             throw new InvalidArgumentException('Token was not generated by Api');\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.59eb09071f3d66e61a824c7eaba0dcf9.infection.xml\n\n..F\n\nTime: 00:00.008, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testThrowsExceptionIfTokenWasManipulated with data set \"notFromApp\" ('invalidTokenNotFromApp.jwt', 'Token was not generated by Api')\nnorsk\\api\\app\\logging\\Logger::info(norsk\\api\\app\\logging\\LogMessage Object (...)): void was not expected to be called.\n\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:47\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtManagementTest.php:251\n\nFAILURES!\nTests: 3, Assertions: 9, Failures: 1."},{"mutator":{"mutatorName":"LogicalOrAllSubExprNegation","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (property_exists($decodedPayload, 'sub') || !($decodedPayload->sub !== self::NORSK_APP_SUB)) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":119},"diff":"@@ @@\n     }\n     private function ensureSubjectIsValid(stdClass $decodedPayload): void\n     {\n-        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n+        if (property_exists($decodedPayload, 'sub') || !($decodedPayload->sub !== self::NORSK_APP_SUB)) {\n             throw new InvalidArgumentException('Token was not generated by Api');\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.daf39a79cfec39d6ddd79dfac67741f7.infection.xml\n\nE\n\nTime: 00:00.008, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testCanValidateGivenTokenForScope with data set \"user\" ('validUserTokenWithTime.jwt')\nInvalidArgumentException: Token was not generated by Api\n\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:76\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:68\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:46\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtManagementTest.php:215\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"LogicalOrNegation","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!(!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB)) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":119},"diff":"@@ @@\n     }\n     private function ensureSubjectIsValid(stdClass $decodedPayload): void\n     {\n-        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n+        if (!(!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB)) {\n             throw new InvalidArgumentException('Token was not generated by Api');\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.a1ab645efb79c3dfc1b963d84ac81e09.infection.xml\n\nE\n\nTime: 00:00.008, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testCanValidateGivenTokenForScope with data set \"user\" ('validUserTokenWithTime.jwt')\nInvalidArgumentException: Token was not generated by Api\n\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:76\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:68\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:46\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtManagementTest.php:215\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Throw_","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":120},"diff":"@@ @@\n     private function ensureSubjectIsValid(stdClass $decodedPayload): void\n     {\n         if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n-            throw new InvalidArgumentException('Token was not generated by Api');\n+            new InvalidArgumentException('Token was not generated by Api');\n         }\n     }\n     private function ensureAudienceIsValid(stdClass $decodedPayload): void","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.ee870b241fa59db1415e2e5a363a3a32.infection.xml\n\n..F\n\nTime: 00:00.010, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testThrowsExceptionIfTokenWasManipulated with data set \"notFromApp\" ('invalidTokenNotFromApp.jwt', 'Token was not generated by Api')\nnorsk\\api\\app\\logging\\Logger::info(norsk\\api\\app\\logging\\LogMessage Object (...)): void was not expected to be called.\n\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:47\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtManagementTest.php:251\n\nFAILURES!\nTests: 3, Assertions: 9, Failures: 1."},{"mutator":{"mutatorName":"LogicalNot","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":127},"diff":"@@ @@\n     }\n     private function ensureAudienceIsValid(stdClass $decodedPayload): void\n     {\n-        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n+        if (property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n             throw new InvalidArgumentException('Token was not sent from Client');\n         }\n     }\n }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.c5808b7d0eb644e9570e4b6f5fa8929a.infection.xml\n\nE\n\nTime: 00:00.007, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testCanValidateGivenTokenForScope with data set \"user\" ('validUserTokenWithTime.jwt')\nInvalidArgumentException: Token was not sent from Client\n\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:82\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:69\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:46\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtManagementTest.php:215\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"NotIdentical","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud === self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":127},"diff":"@@ @@\n     }\n     private function ensureAudienceIsValid(stdClass $decodedPayload): void\n     {\n-        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n+        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud === self::NORSK_CLIENT) {\n             throw new InvalidArgumentException('Token was not sent from Client');\n         }\n     }\n }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.048fe2f80efbe4a87191464de21bd50f.infection.xml\n\nE\n\nTime: 00:00.007, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testCanValidateGivenTokenForScope with data set \"user\" ('validUserTokenWithTime.jwt')\nInvalidArgumentException: Token was not sent from Client\n\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:82\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:69\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:46\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtManagementTest.php:215\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"LogicalOr","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') && $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":127},"diff":"@@ @@\n     }\n     private function ensureAudienceIsValid(stdClass $decodedPayload): void\n     {\n-        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n+        if (!property_exists($decodedPayload, 'aud') && $decodedPayload->aud !== self::NORSK_CLIENT) {\n             throw new InvalidArgumentException('Token was not sent from Client');\n         }\n     }\n }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.c54f0fb9ac199888e68c20b5f62eaab2.infection.xml\n\n...F\n\nTime: 00:00.008, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testThrowsExceptionIfTokenWasManipulated with data set \"manipulatedClient\" ('invalidTokenWithManipulatedClient.jwt', 'Token was not sent from Client')\nnorsk\\api\\app\\logging\\Logger::info(norsk\\api\\app\\logging\\LogMessage Object (...)): void was not expected to be called.\n\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:47\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtManagementTest.php:251\n\nFAILURES!\nTests: 4, Assertions: 15, Failures: 1."},{"mutator":{"mutatorName":"LogicalOrAllSubExprNegation","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (property_exists($decodedPayload, 'aud') || !($decodedPayload->aud !== self::NORSK_CLIENT)) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":127},"diff":"@@ @@\n     }\n     private function ensureAudienceIsValid(stdClass $decodedPayload): void\n     {\n-        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n+        if (property_exists($decodedPayload, 'aud') || !($decodedPayload->aud !== self::NORSK_CLIENT)) {\n             throw new InvalidArgumentException('Token was not sent from Client');\n         }\n     }\n }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.dd8ae9ec7976fd4d0b63feb4053a9faf.infection.xml\n\nE\n\nTime: 00:00.007, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testCanValidateGivenTokenForScope with data set \"user\" ('validUserTokenWithTime.jwt')\nInvalidArgumentException: Token was not sent from Client\n\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:82\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:69\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:46\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtManagementTest.php:215\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"LogicalOrNegation","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!(!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT)) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":127},"diff":"@@ @@\n     }\n     private function ensureAudienceIsValid(stdClass $decodedPayload): void\n     {\n-        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n+        if (!(!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT)) {\n             throw new InvalidArgumentException('Token was not sent from Client');\n         }\n     }\n }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.385de18a15e88f630407c25247fff8fd.infection.xml\n\nE\n\nTime: 00:00.007, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testCanValidateGivenTokenForScope with data set \"user\" ('validUserTokenWithTime.jwt')\nInvalidArgumentException: Token was not sent from Client\n\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:82\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:69\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:46\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtManagementTest.php:215\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Throw_","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            throw new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse Firebase\\JWT\\BeforeValidException;\nuse Firebase\\JWT\\ExpiredException;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse Firebase\\JWT\\SignatureInvalidException;\nuse InvalidArgumentException;\nuse norsk\\api\\app\\config\\AppConfig;\nuse norsk\\api\\app\\logging\\Logger;\nuse norsk\\api\\app\\logging\\LogMessage;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\shared\\SanitizedClientInput;\nuse norsk\\api\\user\\UsersReader;\nuse norsk\\api\\user\\ValidatedUser;\nuse Psr\\Clock\\ClockInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse RuntimeException;\nuse stdClass;\nuse Throwable;\nclass JwtManagement\n{\n    private const int TWO_HOURS_IN_SECONDS = 7200;\n    private const string NORSK_APP_SUB = 'norsk app';\n    private const string NORSK_CLIENT = 'Norsk Client';\n    public function __construct(private readonly AppConfig $appConfig, private readonly ClockInterface $clock, private readonly Logger $logger, private readonly UsersReader $usersReader)\n    {\n    }\n    public function create(ValidatedUser $validatedUser): JsonWebToken\n    {\n        $role = $validatedUser->getRole();\n        $jwtConfig = $this->appConfig->getJwtConfig();\n        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);\n        $payload = ['sub' => $jwtConfig->getSubject()->asString(), 'aud' => $jwtConfig->getAudience()->asString(), 'iat' => $this->clock->getTimestamp(), 'exp' => $futureClock->getTimestamp(), 'scope' => \"is:\" . $role->value, 'nickname' => $validatedUser->getUsername()->asString()];\n        $jwt = JWT::encode($payload, $jwtConfig->getAuthKey()->asBase64String(), $jwtConfig->getAlgorithm()->asString());\n        return JsonWebToken::fromString($jwt);\n    }\n    public function validate(ServerRequestInterface $request, Session $session): void\n    {\n        $tokenString = $request->getHeader('Authorization')[0];\n        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());\n        $decodedPayload = $this->validateJwtToken($token);\n        $this->validateJwtContent($decodedPayload, $session);\n        $this->logger->info(LogMessage::fromString('Jwt is valid'));\n    }\n    private function validateJwtToken(JsonWebToken $token): stdClass\n    {\n        try {\n            $jwtConfig = $this->appConfig->getJwtConfig();\n            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();\n            $headersCodec = $jwtConfig->getAlgorithm()->asString();\n            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));\n        } catch (Throwable $throwable) {\n            $this->logger->error($throwable);\n            return match (true) {\n                $throwable instanceof ExpiredException => throw new RuntimeException('Token expired: ' . $throwable->getMessage()),\n                $throwable instanceof SignatureInvalidException => throw new RuntimeException('Invalid token signature: ' . $throwable->getMessage()),\n                $throwable instanceof BeforeValidException => throw new RuntimeException('Token not valid yet: ' . $throwable->getMessage()),\n                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),\n            };\n        }\n    }\n    private function validateJwtContent(stdClass $decodedPayload, Session $session): void\n    {\n        $this->ensureSubjectIsValid($decodedPayload);\n        $this->ensureAudienceIsValid($decodedPayload);\n        $payload = Payload::by($decodedPayload);\n        $session->addJwtContent($payload, $this->usersReader);\n    }\n    private function ensureSubjectIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {\n            throw new InvalidArgumentException('Token was not generated by Api');\n        }\n    }\n    private function ensureAudienceIsValid(stdClass $decodedPayload): void\n    {\n        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n            new InvalidArgumentException('Token was not sent from Client');\n        }\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php","originalStartLine":128},"diff":"@@ @@\n     private function ensureAudienceIsValid(stdClass $decodedPayload): void\n     {\n         if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {\n-            throw new InvalidArgumentException('Token was not sent from Client');\n+            new InvalidArgumentException('Token was not sent from Client');\n         }\n     }\n }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.48b17220cdaaba8b2591cbb75b8cc8fc.infection.xml\n\n...F\n\nTime: 00:00.010, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtManagementTest::testThrowsExceptionIfTokenWasManipulated with data set \"manipulatedClient\" ('invalidTokenWithManipulatedClient.jwt', 'Token was not sent from Client')\nnorsk\\api\\app\\logging\\Logger::info(norsk\\api\\app\\logging\\LogMessage Object (...)): void was not expected to be called.\n\n\/app\/api\/src\/app\/identityAccessManagement\/JwtManagement.php:47\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtManagementTest.php:251\n\nFAILURES!\nTests: 4, Assertions: 15, Failures: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nuse norsk\\api\\shared\\SanitizedClientInput;\nreadonly class JwtSubject\n{\n    private function __construct(private string $jwtSubject)\n    {\n    }\n    public static function by(string $jwtSubject): self\n    {\n        $trimmed = trim($jwtSubject);\n        self::ensureIsNotEmpty($trimmed);\n        return new self(SanitizedClientInput::of($trimmed)->asString());\n    }\n    private static function ensureIsNotEmpty(string $jwtSubject): void\n    {\n        if ($jwtSubject === '') {\n            throw new InvalidArgumentException('Subject in JWT cannot be empty.');\n        }\n    }\n    public function asString(): string\n    {\n        return $this->jwtSubject;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nuse norsk\\api\\shared\\SanitizedClientInput;\nreadonly class JwtSubject\n{\n    private function __construct(private string $jwtSubject)\n    {\n    }\n    protected static function by(string $jwtSubject): self\n    {\n        $trimmed = trim($jwtSubject);\n        self::ensureIsNotEmpty($trimmed);\n        return new self(SanitizedClientInput::of($trimmed)->asString());\n    }\n    private static function ensureIsNotEmpty(string $jwtSubject): void\n    {\n        if ($jwtSubject === '') {\n            throw new InvalidArgumentException('Subject in JWT cannot be empty.');\n        }\n    }\n    public function asString(): string\n    {\n        return $this->jwtSubject;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtSubject.php","originalStartLine":17},"diff":"@@ @@\n     private function __construct(private string $jwtSubject)\n     {\n     }\n-    public static function by(string $jwtSubject): self\n+    protected static function by(string $jwtSubject): self\n     {\n         $trimmed = trim($jwtSubject);\n         self::ensureIsNotEmpty($trimmed);","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.336f19894ee15ea6b5772186a1f12218.infection.xml\n\nE\n\nTime: 00:00.001, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtSubjectTest::testCanBeUsedAsString\nError: Call to protected method norsk\\api\\app\\identityAccessManagement\\JwtSubject::by() from scope norsk\\api\\app\\identityAccessManagement\\JwtSubjectTest\n\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtSubjectTest.php:16\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"UnwrapTrim","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nuse norsk\\api\\shared\\SanitizedClientInput;\nreadonly class JwtSubject\n{\n    private function __construct(private string $jwtSubject)\n    {\n    }\n    public static function by(string $jwtSubject): self\n    {\n        $trimmed = trim($jwtSubject);\n        self::ensureIsNotEmpty($trimmed);\n        return new self(SanitizedClientInput::of($trimmed)->asString());\n    }\n    private static function ensureIsNotEmpty(string $jwtSubject): void\n    {\n        if ($jwtSubject === '') {\n            throw new InvalidArgumentException('Subject in JWT cannot be empty.');\n        }\n    }\n    public function asString(): string\n    {\n        return $this->jwtSubject;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nuse norsk\\api\\shared\\SanitizedClientInput;\nreadonly class JwtSubject\n{\n    private function __construct(private string $jwtSubject)\n    {\n    }\n    public static function by(string $jwtSubject): self\n    {\n        $trimmed = $jwtSubject;\n        self::ensureIsNotEmpty($trimmed);\n        return new self(SanitizedClientInput::of($trimmed)->asString());\n    }\n    private static function ensureIsNotEmpty(string $jwtSubject): void\n    {\n        if ($jwtSubject === '') {\n            throw new InvalidArgumentException('Subject in JWT cannot be empty.');\n        }\n    }\n    public function asString(): string\n    {\n        return $this->jwtSubject;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtSubject.php","originalStartLine":19},"diff":"@@ @@\n     }\n     public static function by(string $jwtSubject): self\n     {\n-        $trimmed = trim($jwtSubject);\n+        $trimmed = $jwtSubject;\n         self::ensureIsNotEmpty($trimmed);\n         return new self(SanitizedClientInput::of($trimmed)->asString());\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.cccc8f3f8c138bea7490fbb97656b526.infection.xml\n\n.F                                                                  2 \/ 2 (100%)\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtSubjectTest::testThrowsExceptionIfFirstNameIsEmpty\nFailed asserting that exception of type \"InvalidArgumentException\" is thrown.\n\nFAILURES!\nTests: 2, Assertions: 2, Failures: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nuse norsk\\api\\shared\\SanitizedClientInput;\nreadonly class JwtSubject\n{\n    private function __construct(private string $jwtSubject)\n    {\n    }\n    public static function by(string $jwtSubject): self\n    {\n        $trimmed = trim($jwtSubject);\n        self::ensureIsNotEmpty($trimmed);\n        return new self(SanitizedClientInput::of($trimmed)->asString());\n    }\n    private static function ensureIsNotEmpty(string $jwtSubject): void\n    {\n        if ($jwtSubject === '') {\n            throw new InvalidArgumentException('Subject in JWT cannot be empty.');\n        }\n    }\n    public function asString(): string\n    {\n        return $this->jwtSubject;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nuse norsk\\api\\shared\\SanitizedClientInput;\nreadonly class JwtSubject\n{\n    private function __construct(private string $jwtSubject)\n    {\n    }\n    public static function by(string $jwtSubject): self\n    {\n        $trimmed = trim($jwtSubject);\n        \n        return new self(SanitizedClientInput::of($trimmed)->asString());\n    }\n    private static function ensureIsNotEmpty(string $jwtSubject): void\n    {\n        if ($jwtSubject === '') {\n            throw new InvalidArgumentException('Subject in JWT cannot be empty.');\n        }\n    }\n    public function asString(): string\n    {\n        return $this->jwtSubject;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtSubject.php","originalStartLine":21},"diff":"@@ @@\n     public static function by(string $jwtSubject): self\n     {\n         $trimmed = trim($jwtSubject);\n-        self::ensureIsNotEmpty($trimmed);\n+        \n         return new self(SanitizedClientInput::of($trimmed)->asString());\n     }\n     private static function ensureIsNotEmpty(string $jwtSubject): void","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.5edee6922f1f17bd0cfbd616297161b7.infection.xml\n\n.F                                                                  2 \/ 2 (100%)\n\nTime: 00:00.001, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtSubjectTest::testThrowsExceptionIfFirstNameIsEmpty\nFailed asserting that exception of type \"InvalidArgumentException\" is thrown.\n\nFAILURES!\nTests: 2, Assertions: 2, Failures: 1."},{"mutator":{"mutatorName":"Identical","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nuse norsk\\api\\shared\\SanitizedClientInput;\nreadonly class JwtSubject\n{\n    private function __construct(private string $jwtSubject)\n    {\n    }\n    public static function by(string $jwtSubject): self\n    {\n        $trimmed = trim($jwtSubject);\n        self::ensureIsNotEmpty($trimmed);\n        return new self(SanitizedClientInput::of($trimmed)->asString());\n    }\n    private static function ensureIsNotEmpty(string $jwtSubject): void\n    {\n        if ($jwtSubject === '') {\n            throw new InvalidArgumentException('Subject in JWT cannot be empty.');\n        }\n    }\n    public function asString(): string\n    {\n        return $this->jwtSubject;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nuse norsk\\api\\shared\\SanitizedClientInput;\nreadonly class JwtSubject\n{\n    private function __construct(private string $jwtSubject)\n    {\n    }\n    public static function by(string $jwtSubject): self\n    {\n        $trimmed = trim($jwtSubject);\n        self::ensureIsNotEmpty($trimmed);\n        return new self(SanitizedClientInput::of($trimmed)->asString());\n    }\n    private static function ensureIsNotEmpty(string $jwtSubject): void\n    {\n        if ($jwtSubject !== '') {\n            throw new InvalidArgumentException('Subject in JWT cannot be empty.');\n        }\n    }\n    public function asString(): string\n    {\n        return $this->jwtSubject;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtSubject.php","originalStartLine":29},"diff":"@@ @@\n     }\n     private static function ensureIsNotEmpty(string $jwtSubject): void\n     {\n-        if ($jwtSubject === '') {\n+        if ($jwtSubject !== '') {\n             throw new InvalidArgumentException('Subject in JWT cannot be empty.');\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.fb732309f1d8ea5e6014de2c9063a350.infection.xml\n\nE\n\nTime: 00:00.001, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtSubjectTest::testCanBeUsedAsString\nInvalidArgumentException: Subject in JWT cannot be empty.\n\n\/app\/api\/src\/app\/identityAccessManagement\/JwtSubject.php:22\n\/app\/api\/src\/app\/identityAccessManagement\/JwtSubject.php:16\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtSubjectTest.php:16\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Throw_","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nuse norsk\\api\\shared\\SanitizedClientInput;\nreadonly class JwtSubject\n{\n    private function __construct(private string $jwtSubject)\n    {\n    }\n    public static function by(string $jwtSubject): self\n    {\n        $trimmed = trim($jwtSubject);\n        self::ensureIsNotEmpty($trimmed);\n        return new self(SanitizedClientInput::of($trimmed)->asString());\n    }\n    private static function ensureIsNotEmpty(string $jwtSubject): void\n    {\n        if ($jwtSubject === '') {\n            throw new InvalidArgumentException('Subject in JWT cannot be empty.');\n        }\n    }\n    public function asString(): string\n    {\n        return $this->jwtSubject;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nuse norsk\\api\\shared\\SanitizedClientInput;\nreadonly class JwtSubject\n{\n    private function __construct(private string $jwtSubject)\n    {\n    }\n    public static function by(string $jwtSubject): self\n    {\n        $trimmed = trim($jwtSubject);\n        self::ensureIsNotEmpty($trimmed);\n        return new self(SanitizedClientInput::of($trimmed)->asString());\n    }\n    private static function ensureIsNotEmpty(string $jwtSubject): void\n    {\n        if ($jwtSubject === '') {\n            new InvalidArgumentException('Subject in JWT cannot be empty.');\n        }\n    }\n    public function asString(): string\n    {\n        return $this->jwtSubject;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtSubject.php","originalStartLine":30},"diff":"@@ @@\n     private static function ensureIsNotEmpty(string $jwtSubject): void\n     {\n         if ($jwtSubject === '') {\n-            throw new InvalidArgumentException('Subject in JWT cannot be empty.');\n+            new InvalidArgumentException('Subject in JWT cannot be empty.');\n         }\n     }\n     public function asString(): string","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.4c801a2faae96dd13e889b8fe383b321.infection.xml\n\n.F                                                                  2 \/ 2 (100%)\n\nTime: 00:00.001, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtSubjectTest::testThrowsExceptionIfFirstNameIsEmpty\nFailed asserting that exception of type \"InvalidArgumentException\" is thrown.\n\nFAILURES!\nTests: 2, Assertions: 2, Failures: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nuse norsk\\api\\shared\\SanitizedClientInput;\nreadonly class JwtSubject\n{\n    private function __construct(private string $jwtSubject)\n    {\n    }\n    public static function by(string $jwtSubject): self\n    {\n        $trimmed = trim($jwtSubject);\n        self::ensureIsNotEmpty($trimmed);\n        return new self(SanitizedClientInput::of($trimmed)->asString());\n    }\n    private static function ensureIsNotEmpty(string $jwtSubject): void\n    {\n        if ($jwtSubject === '') {\n            throw new InvalidArgumentException('Subject in JWT cannot be empty.');\n        }\n    }\n    public function asString(): string\n    {\n        return $this->jwtSubject;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nuse norsk\\api\\shared\\SanitizedClientInput;\nreadonly class JwtSubject\n{\n    private function __construct(private string $jwtSubject)\n    {\n    }\n    public static function by(string $jwtSubject): self\n    {\n        $trimmed = trim($jwtSubject);\n        self::ensureIsNotEmpty($trimmed);\n        return new self(SanitizedClientInput::of($trimmed)->asString());\n    }\n    private static function ensureIsNotEmpty(string $jwtSubject): void\n    {\n        if ($jwtSubject === '') {\n            throw new InvalidArgumentException('Subject in JWT cannot be empty.');\n        }\n    }\n    protected function asString(): string\n    {\n        return $this->jwtSubject;\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/JwtSubject.php","originalStartLine":35},"diff":"@@ @@\n             throw new InvalidArgumentException('Subject in JWT cannot be empty.');\n         }\n     }\n-    public function asString(): string\n+    protected function asString(): string\n     {\n         return $this->jwtSubject;\n     }\n }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.e7fc44a11809f30359905ef7d3b14fc6.infection.xml\n\nE\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\JwtSubjectTest::testCanBeUsedAsString\nError: Call to protected method norsk\\api\\app\\identityAccessManagement\\JwtSubject::asString() from scope norsk\\api\\app\\identityAccessManagement\\JwtSubjectTest\n\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/JwtSubjectTest.php:16\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Identical","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\user\\Role;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nclass Session\n{\n    private const string NORSK_CLIENT = 'norsk client';\n    private function __construct()\n    {\n        if (session_status() === PHP_SESSION_NONE) {\n            session_start();\n        }\n    }\n    public static function create(): self\n    {\n        return new self();\n    }\n    public static function getUserName(): UserName\n    {\n        $userName = $_SESSION['user'];\n        self::ensureIsNotNull($userName);\n        return UserName::by($userName);\n    }\n    private static function ensureIsNotNull(?string $userName): void\n    {\n        if ($userName === null) {\n            throw new InvalidArgumentException('Session user is not set.', ResponseCode::serverError->value);\n        }\n    }\n    public static function isValidManager(): bool\n    {\n        return isset($_SESSION['user'], $_SESSION['scope']) && self::isScopeManager();\n    }\n    private static function isScopeManager(): bool\n    {\n        return $_SESSION['scope'] === 'is:' . Role::MANAGER->value;\n    }\n    public function addJwtContent(Payload $payload, UsersReader $usersReader): void\n    {\n        $payloadArray = $payload->asArray();\n        $this->addScope($payloadArray);\n        $this->addUserName($payloadArray, $usersReader);\n        $this->addExpiration($payloadArray);\n    }\n    private function addScope(array $payload): void\n    {\n        if (array_key_exists('scope', $payload) && ($payload['scope'] === 'is:user' || $payload['scope'] === 'is:manager')) {\n            $_SESSION['scope'] = $payload['scope'];\n        }\n    }\n    private function addUserName(array $payload, UsersReader $usersReader): void\n    {\n        if ($payload['nickname'] !== null) {\n            $this->ifTokenIsClientDefaultSetDefaultUserName($payload);\n            $this->ifIsNotClientCheckIfUsernameExists($payload, $usersReader);\n            $_SESSION['user'] = UserName::by($payload['nickname'])->asString();\n        }\n    }\n    private function ifTokenIsClientDefaultSetDefaultUserName(array $payload): void\n    {\n        if ($payload['nickname'] === self::NORSK_CLIENT) {\n            $_SESSION['user'] = $payload['nickname'];\n        }\n    }\n    private function ifIsNotClientCheckIfUsernameExists(array $payload, UsersReader $usersReader): void\n    {\n        if ($payload['nickname'] !== self::NORSK_CLIENT) {\n            $usersReader->checkIfUserExists(UserName::by($payload['nickname']));\n        }\n    }\n    private function addExpiration(array $payload): void\n    {\n        if ($payload['exp'] !== null) {\n            $_SESSION['expire'] = $payload['exp'];\n        }\n    }\n    public function destroy(): void\n    {\n        session_unset();\n        session_destroy();\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\user\\Role;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nclass Session\n{\n    private const string NORSK_CLIENT = 'norsk client';\n    private function __construct()\n    {\n        if (session_status() !== PHP_SESSION_NONE) {\n            session_start();\n        }\n    }\n    public static function create(): self\n    {\n        return new self();\n    }\n    public static function getUserName(): UserName\n    {\n        $userName = $_SESSION['user'];\n        self::ensureIsNotNull($userName);\n        return UserName::by($userName);\n    }\n    private static function ensureIsNotNull(?string $userName): void\n    {\n        if ($userName === null) {\n            throw new InvalidArgumentException('Session user is not set.', ResponseCode::serverError->value);\n        }\n    }\n    public static function isValidManager(): bool\n    {\n        return isset($_SESSION['user'], $_SESSION['scope']) && self::isScopeManager();\n    }\n    private static function isScopeManager(): bool\n    {\n        return $_SESSION['scope'] === 'is:' . Role::MANAGER->value;\n    }\n    public function addJwtContent(Payload $payload, UsersReader $usersReader): void\n    {\n        $payloadArray = $payload->asArray();\n        $this->addScope($payloadArray);\n        $this->addUserName($payloadArray, $usersReader);\n        $this->addExpiration($payloadArray);\n    }\n    private function addScope(array $payload): void\n    {\n        if (array_key_exists('scope', $payload) && ($payload['scope'] === 'is:user' || $payload['scope'] === 'is:manager')) {\n            $_SESSION['scope'] = $payload['scope'];\n        }\n    }\n    private function addUserName(array $payload, UsersReader $usersReader): void\n    {\n        if ($payload['nickname'] !== null) {\n            $this->ifTokenIsClientDefaultSetDefaultUserName($payload);\n            $this->ifIsNotClientCheckIfUsernameExists($payload, $usersReader);\n            $_SESSION['user'] = UserName::by($payload['nickname'])->asString();\n        }\n    }\n    private function ifTokenIsClientDefaultSetDefaultUserName(array $payload): void\n    {\n        if ($payload['nickname'] === self::NORSK_CLIENT) {\n            $_SESSION['user'] = $payload['nickname'];\n        }\n    }\n    private function ifIsNotClientCheckIfUsernameExists(array $payload, UsersReader $usersReader): void\n    {\n        if ($payload['nickname'] !== self::NORSK_CLIENT) {\n            $usersReader->checkIfUserExists(UserName::by($payload['nickname']));\n        }\n    }\n    private function addExpiration(array $payload): void\n    {\n        if ($payload['exp'] !== null) {\n            $_SESSION['expire'] = $payload['exp'];\n        }\n    }\n    public function destroy(): void\n    {\n        session_unset();\n        session_destroy();\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/Session.php","originalStartLine":21},"diff":"@@ @@\n     private const string NORSK_CLIENT = 'norsk client';\n     private function __construct()\n     {\n-        if (session_status() === PHP_SESSION_NONE) {\n+        if (session_status() !== PHP_SESSION_NONE) {\n             session_start();\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.fda2e323c3e32fa643b184cb56742049.infection.xml\n\nF\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\SessionTest::testCanCreateSession\nFailed asserting that false is true.\n\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/SessionTest.php:31\n\nFAILURES!\nTests: 1, Assertions: 1, Failures: 1."},{"mutator":{"mutatorName":"FunctionCallRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\user\\Role;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nclass Session\n{\n    private const string NORSK_CLIENT = 'norsk client';\n    private function __construct()\n    {\n        if (session_status() === PHP_SESSION_NONE) {\n            session_start();\n        }\n    }\n    public static function create(): self\n    {\n        return new self();\n    }\n    public static function getUserName(): UserName\n    {\n        $userName = $_SESSION['user'];\n        self::ensureIsNotNull($userName);\n        return UserName::by($userName);\n    }\n    private static function ensureIsNotNull(?string $userName): void\n    {\n        if ($userName === null) {\n            throw new InvalidArgumentException('Session user is not set.', ResponseCode::serverError->value);\n        }\n    }\n    public static function isValidManager(): bool\n    {\n        return isset($_SESSION['user'], $_SESSION['scope']) && self::isScopeManager();\n    }\n    private static function isScopeManager(): bool\n    {\n        return $_SESSION['scope'] === 'is:' . Role::MANAGER->value;\n    }\n    public function addJwtContent(Payload $payload, UsersReader $usersReader): void\n    {\n        $payloadArray = $payload->asArray();\n        $this->addScope($payloadArray);\n        $this->addUserName($payloadArray, $usersReader);\n        $this->addExpiration($payloadArray);\n    }\n    private function addScope(array $payload): void\n    {\n        if (array_key_exists('scope', $payload) && ($payload['scope'] === 'is:user' || $payload['scope'] === 'is:manager')) {\n            $_SESSION['scope'] = $payload['scope'];\n        }\n    }\n    private function addUserName(array $payload, UsersReader $usersReader): void\n    {\n        if ($payload['nickname'] !== null) {\n            $this->ifTokenIsClientDefaultSetDefaultUserName($payload);\n            $this->ifIsNotClientCheckIfUsernameExists($payload, $usersReader);\n            $_SESSION['user'] = UserName::by($payload['nickname'])->asString();\n        }\n    }\n    private function ifTokenIsClientDefaultSetDefaultUserName(array $payload): void\n    {\n        if ($payload['nickname'] === self::NORSK_CLIENT) {\n            $_SESSION['user'] = $payload['nickname'];\n        }\n    }\n    private function ifIsNotClientCheckIfUsernameExists(array $payload, UsersReader $usersReader): void\n    {\n        if ($payload['nickname'] !== self::NORSK_CLIENT) {\n            $usersReader->checkIfUserExists(UserName::by($payload['nickname']));\n        }\n    }\n    private function addExpiration(array $payload): void\n    {\n        if ($payload['exp'] !== null) {\n            $_SESSION['expire'] = $payload['exp'];\n        }\n    }\n    public function destroy(): void\n    {\n        session_unset();\n        session_destroy();\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\user\\Role;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nclass Session\n{\n    private const string NORSK_CLIENT = 'norsk client';\n    private function __construct()\n    {\n        if (session_status() === PHP_SESSION_NONE) {\n            \n        }\n    }\n    public static function create(): self\n    {\n        return new self();\n    }\n    public static function getUserName(): UserName\n    {\n        $userName = $_SESSION['user'];\n        self::ensureIsNotNull($userName);\n        return UserName::by($userName);\n    }\n    private static function ensureIsNotNull(?string $userName): void\n    {\n        if ($userName === null) {\n            throw new InvalidArgumentException('Session user is not set.', ResponseCode::serverError->value);\n        }\n    }\n    public static function isValidManager(): bool\n    {\n        return isset($_SESSION['user'], $_SESSION['scope']) && self::isScopeManager();\n    }\n    private static function isScopeManager(): bool\n    {\n        return $_SESSION['scope'] === 'is:' . Role::MANAGER->value;\n    }\n    public function addJwtContent(Payload $payload, UsersReader $usersReader): void\n    {\n        $payloadArray = $payload->asArray();\n        $this->addScope($payloadArray);\n        $this->addUserName($payloadArray, $usersReader);\n        $this->addExpiration($payloadArray);\n    }\n    private function addScope(array $payload): void\n    {\n        if (array_key_exists('scope', $payload) && ($payload['scope'] === 'is:user' || $payload['scope'] === 'is:manager')) {\n            $_SESSION['scope'] = $payload['scope'];\n        }\n    }\n    private function addUserName(array $payload, UsersReader $usersReader): void\n    {\n        if ($payload['nickname'] !== null) {\n            $this->ifTokenIsClientDefaultSetDefaultUserName($payload);\n            $this->ifIsNotClientCheckIfUsernameExists($payload, $usersReader);\n            $_SESSION['user'] = UserName::by($payload['nickname'])->asString();\n        }\n    }\n    private function ifTokenIsClientDefaultSetDefaultUserName(array $payload): void\n    {\n        if ($payload['nickname'] === self::NORSK_CLIENT) {\n            $_SESSION['user'] = $payload['nickname'];\n        }\n    }\n    private function ifIsNotClientCheckIfUsernameExists(array $payload, UsersReader $usersReader): void\n    {\n        if ($payload['nickname'] !== self::NORSK_CLIENT) {\n            $usersReader->checkIfUserExists(UserName::by($payload['nickname']));\n        }\n    }\n    private function addExpiration(array $payload): void\n    {\n        if ($payload['exp'] !== null) {\n            $_SESSION['expire'] = $payload['exp'];\n        }\n    }\n    public function destroy(): void\n    {\n        session_unset();\n        session_destroy();\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/Session.php","originalStartLine":22},"diff":"@@ @@\n     private function __construct()\n     {\n         if (session_status() === PHP_SESSION_NONE) {\n-            session_start();\n+            \n         }\n     }\n     public static function create(): self","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.3eac25be40f01a36201cd5757d96e461.infection.xml\n\nF\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\SessionTest::testCanCreateSession\nFailed asserting that false is true.\n\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/SessionTest.php:31\n\nFAILURES!\nTests: 1, Assertions: 1, Failures: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\user\\Role;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nclass Session\n{\n    private const string NORSK_CLIENT = 'norsk client';\n    private function __construct()\n    {\n        if (session_status() === PHP_SESSION_NONE) {\n            session_start();\n        }\n    }\n    public static function create(): self\n    {\n        return new self();\n    }\n    public static function getUserName(): UserName\n    {\n        $userName = $_SESSION['user'];\n        self::ensureIsNotNull($userName);\n        return UserName::by($userName);\n    }\n    private static function ensureIsNotNull(?string $userName): void\n    {\n        if ($userName === null) {\n            throw new InvalidArgumentException('Session user is not set.', ResponseCode::serverError->value);\n        }\n    }\n    public static function isValidManager(): bool\n    {\n        return isset($_SESSION['user'], $_SESSION['scope']) && self::isScopeManager();\n    }\n    private static function isScopeManager(): bool\n    {\n        return $_SESSION['scope'] === 'is:' . Role::MANAGER->value;\n    }\n    public function addJwtContent(Payload $payload, UsersReader $usersReader): void\n    {\n        $payloadArray = $payload->asArray();\n        $this->addScope($payloadArray);\n        $this->addUserName($payloadArray, $usersReader);\n        $this->addExpiration($payloadArray);\n    }\n    private function addScope(array $payload): void\n    {\n        if (array_key_exists('scope', $payload) && ($payload['scope'] === 'is:user' || $payload['scope'] === 'is:manager')) {\n            $_SESSION['scope'] = $payload['scope'];\n        }\n    }\n    private function addUserName(array $payload, UsersReader $usersReader): void\n    {\n        if ($payload['nickname'] !== null) {\n            $this->ifTokenIsClientDefaultSetDefaultUserName($payload);\n            $this->ifIsNotClientCheckIfUsernameExists($payload, $usersReader);\n            $_SESSION['user'] = UserName::by($payload['nickname'])->asString();\n        }\n    }\n    private function ifTokenIsClientDefaultSetDefaultUserName(array $payload): void\n    {\n        if ($payload['nickname'] === self::NORSK_CLIENT) {\n            $_SESSION['user'] = $payload['nickname'];\n        }\n    }\n    private function ifIsNotClientCheckIfUsernameExists(array $payload, UsersReader $usersReader): void\n    {\n        if ($payload['nickname'] !== self::NORSK_CLIENT) {\n            $usersReader->checkIfUserExists(UserName::by($payload['nickname']));\n        }\n    }\n    private function addExpiration(array $payload): void\n    {\n        if ($payload['exp'] !== null) {\n            $_SESSION['expire'] = $payload['exp'];\n        }\n    }\n    public function destroy(): void\n    {\n        session_unset();\n        session_destroy();\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\user\\Role;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nclass Session\n{\n    private const string NORSK_CLIENT = 'norsk client';\n    private function __construct()\n    {\n        if (session_status() === PHP_SESSION_NONE) {\n            session_start();\n        }\n    }\n    protected static function create(): self\n    {\n        return new self();\n    }\n    public static function getUserName(): UserName\n    {\n        $userName = $_SESSION['user'];\n        self::ensureIsNotNull($userName);\n        return UserName::by($userName);\n    }\n    private static function ensureIsNotNull(?string $userName): void\n    {\n        if ($userName === null) {\n            throw new InvalidArgumentException('Session user is not set.', ResponseCode::serverError->value);\n        }\n    }\n    public static function isValidManager(): bool\n    {\n        return isset($_SESSION['user'], $_SESSION['scope']) && self::isScopeManager();\n    }\n    private static function isScopeManager(): bool\n    {\n        return $_SESSION['scope'] === 'is:' . Role::MANAGER->value;\n    }\n    public function addJwtContent(Payload $payload, UsersReader $usersReader): void\n    {\n        $payloadArray = $payload->asArray();\n        $this->addScope($payloadArray);\n        $this->addUserName($payloadArray, $usersReader);\n        $this->addExpiration($payloadArray);\n    }\n    private function addScope(array $payload): void\n    {\n        if (array_key_exists('scope', $payload) && ($payload['scope'] === 'is:user' || $payload['scope'] === 'is:manager')) {\n            $_SESSION['scope'] = $payload['scope'];\n        }\n    }\n    private function addUserName(array $payload, UsersReader $usersReader): void\n    {\n        if ($payload['nickname'] !== null) {\n            $this->ifTokenIsClientDefaultSetDefaultUserName($payload);\n            $this->ifIsNotClientCheckIfUsernameExists($payload, $usersReader);\n            $_SESSION['user'] = UserName::by($payload['nickname'])->asString();\n        }\n    }\n    private function ifTokenIsClientDefaultSetDefaultUserName(array $payload): void\n    {\n        if ($payload['nickname'] === self::NORSK_CLIENT) {\n            $_SESSION['user'] = $payload['nickname'];\n        }\n    }\n    private function ifIsNotClientCheckIfUsernameExists(array $payload, UsersReader $usersReader): void\n    {\n        if ($payload['nickname'] !== self::NORSK_CLIENT) {\n            $usersReader->checkIfUserExists(UserName::by($payload['nickname']));\n        }\n    }\n    private function addExpiration(array $payload): void\n    {\n        if ($payload['exp'] !== null) {\n            $_SESSION['expire'] = $payload['exp'];\n        }\n    }\n    public function destroy(): void\n    {\n        session_unset();\n        session_destroy();\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/Session.php","originalStartLine":27},"diff":"@@ @@\n             session_start();\n         }\n     }\n-    public static function create(): self\n+    protected static function create(): self\n     {\n         return new self();\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.73ac7f409492a9d498ee5f8ffd1d21e6.infection.xml\n\nE\n\nTime: 00:00.001, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\SessionTest::testCanCreateSession\nError: Call to protected method norsk\\api\\app\\identityAccessManagement\\Session::create() from scope norsk\\api\\app\\identityAccessManagement\\SessionTest\n\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/SessionTest.php:149\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\user\\Role;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nclass Session\n{\n    private const string NORSK_CLIENT = 'norsk client';\n    private function __construct()\n    {\n        if (session_status() === PHP_SESSION_NONE) {\n            session_start();\n        }\n    }\n    public static function create(): self\n    {\n        return new self();\n    }\n    public static function getUserName(): UserName\n    {\n        $userName = $_SESSION['user'];\n        self::ensureIsNotNull($userName);\n        return UserName::by($userName);\n    }\n    private static function ensureIsNotNull(?string $userName): void\n    {\n        if ($userName === null) {\n            throw new InvalidArgumentException('Session user is not set.', ResponseCode::serverError->value);\n        }\n    }\n    public static function isValidManager(): bool\n    {\n        return isset($_SESSION['user'], $_SESSION['scope']) && self::isScopeManager();\n    }\n    private static function isScopeManager(): bool\n    {\n        return $_SESSION['scope'] === 'is:' . Role::MANAGER->value;\n    }\n    public function addJwtContent(Payload $payload, UsersReader $usersReader): void\n    {\n        $payloadArray = $payload->asArray();\n        $this->addScope($payloadArray);\n        $this->addUserName($payloadArray, $usersReader);\n        $this->addExpiration($payloadArray);\n    }\n    private function addScope(array $payload): void\n    {\n        if (array_key_exists('scope', $payload) && ($payload['scope'] === 'is:user' || $payload['scope'] === 'is:manager')) {\n            $_SESSION['scope'] = $payload['scope'];\n        }\n    }\n    private function addUserName(array $payload, UsersReader $usersReader): void\n    {\n        if ($payload['nickname'] !== null) {\n            $this->ifTokenIsClientDefaultSetDefaultUserName($payload);\n            $this->ifIsNotClientCheckIfUsernameExists($payload, $usersReader);\n            $_SESSION['user'] = UserName::by($payload['nickname'])->asString();\n        }\n    }\n    private function ifTokenIsClientDefaultSetDefaultUserName(array $payload): void\n    {\n        if ($payload['nickname'] === self::NORSK_CLIENT) {\n            $_SESSION['user'] = $payload['nickname'];\n        }\n    }\n    private function ifIsNotClientCheckIfUsernameExists(array $payload, UsersReader $usersReader): void\n    {\n        if ($payload['nickname'] !== self::NORSK_CLIENT) {\n            $usersReader->checkIfUserExists(UserName::by($payload['nickname']));\n        }\n    }\n    private function addExpiration(array $payload): void\n    {\n        if ($payload['exp'] !== null) {\n            $_SESSION['expire'] = $payload['exp'];\n        }\n    }\n    public function destroy(): void\n    {\n        session_unset();\n        session_destroy();\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\user\\Role;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nclass Session\n{\n    private const string NORSK_CLIENT = 'norsk client';\n    private function __construct()\n    {\n        if (session_status() === PHP_SESSION_NONE) {\n            session_start();\n        }\n    }\n    public static function create(): self\n    {\n        return new self();\n    }\n    protected static function getUserName(): UserName\n    {\n        $userName = $_SESSION['user'];\n        self::ensureIsNotNull($userName);\n        return UserName::by($userName);\n    }\n    private static function ensureIsNotNull(?string $userName): void\n    {\n        if ($userName === null) {\n            throw new InvalidArgumentException('Session user is not set.', ResponseCode::serverError->value);\n        }\n    }\n    public static function isValidManager(): bool\n    {\n        return isset($_SESSION['user'], $_SESSION['scope']) && self::isScopeManager();\n    }\n    private static function isScopeManager(): bool\n    {\n        return $_SESSION['scope'] === 'is:' . Role::MANAGER->value;\n    }\n    public function addJwtContent(Payload $payload, UsersReader $usersReader): void\n    {\n        $payloadArray = $payload->asArray();\n        $this->addScope($payloadArray);\n        $this->addUserName($payloadArray, $usersReader);\n        $this->addExpiration($payloadArray);\n    }\n    private function addScope(array $payload): void\n    {\n        if (array_key_exists('scope', $payload) && ($payload['scope'] === 'is:user' || $payload['scope'] === 'is:manager')) {\n            $_SESSION['scope'] = $payload['scope'];\n        }\n    }\n    private function addUserName(array $payload, UsersReader $usersReader): void\n    {\n        if ($payload['nickname'] !== null) {\n            $this->ifTokenIsClientDefaultSetDefaultUserName($payload);\n            $this->ifIsNotClientCheckIfUsernameExists($payload, $usersReader);\n            $_SESSION['user'] = UserName::by($payload['nickname'])->asString();\n        }\n    }\n    private function ifTokenIsClientDefaultSetDefaultUserName(array $payload): void\n    {\n        if ($payload['nickname'] === self::NORSK_CLIENT) {\n            $_SESSION['user'] = $payload['nickname'];\n        }\n    }\n    private function ifIsNotClientCheckIfUsernameExists(array $payload, UsersReader $usersReader): void\n    {\n        if ($payload['nickname'] !== self::NORSK_CLIENT) {\n            $usersReader->checkIfUserExists(UserName::by($payload['nickname']));\n        }\n    }\n    private function addExpiration(array $payload): void\n    {\n        if ($payload['exp'] !== null) {\n            $_SESSION['expire'] = $payload['exp'];\n        }\n    }\n    public function destroy(): void\n    {\n        session_unset();\n        session_destroy();\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/Session.php","originalStartLine":33},"diff":"@@ @@\n     {\n         return new self();\n     }\n-    public static function getUserName(): UserName\n+    protected static function getUserName(): UserName\n     {\n         $userName = $_SESSION['user'];\n         self::ensureIsNotNull($userName);","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.18d3cf6c54b2472a3f70d4cd76a26439.infection.xml\n\n.E\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\SessionTest::testCanGetUserName\nError: Call to protected method norsk\\api\\app\\identityAccessManagement\\Session::getUserName() from scope norsk\\api\\app\\identityAccessManagement\\SessionTest\n\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/SessionTest.php:39\n\nERRORS!\nTests: 2, Assertions: 2, Errors: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\user\\Role;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nclass Session\n{\n    private const string NORSK_CLIENT = 'norsk client';\n    private function __construct()\n    {\n        if (session_status() === PHP_SESSION_NONE) {\n            session_start();\n        }\n    }\n    public static function create(): self\n    {\n        return new self();\n    }\n    public static function getUserName(): UserName\n    {\n        $userName = $_SESSION['user'];\n        self::ensureIsNotNull($userName);\n        return UserName::by($userName);\n    }\n    private static function ensureIsNotNull(?string $userName): void\n    {\n        if ($userName === null) {\n            throw new InvalidArgumentException('Session user is not set.', ResponseCode::serverError->value);\n        }\n    }\n    public static function isValidManager(): bool\n    {\n        return isset($_SESSION['user'], $_SESSION['scope']) && self::isScopeManager();\n    }\n    private static function isScopeManager(): bool\n    {\n        return $_SESSION['scope'] === 'is:' . Role::MANAGER->value;\n    }\n    public function addJwtContent(Payload $payload, UsersReader $usersReader): void\n    {\n        $payloadArray = $payload->asArray();\n        $this->addScope($payloadArray);\n        $this->addUserName($payloadArray, $usersReader);\n        $this->addExpiration($payloadArray);\n    }\n    private function addScope(array $payload): void\n    {\n        if (array_key_exists('scope', $payload) && ($payload['scope'] === 'is:user' || $payload['scope'] === 'is:manager')) {\n            $_SESSION['scope'] = $payload['scope'];\n        }\n    }\n    private function addUserName(array $payload, UsersReader $usersReader): void\n    {\n        if ($payload['nickname'] !== null) {\n            $this->ifTokenIsClientDefaultSetDefaultUserName($payload);\n            $this->ifIsNotClientCheckIfUsernameExists($payload, $usersReader);\n            $_SESSION['user'] = UserName::by($payload['nickname'])->asString();\n        }\n    }\n    private function ifTokenIsClientDefaultSetDefaultUserName(array $payload): void\n    {\n        if ($payload['nickname'] === self::NORSK_CLIENT) {\n            $_SESSION['user'] = $payload['nickname'];\n        }\n    }\n    private function ifIsNotClientCheckIfUsernameExists(array $payload, UsersReader $usersReader): void\n    {\n        if ($payload['nickname'] !== self::NORSK_CLIENT) {\n            $usersReader->checkIfUserExists(UserName::by($payload['nickname']));\n        }\n    }\n    private function addExpiration(array $payload): void\n    {\n        if ($payload['exp'] !== null) {\n            $_SESSION['expire'] = $payload['exp'];\n        }\n    }\n    public function destroy(): void\n    {\n        session_unset();\n        session_destroy();\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\user\\Role;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nclass Session\n{\n    private const string NORSK_CLIENT = 'norsk client';\n    private function __construct()\n    {\n        if (session_status() === PHP_SESSION_NONE) {\n            session_start();\n        }\n    }\n    public static function create(): self\n    {\n        return new self();\n    }\n    public static function getUserName(): UserName\n    {\n        $userName = $_SESSION['user'];\n        \n        return UserName::by($userName);\n    }\n    private static function ensureIsNotNull(?string $userName): void\n    {\n        if ($userName === null) {\n            throw new InvalidArgumentException('Session user is not set.', ResponseCode::serverError->value);\n        }\n    }\n    public static function isValidManager(): bool\n    {\n        return isset($_SESSION['user'], $_SESSION['scope']) && self::isScopeManager();\n    }\n    private static function isScopeManager(): bool\n    {\n        return $_SESSION['scope'] === 'is:' . Role::MANAGER->value;\n    }\n    public function addJwtContent(Payload $payload, UsersReader $usersReader): void\n    {\n        $payloadArray = $payload->asArray();\n        $this->addScope($payloadArray);\n        $this->addUserName($payloadArray, $usersReader);\n        $this->addExpiration($payloadArray);\n    }\n    private function addScope(array $payload): void\n    {\n        if (array_key_exists('scope', $payload) && ($payload['scope'] === 'is:user' || $payload['scope'] === 'is:manager')) {\n            $_SESSION['scope'] = $payload['scope'];\n        }\n    }\n    private function addUserName(array $payload, UsersReader $usersReader): void\n    {\n        if ($payload['nickname'] !== null) {\n            $this->ifTokenIsClientDefaultSetDefaultUserName($payload);\n            $this->ifIsNotClientCheckIfUsernameExists($payload, $usersReader);\n            $_SESSION['user'] = UserName::by($payload['nickname'])->asString();\n        }\n    }\n    private function ifTokenIsClientDefaultSetDefaultUserName(array $payload): void\n    {\n        if ($payload['nickname'] === self::NORSK_CLIENT) {\n            $_SESSION['user'] = $payload['nickname'];\n        }\n    }\n    private function ifIsNotClientCheckIfUsernameExists(array $payload, UsersReader $usersReader): void\n    {\n        if ($payload['nickname'] !== self::NORSK_CLIENT) {\n            $usersReader->checkIfUserExists(UserName::by($payload['nickname']));\n        }\n    }\n    private function addExpiration(array $payload): void\n    {\n        if ($payload['exp'] !== null) {\n            $_SESSION['expire'] = $payload['exp'];\n        }\n    }\n    public function destroy(): void\n    {\n        session_unset();\n        session_destroy();\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/Session.php","originalStartLine":36},"diff":"@@ @@\n     public static function getUserName(): UserName\n     {\n         $userName = $_SESSION['user'];\n-        self::ensureIsNotNull($userName);\n+        \n         return UserName::by($userName);\n     }\n     private static function ensureIsNotNull(?string $userName): void","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.cf124381e613ecdb78c9f98952d16e3f.infection.xml\n\n..F\n\nTime: 00:00.005, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\SessionTest::testCanGetUnsetUserName\nFailed asserting that exception of type \"TypeError\" matches expected exception \"InvalidArgumentException\". Message was: \"norsk\\api\\user\\UserName::by(): Argument #1 ($userName) must be of type string, null given, called in \/app\/api\/src\/app\/identityAccessManagement\/Session.php on line 29\" at\n\/app\/api\/src\/user\/UserName.php:22\n\/app\/api\/src\/app\/identityAccessManagement\/Session.php:29\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/SessionTest.php:48\n.\n\nFAILURES!\nTests: 3, Assertions: 4, Failures: 1, Warnings: 1."},{"mutator":{"mutatorName":"Identical","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\user\\Role;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nclass Session\n{\n    private const string NORSK_CLIENT = 'norsk client';\n    private function __construct()\n    {\n        if (session_status() === PHP_SESSION_NONE) {\n            session_start();\n        }\n    }\n    public static function create(): self\n    {\n        return new self();\n    }\n    public static function getUserName(): UserName\n    {\n        $userName = $_SESSION['user'];\n        self::ensureIsNotNull($userName);\n        return UserName::by($userName);\n    }\n    private static function ensureIsNotNull(?string $userName): void\n    {\n        if ($userName === null) {\n            throw new InvalidArgumentException('Session user is not set.', ResponseCode::serverError->value);\n        }\n    }\n    public static function isValidManager(): bool\n    {\n        return isset($_SESSION['user'], $_SESSION['scope']) && self::isScopeManager();\n    }\n    private static function isScopeManager(): bool\n    {\n        return $_SESSION['scope'] === 'is:' . Role::MANAGER->value;\n    }\n    public function addJwtContent(Payload $payload, UsersReader $usersReader): void\n    {\n        $payloadArray = $payload->asArray();\n        $this->addScope($payloadArray);\n        $this->addUserName($payloadArray, $usersReader);\n        $this->addExpiration($payloadArray);\n    }\n    private function addScope(array $payload): void\n    {\n        if (array_key_exists('scope', $payload) && ($payload['scope'] === 'is:user' || $payload['scope'] === 'is:manager')) {\n            $_SESSION['scope'] = $payload['scope'];\n        }\n    }\n    private function addUserName(array $payload, UsersReader $usersReader): void\n    {\n        if ($payload['nickname'] !== null) {\n            $this->ifTokenIsClientDefaultSetDefaultUserName($payload);\n            $this->ifIsNotClientCheckIfUsernameExists($payload, $usersReader);\n            $_SESSION['user'] = UserName::by($payload['nickname'])->asString();\n        }\n    }\n    private function ifTokenIsClientDefaultSetDefaultUserName(array $payload): void\n    {\n        if ($payload['nickname'] === self::NORSK_CLIENT) {\n            $_SESSION['user'] = $payload['nickname'];\n        }\n    }\n    private function ifIsNotClientCheckIfUsernameExists(array $payload, UsersReader $usersReader): void\n    {\n        if ($payload['nickname'] !== self::NORSK_CLIENT) {\n            $usersReader->checkIfUserExists(UserName::by($payload['nickname']));\n        }\n    }\n    private function addExpiration(array $payload): void\n    {\n        if ($payload['exp'] !== null) {\n            $_SESSION['expire'] = $payload['exp'];\n        }\n    }\n    public function destroy(): void\n    {\n        session_unset();\n        session_destroy();\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\user\\Role;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nclass Session\n{\n    private const string NORSK_CLIENT = 'norsk client';\n    private function __construct()\n    {\n        if (session_status() === PHP_SESSION_NONE) {\n            session_start();\n        }\n    }\n    public static function create(): self\n    {\n        return new self();\n    }\n    public static function getUserName(): UserName\n    {\n        $userName = $_SESSION['user'];\n        self::ensureIsNotNull($userName);\n        return UserName::by($userName);\n    }\n    private static function ensureIsNotNull(?string $userName): void\n    {\n        if ($userName !== null) {\n            throw new InvalidArgumentException('Session user is not set.', ResponseCode::serverError->value);\n        }\n    }\n    public static function isValidManager(): bool\n    {\n        return isset($_SESSION['user'], $_SESSION['scope']) && self::isScopeManager();\n    }\n    private static function isScopeManager(): bool\n    {\n        return $_SESSION['scope'] === 'is:' . Role::MANAGER->value;\n    }\n    public function addJwtContent(Payload $payload, UsersReader $usersReader): void\n    {\n        $payloadArray = $payload->asArray();\n        $this->addScope($payloadArray);\n        $this->addUserName($payloadArray, $usersReader);\n        $this->addExpiration($payloadArray);\n    }\n    private function addScope(array $payload): void\n    {\n        if (array_key_exists('scope', $payload) && ($payload['scope'] === 'is:user' || $payload['scope'] === 'is:manager')) {\n            $_SESSION['scope'] = $payload['scope'];\n        }\n    }\n    private function addUserName(array $payload, UsersReader $usersReader): void\n    {\n        if ($payload['nickname'] !== null) {\n            $this->ifTokenIsClientDefaultSetDefaultUserName($payload);\n            $this->ifIsNotClientCheckIfUsernameExists($payload, $usersReader);\n            $_SESSION['user'] = UserName::by($payload['nickname'])->asString();\n        }\n    }\n    private function ifTokenIsClientDefaultSetDefaultUserName(array $payload): void\n    {\n        if ($payload['nickname'] === self::NORSK_CLIENT) {\n            $_SESSION['user'] = $payload['nickname'];\n        }\n    }\n    private function ifIsNotClientCheckIfUsernameExists(array $payload, UsersReader $usersReader): void\n    {\n        if ($payload['nickname'] !== self::NORSK_CLIENT) {\n            $usersReader->checkIfUserExists(UserName::by($payload['nickname']));\n        }\n    }\n    private function addExpiration(array $payload): void\n    {\n        if ($payload['exp'] !== null) {\n            $_SESSION['expire'] = $payload['exp'];\n        }\n    }\n    public function destroy(): void\n    {\n        session_unset();\n        session_destroy();\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/Session.php","originalStartLine":44},"diff":"@@ @@\n     }\n     private static function ensureIsNotNull(?string $userName): void\n     {\n-        if ($userName === null) {\n+        if ($userName !== null) {\n             throw new InvalidArgumentException('Session user is not set.', ResponseCode::serverError->value);\n         }\n     }","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.4057eb8a7f5565cee9a8150a93095c0d.infection.xml\n\n.E\n\nTime: 00:00.002, Memory: 18.00 MB\n\nThere was 1 error:\n\n1) norsk\\api\\app\\identityAccessManagement\\SessionTest::testCanGetUserName\nInvalidArgumentException: Session user is not set.\n\n\/app\/api\/src\/app\/identityAccessManagement\/Session.php:34\n\/app\/api\/src\/app\/identityAccessManagement\/Session.php:28\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/SessionTest.php:39\n\nERRORS!\nTests: 2, Assertions: 2, Errors: 1."},{"mutator":{"mutatorName":"Throw_","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\user\\Role;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nclass Session\n{\n    private const string NORSK_CLIENT = 'norsk client';\n    private function __construct()\n    {\n        if (session_status() === PHP_SESSION_NONE) {\n            session_start();\n        }\n    }\n    public static function create(): self\n    {\n        return new self();\n    }\n    public static function getUserName(): UserName\n    {\n        $userName = $_SESSION['user'];\n        self::ensureIsNotNull($userName);\n        return UserName::by($userName);\n    }\n    private static function ensureIsNotNull(?string $userName): void\n    {\n        if ($userName === null) {\n            throw new InvalidArgumentException('Session user is not set.', ResponseCode::serverError->value);\n        }\n    }\n    public static function isValidManager(): bool\n    {\n        return isset($_SESSION['user'], $_SESSION['scope']) && self::isScopeManager();\n    }\n    private static function isScopeManager(): bool\n    {\n        return $_SESSION['scope'] === 'is:' . Role::MANAGER->value;\n    }\n    public function addJwtContent(Payload $payload, UsersReader $usersReader): void\n    {\n        $payloadArray = $payload->asArray();\n        $this->addScope($payloadArray);\n        $this->addUserName($payloadArray, $usersReader);\n        $this->addExpiration($payloadArray);\n    }\n    private function addScope(array $payload): void\n    {\n        if (array_key_exists('scope', $payload) && ($payload['scope'] === 'is:user' || $payload['scope'] === 'is:manager')) {\n            $_SESSION['scope'] = $payload['scope'];\n        }\n    }\n    private function addUserName(array $payload, UsersReader $usersReader): void\n    {\n        if ($payload['nickname'] !== null) {\n            $this->ifTokenIsClientDefaultSetDefaultUserName($payload);\n            $this->ifIsNotClientCheckIfUsernameExists($payload, $usersReader);\n            $_SESSION['user'] = UserName::by($payload['nickname'])->asString();\n        }\n    }\n    private function ifTokenIsClientDefaultSetDefaultUserName(array $payload): void\n    {\n        if ($payload['nickname'] === self::NORSK_CLIENT) {\n            $_SESSION['user'] = $payload['nickname'];\n        }\n    }\n    private function ifIsNotClientCheckIfUsernameExists(array $payload, UsersReader $usersReader): void\n    {\n        if ($payload['nickname'] !== self::NORSK_CLIENT) {\n            $usersReader->checkIfUserExists(UserName::by($payload['nickname']));\n        }\n    }\n    private function addExpiration(array $payload): void\n    {\n        if ($payload['exp'] !== null) {\n            $_SESSION['expire'] = $payload['exp'];\n        }\n    }\n    public function destroy(): void\n    {\n        session_unset();\n        session_destroy();\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace norsk\\api\\app\\identityAccessManagement;\n\nuse InvalidArgumentException;\nuse norsk\\api\\app\\request\\Payload;\nuse norsk\\api\\app\\response\\ResponseCode;\nuse norsk\\api\\user\\Role;\nuse norsk\\api\\user\\UserName;\nuse norsk\\api\\user\\UsersReader;\nclass Session\n{\n    private const string NORSK_CLIENT = 'norsk client';\n    private function __construct()\n    {\n        if (session_status() === PHP_SESSION_NONE) {\n            session_start();\n        }\n    }\n    public static function create(): self\n    {\n        return new self();\n    }\n    public static function getUserName(): UserName\n    {\n        $userName = $_SESSION['user'];\n        self::ensureIsNotNull($userName);\n        return UserName::by($userName);\n    }\n    private static function ensureIsNotNull(?string $userName): void\n    {\n        if ($userName === null) {\n            new InvalidArgumentException('Session user is not set.', ResponseCode::serverError->value);\n        }\n    }\n    public static function isValidManager(): bool\n    {\n        return isset($_SESSION['user'], $_SESSION['scope']) && self::isScopeManager();\n    }\n    private static function isScopeManager(): bool\n    {\n        return $_SESSION['scope'] === 'is:' . Role::MANAGER->value;\n    }\n    public function addJwtContent(Payload $payload, UsersReader $usersReader): void\n    {\n        $payloadArray = $payload->asArray();\n        $this->addScope($payloadArray);\n        $this->addUserName($payloadArray, $usersReader);\n        $this->addExpiration($payloadArray);\n    }\n    private function addScope(array $payload): void\n    {\n        if (array_key_exists('scope', $payload) && ($payload['scope'] === 'is:user' || $payload['scope'] === 'is:manager')) {\n            $_SESSION['scope'] = $payload['scope'];\n        }\n    }\n    private function addUserName(array $payload, UsersReader $usersReader): void\n    {\n        if ($payload['nickname'] !== null) {\n            $this->ifTokenIsClientDefaultSetDefaultUserName($payload);\n            $this->ifIsNotClientCheckIfUsernameExists($payload, $usersReader);\n            $_SESSION['user'] = UserName::by($payload['nickname'])->asString();\n        }\n    }\n    private function ifTokenIsClientDefaultSetDefaultUserName(array $payload): void\n    {\n        if ($payload['nickname'] === self::NORSK_CLIENT) {\n            $_SESSION['user'] = $payload['nickname'];\n        }\n    }\n    private function ifIsNotClientCheckIfUsernameExists(array $payload, UsersReader $usersReader): void\n    {\n        if ($payload['nickname'] !== self::NORSK_CLIENT) {\n            $usersReader->checkIfUserExists(UserName::by($payload['nickname']));\n        }\n    }\n    private function addExpiration(array $payload): void\n    {\n        if ($payload['exp'] !== null) {\n            $_SESSION['expire'] = $payload['exp'];\n        }\n    }\n    public function destroy(): void\n    {\n        session_unset();\n        session_destroy();\n    }\n}","originalFilePath":"\/app\/api\/src\/app\/identityAccessManagement\/Session.php","originalStartLine":45},"diff":"@@ @@\n     private static function ensureIsNotNull(?string $userName): void\n     {\n         if ($userName === null) {\n-            throw new InvalidArgumentException('Session user is not set.', ResponseCode::serverError->value);\n+            new InvalidArgumentException('Session user is not set.', ResponseCode::serverError->value);\n         }\n     }\n     public static function isValidManager(): bool","processOutput":"PHPUnit 12.2.2 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.3.22\nConfiguration: \/opt\/tmp-folder\/infection\/phpunitConfiguration.a58ea935ff1143b4c4bc872e12d1d90f.infection.xml\n\n..F\n\nTime: 00:00.004, Memory: 18.00 MB\n\nThere was 1 failure:\n\n1) norsk\\api\\app\\identityAccessManagement\\SessionTest::testCanGetUnsetUserName\nFailed asserting that exception of type \"TypeError\" matches expected exception \"InvalidArgumentException\". Message was: \"norsk\\api\\user\\UserName::by(): Argument #1 ($userName) must be of type string, null given, called in \/app\/api\/src\/app\/identityAccessManagement\/Session.php on line 29\" at\n\/app\/api\/src\/user\/UserName.php:22\n\/app\/api\/src\/app\/identityAccessManagement\/Session.php:29\n\/app\/api\/tests\/unit\/app\/identityAccessManagement\/SessionTest.php:48\n.\n\nFAILURES!\nTests: 3, Assertions: 4, Failures: 1, Warnings: 1."}],"errored":[],"syntaxErrors":[],"uncovered":[],"ignored":[]}