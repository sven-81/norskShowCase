<?php

declare(strict_types=1);

namespace norsk\api\app\identityAccessManagement;

use Firebase\JWT\BeforeValidException;
use Firebase\JWT\ExpiredException;
use Firebase\JWT\JWT;
use Firebase\JWT\Key;
use Firebase\JWT\SignatureInvalidException;
use InvalidArgumentException;
use norsk\api\app\config\AppConfig;
use norsk\api\app\logging\Logger;
use norsk\api\app\logging\LogMessage;
use norsk\api\app\request\Payload;
use norsk\api\shared\SanitizedClientInput;
use norsk\api\user\UsersReader;
use norsk\api\user\ValidatedUser;
use Psr\Clock\ClockInterface;
use Psr\Http\Message\ServerRequestInterface;
use RuntimeException;
use stdClass;
use Throwable;

class JwtManagement
{
    private const int TWO_HOURS_IN_SECONDS = 7200;
    private const string NORSK_APP_SUB = 'norsk app';
    private const string NORSK_CLIENT = 'Norsk Client';


    public function __construct(
        private readonly AppConfig $appConfig,
        private readonly ClockInterface $clock,
        private readonly Logger $logger,
        private readonly UsersReader $usersReader,
    ) {
    }


    public function create(ValidatedUser $validatedUser): JsonWebToken
    {
        $role = $validatedUser->getRole();

        $jwtConfig = $this->appConfig->getJwtConfig();
        $futureClock = $this->clock->addSeconds(self::TWO_HOURS_IN_SECONDS);
        $payload = [
            'sub' => $jwtConfig->getSubject()->asString(),
            'aud' => $jwtConfig->getAudience()->asString(),
            'iat' => $this->clock->getTimestamp(),
            'exp' => $futureClock->getTimestamp(),
            'scope' => "is:" . $role->value,
            'nickname' => $validatedUser->getUsername()->asString(),
        ];

        $jwt = JWT::encode(
            $payload,
            $jwtConfig->getAuthKey()->asBase64String(),
            $jwtConfig->getAlgorithm()->asString()
        );

        return JsonWebToken::fromString($jwt);
    }


    public function validate(ServerRequestInterface $request, Session $session): void
    {
        $tokenString = $request->getHeader('Authorization')[0];
        $token = JsonWebToken::fromBearerString(SanitizedClientInput::of($tokenString)->asString());

        $decodedPayload = $this->validateJwtToken($token);
        $this->validateJwtContent($decodedPayload, $session);

        $this->logger->info(LogMessage::fromString('Jwt is valid'));
    }


    private function validateJwtToken(JsonWebToken $token): stdClass
    {
        try {
            $jwtConfig = $this->appConfig->getJwtConfig();
            $secretKey64 = $jwtConfig->getAuthKey()->asBase64String();
            $headersCodec = $jwtConfig->getAlgorithm()->asString();

            return JWT::decode($token->asString(), new Key($secretKey64, $headersCodec));
        } catch (Throwable $throwable) {
            $this->logger->error($throwable);

            return match (true) {
                $throwable instanceof ExpiredException => throw new RuntimeException(
                    'Token expired: ' . $throwable->getMessage()
                ),
                $throwable instanceof SignatureInvalidException => throw new RuntimeException(
                    'Invalid token signature: ' . $throwable->getMessage()
                ),
                $throwable instanceof BeforeValidException => throw new RuntimeException(
                    'Token not valid yet: ' . $throwable->getMessage()
                ),

                default => throw new RuntimeException('Invalid token: ' . $throwable->getMessage()),
            };
        }
    }


    private function validateJwtContent(stdClass $decodedPayload, Session $session): void
    {
        $this->ensureSubjectIsValid($decodedPayload);
        $this->ensureAudienceIsValid($decodedPayload);

        $payload = Payload::by($decodedPayload);
        $session->addJwtContent($payload, $this->usersReader);
    }


    private function ensureSubjectIsValid(stdClass $decodedPayload): void
    {
        if (!property_exists($decodedPayload, 'sub') || $decodedPayload->sub !== self::NORSK_APP_SUB) {
            throw new InvalidArgumentException('Token was not generated by Api');
        }
    }


    private function ensureAudienceIsValid(stdClass $decodedPayload): void
    {
        if (!property_exists($decodedPayload, 'aud') || $decodedPayload->aud !== self::NORSK_CLIENT) {
            throw new InvalidArgumentException('Token was not sent from Client');
        }
    }
}
