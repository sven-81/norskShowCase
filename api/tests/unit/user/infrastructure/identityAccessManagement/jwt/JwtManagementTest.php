<?php

declare(strict_types=1);

namespace norsk\api\user\infrastructure\identityAccessManagement\jwt;

use GuzzleHttp\Psr7\ServerRequest;
use InvalidArgumentException;
use norsk\api\infrastructure\config\AppConfig;
use norsk\api\infrastructure\logging\Logger;
use norsk\api\infrastructure\logging\LogMessage;
use norsk\api\tests\stubs\MutableTestClock;
use norsk\api\user\domain\model\Role;
use norsk\api\user\domain\model\ValidatedUser;
use norsk\api\user\domain\valueObjects\UserName;
use norsk\api\user\infrastructure\identityAccessManagement\authentication\AuthenticationAlgorithm;
use norsk\api\user\infrastructure\identityAccessManagement\authentication\AuthenticationKey;
use norsk\api\user\infrastructure\identityAccessManagement\EnhancedClock;
use norsk\api\user\infrastructure\persistence\UsersReader;
use PHPUnit\Framework\Attributes\CoversClass;
use PHPUnit\Framework\Attributes\DataProvider;
use PHPUnit\Framework\MockObject\MockObject;
use PHPUnit\Framework\TestCase;
use RuntimeException;

#[CoversClass(JwtManagement::class)]
class JwtManagementTest extends TestCase
{
    private const string BASE_PATH = __DIR__ . '/../../resources/jwt/';

    private MockObject|AppConfig $appConfigMock;

    private MockObject|JwtConfig $jwtConfigMock;

    private ValidatedUser|MockObject $validatedUserMock;

    private Logger|MockObject $loggerMock;

    private UsersReader|MockObject $usersReaderMock;

    private MockObject|ServerRequest $requestMock;

    private EnhancedClock $presentClock;


    protected function setUp(): void
    {
        $this->appConfigMock = $this->createMock(AppConfig::class);
        $this->jwtConfigMock = $this->createMock(JwtConfig::class);
        $this->validatedUserMock = $this->createMock(ValidatedUser::class);
        $this->loggerMock = $this->createMock(Logger::class);
        $this->usersReaderMock = $this->createMock(UsersReader::class);
        $this->requestMock = $this->createMock(ServerRequest::class);

        $initialTime = new MutableTestClock();
        $initialTime->setTo('2024-09-27 19:41:52');
        $this->presentClock = new EnhancedClock($initialTime);

        $this->validatedUserMock->method('getRole')
            ->willReturn(Role::USER);
    }


    public static function getTokenForScope(): array
    {
        return [
            'user' => ['validUserTokenWithTime.jwt'],
            'manager' => ['validManagerTokenWithTime.jwt'],
        ];
    }


    public static function getTokenForNickname(): array
    {
        return [
            'someUser' => ['klaus', 'validUserTokenWithTime.jwt'],
            'client' => ['norsk client', 'validClientTokenWithTime.jwt'],
        ];
    }


    public static function getManipulatedInvalidToken(): array
    {
        return [
            'notFromApp' => ['invalidTokenNotFromApp.jwt', 'Token was not generated by Api'],
            'manipulatedClient' => ['invalidTokenWithManipulatedClient.jwt', 'Token was not sent from Client',],
        ];
    }


    public static function getInvalidToken(): array
    {
        return [
            'TokenExpired' => ['invalidExpired.jwt', 'Token expired'],
            'SignatureInvalid' => ['invalidSignature.jwt', 'Invalid token signature',],
            'BeforeValid' => ['invalidNotValidYet.jwt', 'Token not valid yet',],
            'GeneralInvalidToken' => ['invalid.jwt', 'Invalid token',],
        ];
    }


    private function configureJwtConfig(
        int $subject,
        int $audience,
        int $algorithm,
        int $key,
        string $algorithmMethod = 'HS256',
    ): void {
        $this->jwtConfigMock->expects($this->exactly($subject))
            ->method('getSubject')
            ->willReturn(JwtSubject::by('norsk app'));
        $this->jwtConfigMock->expects($this->exactly($audience))
            ->method('getAudience')
            ->willReturn(JwtAudience::by('Norsk Client'));
        $this->jwtConfigMock->expects($this->exactly($algorithm))
            ->method('getAlgorithm')
            ->willReturn(AuthenticationAlgorithm::by($algorithmMethod));

        $this->jwtConfigMock->expects($this->exactly($key))
            ->method('getAuthKey')
            ->willReturn(
                AuthenticationKey::by('ABCDEFGHIJKLMnopqrstuvwxyz0123456789')
            );
    }


    public function testCanCreateJwt(): void
    {
        $validToken = JsonWebToken::fromString(
            file_get_contents(self::BASE_PATH . 'validToken.jwt')
        );

        $this->configureJwtConfig(subject: 1, audience: 1, algorithm: 1, key: 1);

        $this->appConfigMock->expects($this->once())
            ->method('getJwtConfig')
            ->willReturn($this->jwtConfigMock);

        $JwtManagement = new JwtManagement(
            $this->appConfigMock,
            $this->presentClock,
            $this->loggerMock
        );
        $jsonWebToken = $JwtManagement->create($this->validatedUserMock);

        self::assertEquals($validToken, $jsonWebToken, 'Jwt should be created');
    }


    public function testCanValidateCreatedToken(): void
    {
        $this->configureJwtConfig(subject: 1, audience: 1, algorithm: 2, key: 2);

        $this->appConfigMock
            ->method('getJwtConfig')
            ->willReturn($this->jwtConfigMock);

        $initialTime = new MutableTestClock();
        $presentClock = new EnhancedClock($initialTime);

        $this->validatedUserMock->method('getUserName')
            ->willReturn(UserName::by('klaus'));

        $this->loggerMock->expects($this->once())
            ->method('info')
            ->with(LogMessage::fromString('Jwt is valid'));

        $jwtManagement = new JwtManagement(
            $this->appConfigMock,
            $presentClock,
            $this->loggerMock
        );
        $jsonWebToken = $jwtManagement->create($this->validatedUserMock);
        $requestJwt = 'Bearer ' . $jsonWebToken->asString();

        $this->requestMock->method('getHeader')
            ->willReturn([$requestJwt]);

        $jwtManagement->validate($this->requestMock);
    }


    #[DataProvider('getTokenForScope')]
    public function testCanValidateGivenTokenForScope(string $jwt): void
    {
        $token = JsonWebToken::fromString(
            file_get_contents(self::BASE_PATH . $jwt)
        );
        $requestJwt = 'Bearer ' . $token->asString();

        $this->requestMock->method('getHeader')
            ->willReturn([$requestJwt]);

        $this->loggerMock->expects($this->once())
            ->method('info')
            ->with(LogMessage::fromString('Jwt is valid'));

        $this->configureJwtConfig(0, 0, 1, 1, 'HS512');

        $this->appConfigMock
            ->method('getJwtConfig')
            ->willReturn($this->jwtConfigMock);

        $jwtManagement = new JwtManagement(
            $this->appConfigMock,
            $this->presentClock,
            $this->loggerMock
        );
        $jwtManagement->validate($this->requestMock);
    }


    #[DataProvider('getManipulatedInvalidToken')]
    public function testThrowsExceptionIfTokenWasManipulated(string $jwt, string $message): void
    {
        $this->expectExceptionObject(new InvalidArgumentException($message));

        $token = JsonWebToken::fromString(
            file_get_contents(self::BASE_PATH . $jwt)
        );
        $requestJwt = 'Bearer ' . $token->asString();

        $this->requestMock->method('getHeader')
            ->willReturn([$requestJwt]);

        $this->loggerMock->expects($this->never())
            ->method('info')
            ->with(LogMessage::fromString('Jwt is valid'));

        $this->configureJwtConfig(0, 0, 1, 1, 'HS512');

        $this->appConfigMock
            ->method('getJwtConfig')
            ->willReturn($this->jwtConfigMock);

        $this->usersReaderMock->expects($this->never())
            ->method('checkIfUserExists');

        $jwtManagement = new JwtManagement(
            $this->appConfigMock,
            $this->presentClock,
            $this->loggerMock
        );
        $jwtManagement->validate($this->requestMock);
    }


    #[DataProvider('getInvalidToken')]
    public function testThrowsExceptionIfTokenIsInvalid(
        string $jwt,
        string $message
    ): void {
        $this->expectExceptionObject(new RuntimeException($message));

        $token = JsonWebToken::fromString(
            file_get_contents(self::BASE_PATH . $jwt)
        );
        $requestJwt = 'Bearer ' . $token->asString();

        $this->requestMock->method('getHeader')
            ->willReturn([$requestJwt]);

        $this->loggerMock->expects($this->never())
            ->method('info')
            ->with(LogMessage::fromString('Jwt is valid'));
        $this->loggerMock->expects($this->once())
            ->method('error');

        $this->configureJwtConfig(0, 0, 1, 1, 'HS512');

        $this->appConfigMock
            ->method('getJwtConfig')
            ->willReturn($this->jwtConfigMock);

        $this->usersReaderMock->expects($this->never())
            ->method('checkIfUserExists');

        $jwtManagement = new JwtManagement(
            $this->appConfigMock,
            $this->presentClock,
            $this->loggerMock
        );
        $jwtManagement->validate($this->requestMock);
    }
}
